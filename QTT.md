



## QT前言

> 以下是一些适合用来练手的 Qt 项目，按照从简单到难的顺序排列：
>
> 1. 简单的计算器：创建一个简单的计算器应用程序，可以进行基本的数学运算，如加法、减法、乘法和除法。
> 2. TodoList 应用程序：创建一个简单的 TodoList 应用程序，可以添加、删除和编辑待办事项。
> 3. 图片查看器：创建一个简单的图片查看器，可以打开和浏览图片文件，并提供一些基本的操作，如缩放、旋转和切换图片。
> 4. 聊天应用程序：创建一个简单的聊天应用程序，可以实现基本的消息发送和接收功能，可以在本地或网络上进行通信。
> 5. 文件管理器：创建一个简单的文件管理器，可以浏览和管理文件和文件夹，提供基本的文件操作，如复制、粘贴和删除。
> 6. 图书馆管理系统：创建一个图书馆管理系统，可以管理图书的借阅和归还，提供图书搜索和借阅记录等功能。
> 7. 图形化绘图应用程序：创建一个具有绘图功能的应用程序，可以绘制基本的图形，如线条、矩形和椭圆，并提供颜色和线条宽度选择等功能。
> 8. 电子邮件客户端：创建一个简单的电子邮件客户端，可以发送和接收电子邮件，支持多个邮件账户和邮件夹管理。
> 9. 在线音乐播放器：创建一个在线音乐播放器，可以搜索和播放音乐，支持创建播放列表和收藏喜欢的音乐。
> 10. 3D 游戏：创建一个简单的 3D 游戏，可以实现基本的游戏功能，如角色移动、碰撞检测和得分计算。
>
> 这些项目涵盖了从简单到复杂的不同领域和功能。你可以根据自己的兴趣和能力选择适合的项目进行练手。在实现这些项目的过程中，你将学习和应用 Qt 的各种功能，提高自己的编程技能。
>
> ---
>
> ---
>
> 在使用 Qt 进行项目开发时，你需要掌握一些与 C++ 和 Qt 相关的知识。以下是一些你可能需要学习的主题：
>
> 1. C++ 基础知识：你需要熟悉 C++ 的基本语法、数据类型、控制流程、函数和类等概念。这些知识对于理解和编写 Qt 代码是基础。
>
> 2. Qt 基础知识：你需要学习 Qt 的基本概念和类库。这包括了 Qt 的核心模块（如 QObject、QWidget 和 QApplication）以及其他模块（如 Qt Widgets、Qt GUI 和 Qt Network）。你需要了解这些模块的类和功能，以便在项目中使用它们。
>
> 3. 信号与槽机制：Qt 使用信号与槽机制来实现对象之间的通信。你需要学习如何定义和连接信号与槽，以及如何在应用程序中使用它们。
>
> 4. Qt 布局管理器：Qt 提供了一套布局管理器来帮助你在窗口中进行控件布局。你需要学习如何使用布局管理器来自动调整和排列控件，以适应不同的窗口大小和分辨率。
>
> 5. Qt 事件处理：Qt 使用事件来处理用户输入和其他系统事件。你需要学习如何重写事件处理函数，以便在应用程序中响应和处理不同类型的事件。
>
> 6. Qt 文件和网络操作：在许多应用程序中，你可能需要进行文件读写和网络通信。你需要学习如何使用 Qt 提供的类来进行文件和网络操作，如 QFile、QDir、QNetworkAccessManager 和 QNetworkRequest。
>
> 7. Qt 多线程编程：如果你的应用程序需要进行并发处理或长时间运行的任务，你可能需要学习如何使用 Qt 的多线程机制来实现线程间的通信和同步。
>
> 8. Qt 数据库访问：如果你的应用程序需要与数据库进行交互，你需要学习如何使用 Qt 提供的数据库模块（如 QSqlDatabase 和 QSqlQuery）来连接和操作数据库。
>
> 以上是一些与 C++ 和 Qt 相关的主题，你可以根据自己的项目需求和兴趣选择学习的内容。Qt 官方文档和教程是学习这些知识的好资源，你可以参考它们来深入学习和实践。
>
> ---
>
> 1. **编写实际项目**：实践是学习编程的关键。尝试编写一些小型的Qt应用程序或项目，以应用您学到的知识。通过实际项目的编写，您可以更好地理解概念，发现问题并学习解决方案。
> 2. **参考示例代码**：Qt提供了大量的示例代码，涵盖了各种功能和应用场景。阅读和理解这些示例代码可以帮助您学习Qt的最佳实践和常用模式。
> 3. **参与社区**：加入Qt和C++的开发者社区，参与讨论和交流。这样可以与其他开发者分享经验、解决问题，并从他们的经验中学习。
> 4. **坚持练习**：编程需要不断的练习和实践。坚持练习编写代码，并尝试解决各种问题和挑战。通过不断地练习，您可以加深对Qt和C++的理解，并提高编程技能。
> 5. **多种学习资源**：除了官方文档外，还可以使用在线教程、书籍、视频教程等多种学习资源。选择适合您学习风格和需求的资源，以帮助您更好地学习Qt和C++。
> 6. **复习和总结**：定期复习和总结您学到的知识。回顾之前学习的内容，巩固和加深对概念和技术的理解。
> 7. **持续学习**：Qt和C++是广阔而深入的领域，持续学习是成为优秀程序员的关键。保持对新技术和最佳实践的学习兴趣，并持续提升自己的技能。
>
> 记住，学习编程需要时间和耐心。重要的是保持积极的学习态度，并坚持不懈地学习和实践。祝您在Qt和C++编程的学习中取得成功！

## QT打包

## c++类型转换***static_cast<>和reinterpret_cast<>***

> ## static_cast<>
>
> `static_cast<>` 是 C++ 中的一种**类型转换运算符**，用于在编译时进行类型转换。它可以用于将一种类型转换为另一种类型，包括基本类型、类类型和指针类型。
>
> `static_cast<>` 的语法如下：
>
> ```cpp
> static_cast<目标类型>(表达式)
> ```
>
> 其中，`目标类型` 是你希望将表达式转换为的类型，而 `表达式` 则是要进行转换的值或**变量**。
>
> 下面是一些示例用法：
>
> 1. 将整数转换为浮点数：
>
> ```cpp
> int num = 10;
> double result = static_cast<double>(num);
> ```
>
> 2. 将浮点数转换为整数：
>
> ```cpp
> double num = 3.14;
> int result = static_cast<int>(num);
> ```
>
> 3. *将指针类型转换为另一种指针类型*：
>
> ```cpp
> int* ptr = new int(10);
> char* result = static_cast<char*>(ptr);
> ```
>
> 需要注意的是，`static_cast<>` **不会执行运行时的类型检查**，因此转换的安全性需要由开发者自行保证。如果转换是不安全的，建议使用更加安全的类型转换运算符，如 `dynamic_cast<>` 或 `reinterpret_cast<>`。
>
> 总结起来，`static_cast<>` 是 C++ 中一种常用的类型转换运算符，**用于在编译时进行类型转换**。它可以将一种类型转换为另一种类型，但需要开发者自行确保转换的安全性。
>
> ---
>
> ---
>
> ---
>
> ## reinterpret_cast<>
>
> `reinterpret_cast<>` 是 C++ 中的一种类型转换运算符，用**于执行底层的强制类型转换**。它可以将一个指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。
>
> `reinterpret_cast<>` 的语法如下：
>
> ```cpp
> reinterpret_cast<目标类型>(表达式)
> ```
>
> 其中，`目标类型` 是你希望将表达式转换为的类型，而 `表达式` 则是要进行转换的值或变量。
>
> 下面是一些示例用法：
>
> 1. 将指针类型转换为另一种指针类型：
>
> ```cpp
> int* ptr = new int(10);
> char* result = reinterpret_cast<char*>(ptr);
> ```
>
> 2. 将指针类型转换为整数类型：
>
> ```cpp
> int* ptr = new int(10);
> uintptr_t result = reinterpret_cast<uintptr_t>(ptr);
> ```
>
> 3. 将整数类型转换为指针类型：
>
> ```cpp
> uintptr_t num = 12345;
> int* result = reinterpret_cast<int*>(num);
> ```
>
> 需要注意的是，`reinterpret_cast<>` 执行的是一种底层的强制类型转换，**它可以绕过编译器的类型检查**，因此需要开发者自行确保转换的安全性。使用 `reinterpret_cast<>` 进行类型转换时应该非常小心，确保转换的结果在语义上是合理的。
>
> 总结起来，`reinterpret_cast<>` 是 C++ 中一种类型转换运算符，用于执行底层的强制类型转换。它可以将指针或引用转换为另一种指针或引用类型，甚至可以将指针或引用转换为整数类型。使用 `reinterpret_cast<>` 进行类型转换时需要非常小心，确保转换的安全性和语义正确性。

## QT[快捷键](https://blog.csdn.net/xideaha/article/details/132365224?spm=1001.2014.3001.5501)

## QWIDGET

![image-20230731110426486](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230731110426486.png)

## Qdilog

![image-20230731111621860](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230731111621860.png)

## Qmainwindow

**菜单栏和状态栏只能有一个工具栏可以有多个**

![image-20230731112301130](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230731112301130.png)

## 字符串

![image-20230731201826875](E:\MD\QTT.assets\image-20230731201826875.png)



## Qbytearry

![image-20230803095410076](E:\MD\QTT.assets\image-20230803095410076.png)

> ### 构造函数

```c++
// 构造空对象, 里边没有数据
QByteArray::QByteArray();
// 将data中的size个字符进行构造, 得到一个字节数组对象
// 如果 size==-1 函数内部自动计算字符串长度, 计算方式为: strlen(data)
QByteArray::QByteArray(const char *data, int size = -1);
// 构造一个长度为size个字节, 并且每个字节值都为ch的字节数组
QByteArray::QByteArray(int size, char ch);
```

> ### 数据操作

```c++
// 在尾部追加数据
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &QByteArray::append(const QByteArray &ba);
void QByteArray::push_back(const QByteArray &other);

// 头部添加数据
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &QByteArray::prepend(const QByteArray &ba);
void QByteArray::push_front(const QByteArray &other);

// 插入数据, 将ba插入到数组第 i 个字节的位置(从0开始)
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &QByteArray::insert(int i, const QByteArray &ba);

// 删除数据
// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除
QByteArray &QByteArray::remove(int pos, int len);

// 从字符数组的尾部删除 n 个字节
void QByteArray::chop(int n);


// 从字节数组的 pos 位置将数组截断 (前边部分留下, 后边部分被删除)
void QByteArray::truncate(int pos);


// 将对象中的数据清空, 使其为null
void QByteArray::clear();

// 字符串替换
// 将字节数组中的 子字符串 before 替换为 after
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &QByteArray::replace(const QByteArray &before, const QByteArray &after);
```

> ### 子字符串查找和判断 

```c++
// 判断字节数组中是否包含子字符串 ba, 包含返回true, 否则返回false
bool QByteArray::contains(const QByteArray &ba) const;
bool QByteArray::contains(const char *ba) const;
// 判断字节数组中是否包含字符 ch, 包含返回true, 否则返回false
bool QByteArray::contains(char ch) const;

// 判断字节数组是否以字符串 ba 开始, 是返回true, 不是返回false
bool QByteArray::startsWith(const QByteArray &ba) const;
bool QByteArray::startsWith(const char *ba) const;
// 判断字节数组是否以字符 ch 开始, 是返回true, 不是返回false
bool QByteArray::startsWith(char ch) const;

// 判断字节数组是否以字符串 ba 结尾, 是返回true, 不是返回false
bool QByteArray::endsWith(const QByteArray &ba) const;
bool QByteArray::endsWith(const char *ba) const;
// 判断字节数组是否以字符 ch 结尾, 是返回true, 不是返回false
bool QByteArray::endsWith(char ch) const;


```

> ### 遍历

```c++
// 使用迭代器
iterator QByteArray::begin();
iterator QByteArray::end();

// 使用数组的方式进行遍历
// i的取值范围 0 <= i < size()
char QByteArray::at(int i) const;
char QByteArray::operator[](int i) const;
     for(int i=0;i<arry1.size();i++)
     {
         qDebug()<<arry1[i];
     }
```



> ### 查看字节数



```c++
// 返回字节数组对象中字符的个数
int QByteArray::length() const;
int QByteArray::size() const;
int QByteArray::count() const;

// 返回字节数组对象中 子字符串ba 出现的次数
int QByteArray::count(const QByteArray &ba) const;
int QByteArray::count(const char *ba) const;
// 返回字节数组对象中 字符ch 出现的次数
int QByteArray::count(char ch) const;

```



> ### 类型转换

```c++
// 将QByteArray类型的字符串 转换为 char* 类型
char *QByteArray::data();
const char *QByteArray::data() const;


先搞个空对象
    然后对象.set数据类型

// int, short, long, float, double -> QByteArray
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QByteArray &QByteArray::setNum(int n, int base = 10);
QByteArray &QByteArray::setNum(short n, int base = 10);
QByteArray &QByteArray::setNum(qlonglong n, int base = 10);
QByteArray &QByteArray::setNum(float n, char f = 'g', int prec = 6);
QByteArray &QByteArray::setNum(double n, char f = 'g', int prec = 6);

[static] QByteArray QByteArray::number(int n, int base = 10);
[static] QByteArray QByteArray::number(qlonglong n, int base = 10);
[static] QByteArray QByteArray::number(double n, char f = 'g', int prec = 6);

// QByteArray -> int, short, long, float, double
int QByteArray::toInt(bool *ok = Q_NULLPTR, int base = 10) const;
short QByteArray::toShort(bool *ok = Q_NULLPTR, int base = 10) const;
long QByteArray::toLong(bool *ok = Q_NULLPTR, int base = 10) const;
float QByteArray::toFloat(bool *ok = Q_NULLPTR) const;
double QByteArray::toDouble(bool *ok = Q_NULLPTR) const;


// std::string -> QByteArray
[static] QByteArray QByteArray::fromStdString(const std::string &str);
// QByteArray -> std::string
std::string QByteArray::toStdString() const;

// 所有字符转换为大写
QByteArray QByteArray::toUpper() const;
// 所有字符转换为小写
QByteArray QByteArray::toLower() const;
```





## QSTRING

![image-20230803095906153](E:\MD\QTT.assets\image-20230803095906153.png)

> ###  构造函数

```c++
// 构造一个空字符串对象
QString::QString();
// 将 char* 字符串 转换为 QString 类型
QString::QString(const char *str);
// 将 QByteArray 转换为 QString 类型
QString::QString(const QByteArray &ba);
// 其他重载的同名构造函数可参考Qt帮助文档, 此处略

```

> ### 数据操作



```c++
// 尾部追加数据
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString &QString::append(const QString &str);
QString &QString::append(const char *str);
QString &QString::append(const QByteArray &ba);
void QString::push_back(const QString &other);

// 头部添加数据
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString &QString::prepend(const QString &str);
QString &QString::prepend(const char *str);
QString &QString::prepend(const QByteArray &ba);
void QString::push_front(const QString &other);

// 插入数据, 将 str 插入到字符串第 position 个字符的位置(从0开始)
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString &QString::insert(int position, const QString &str);
QString &QString::insert(int position, const char *str);
QString &QString::insert(int position, const QByteArray &str);

// 删除数据
// 从大字符串中删除len个字符, 从第pos个字符的位置开始删除
QString &QString::remove(int position, int n);

// 从字符串的尾部删除 n 个字符
void QString::chop(int n);
// 从字节串的 position 位置将字符串截断 (前边部分留下, 后边部分被删除)
void QString::truncate(int position);
// 将对象中的数据清空, 使其为null
void QString::clear();

// 字符串替换
// 将字节数组中的 子字符串 before 替换为 after
// 参数 cs 为是否区分大小写, 默认区分大小写
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString &QString::replace(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);

```





> ### 子字符串查找和判断

```c++
// 参数 cs 为是否区分大小写, 默认区分大小写
// 其他重载的同名函数可参考Qt帮助文档, 此处略

// 判断字符串中是否包含子字符串 str, 包含返回true, 否则返回false
bool QString::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

// 判断字符串是否以字符串 ba 开始, 是返回true, 不是返回false
bool QString::startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

// 判断字符串是否以字符串 ba 结尾, 是返回true, 不是返回false
bool QString::endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

```



> ### 遍历

```c++
// 使用迭代器
iterator QString::begin();
iterator QString::end();

// 使用数组的方式进行遍历
// i的取值范围 0 <= position < size()
const QChar QString::at(int position) const
const QChar QString::operator[](int position) const;
```



> ### 查看字节数

```c++
// 返回字节数组对象中字符的个数 (字符个数和字节个数是不同的概念)
int QString::length() const;
int QString::size() const;
int QString::count() const;

// 返回字节串对象中 子字符串 str 出现的次数
// 参数 cs 为是否区分大小写, 默认区分大小写
int QString::count(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

```





> ### 类型转换



```c++
// 将int, short, long, float, double 转换为 QString 类型
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString &QString::setNum(int n, int base = 10);
QString &QString::setNum(short n, int base = 10);
QString &QString::setNum(long n, int base = 10);
QString &QString::setNum(float n, char format = 'g', int precision = 6);
QString &QString::setNum(double n, char format = 'g', int precision = 6);
[static] QString QString::number(long n, int base = 10);
[static] QString QString::number(int n, int base = 10);
[static] QString QString::number(double n, char format = 'g', int precision = 6);

// 将 QString 转换为 int, short, long, float, double 类型
int QString::toInt(bool *ok = Q_NULLPTR, int base = 10) const;
short QString::toShort(bool *ok = Q_NULLPTR, int base = 10) const;
long QString::toLong(bool *ok = Q_NULLPTR, int base = 10) const
float QString::toFloat(bool *ok = Q_NULLPTR) const;
double QString::toDouble(bool *ok = Q_NULLPTR) const;

// 将标准C++中的 std::string 类型 转换为 QString 类型
[static] QString QString::fromStdString(const std::string &str);
// 将 QString 转换为 标准C++中的 std::string 类型
std::string QString::toStdString() const;

// QString -> QByteArray
// 转换为本地编码, 跟随操作系统
QByteArray QString::toLocal8Bit() const;
// 转换为 Latin-1 编码的字符串 不支持中文
QByteArray QString::toLatin1() const;
// 转换为 utf8 编码格式的字符串 (常用)
QByteArray QString::toUtf8() const;

// 所有字符转换为大写
QString QString::toUpper() const;
// 所有字符转换为小写
QString QString::toLower() const;

```



> ### 字符串格式

```c++
// 其他重载的同名函数可参考Qt帮助文档, 此处略
QString QString::arg(const QString &a, 
          int fieldWidth = 0, 
          QChar fillChar = QLatin1Char( ' ' )) const;
QString QString::arg(int a, int fieldWidth = 0, 
          int base = 10, 
          QChar fillChar = QLatin1Char( ' ' )) const;

// 示例程序
int i;                // 假设该变量表示当前文件的编号
int total;            // 假设该变量表示文件的总个数
QString fileName;     // 假设该变量表示当前文件的名字
// 使用以上三个变量拼接一个动态字符串
QString status = QString("Processing file %1 of %2: %3")
                  .arg(i).arg(total).arg(fileName);

```



## Qvariant

![image-20230803085428989](E:\MD\QTT.assets\image-20230803085428989.png)

![image-20230803085516873](E:\MD\QTT.assets\image-20230803085516873.png)

Qvariant(10+20),涉及到隐式转换，用构造函数或**者,参数只能是标准数据类型**

现有一个QVariant空对象,,,,,,,,,,,,,,,,,,然后口对象.setvalue（10+20），就把实际计算的数据返回给了对象

T代表支持标准类型和我们自定义类型



![image-20230803085526477](E:\MD\QTT.assets\image-20230803085526477.png)

QVariant对象.type()



![image-20230803085534209](E:\MD\QTT.assets\image-20230803085534209.png)



QVariant对象.to 数据类型

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"

#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);


    int a=data(10,20).toInt();
    QString str=data("hello","world").toString();

    qDebug()<<a;
    qDebug()<<str;
}

MainWindow::~MainWindow()
{
    delete ui;
}


QVariant MainWindow::data(QVariant a,QVariant b)
{
    QVariant ret;
    if(a.type()==QVariant::Int&&b.type()==QVariant::Int)
    {
        ret=QVariant(a.toInt()+b.toInt());
    }
    else if(a.type()==QVariant::String&&b.type()==QVariant::String)
    {
//        ret=QVariant(a.toString()+b.toString());
        ret.setValue(a.toString()+b.toString());
    }
    return  ret;
}

```

## Qvariant：：自定义数据类型



![image-20230803090644987](E:\MD\QTT.assets\image-20230803090644987.png)



用Qvariant的



![image-20230803090805728](E:\MD\QTT.assets\image-20230803090805728.png)

![image-20230803090849381](E:\MD\QTT.assets\image-20230803090849381.png)

**----------------------------------- ---------------------------------- 使用方法-------------------------------------------------------**

![ ](E:\MD\QTT.assets\image-20230803091233080.png)

![ ](E:\MD\QTT.assets\image-20230803091121738.png)

**---------------------------------------------------------下面取出数据----------------------------------------------------------------------------**

> ### **c.value<数据类型>()返回<>里面的数据类型**

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"

#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    Student xrb;
    xrb.id=123;
    xrb.name="张大山";
    //1//
    QVariant c;
    c.setValue(xrb);

    //2//
    //QVariant v=QVariant::fromValue(xrb);

    if(c.canConvert<Student>())
    {

        Student temp=c.value<Student>();
        qDebug()<<temp.id;
        qDebug()<<temp.name;
    }


}

MainWindow::~MainWindow()
{
    delete ui;
}


```

![image-20230803085326234](E:\MD\QTT.assets\image-20230803085326234.png)

## QT位置和尺寸

![image-20230803140624518](E:\MD\QTT.assets\image-20230803140624518.png)

### QPOINT

![image-20230803140635397](E:\MD\QTT.assets\image-20230803140635397.png)

```c++
// 构造函数
// 构造一个坐标原点, 即(0, 0)
QPoint::QPoint();
// 参数为 x轴坐标, y轴坐标
QPoint::QPoint(int xpos, int ypos);

// 设置x轴坐标
void QPoint::setX(int x);
// 设置y轴坐标
void QPoint::setY(int y);

// 得到x轴坐标
int QPoint::x() const;
// 得到x轴坐标的引用
int &QPoint::rx();
// 得到y轴坐标
int QPoint::y() const;
// 得到y轴坐标的引用
int &QPoint::ry();

// 直接通过坐标对象进行算术运算: 加减乘除
QPoint &QPoint::operator*=(float factor);
QPoint &QPoint::operator*=(double factor);
QPoint &QPoint::operator*=(int factor);
QPoint &QPoint::operator+=(const QPoint &point);
QPoint &QPoint::operator-=(const QPoint &point);
QPoint &QPoint::operator/=(qreal divisor);

// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......
```

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
// 创建坐标对象
    QPoint p;
    QPoint p1(2,3);

//设置x，y坐标
    p.setX(10);
    p.setY(20);
    //2/2/2/2/2/

//得到x，y坐标
    qDebug()<<p.x();
    qDebug()<<p.y();
    qDebug()<<p1.x();
    qDebug()<<p1.y();

//得到x，y坐标的引用
    int &x1=p.rx();
    int &y1=p.ry();
    x1=100;
    y1=200;

    int &x2=p1.rx();
    int &y2=p1.ry();

    x2=1;
    y2=2;
//再次得到通过引用修改后的坐标
    qDebug()<<p.x();
    qDebug()<<p.y();
    qDebug()<<p1.x();
    qDebug()<<p1.y();

}

MainWindow::~MainWindow()
{
    delete ui;
}
10
20
2
3
100
200
1

```

----

### QLINE

![image-20230803141547493](E:\MD\QTT.assets\image-20230803141547493.png)

```c++
// 构造函数
// 构造一个空对象
QLine::QLine();
// 构造一条直线, 通过两个坐标点
QLine::QLine(const QPoint &p1, const QPoint &p2);
// 从点 (x1, y1) 到 (x2, y2)
QLine::QLine(int x1, int y1, int x2, int y2);

// 给直线对象设置坐标点
void QLine::setPoints(const QPoint &p1, const QPoint &p2);
// 起始点(x1, y1), 终点(x2, y2)
void QLine::setLine(int x1, int y1, int x2, int y2);
// 设置直线的起点坐标
void QLine::setP1(const QPoint &p1);
// 设置直线的终点坐标
void QLine::setP2(const QPoint &p2);

// 返回直线的起始点坐标
QPoint QLine::p1() const;
// 返回直线的终点坐标
QPoint QLine::p2() const;
// 返回值直线的中心点坐标, (p1() + p2()) / 2
QPoint QLine::center() const;

// 返回值直线起点的 x 坐标
int QLine::x1() const;
// 返回值直线终点的 x 坐标
int QLine::x2() const;
// 返回值直线起点的 y 坐标
int QLine::y1() const;
// 返回值直线终点的 y 坐标
int QLine::y2() const;

// 用给定的坐标点平移这条直线
void QLine::translate(const QPoint &offset);
void QLine::translate(int dx, int dy);
// 用给定的坐标点平移这条直线, 返回平移之后的坐标点
QLine QLine::translated(const QPoint &offset) const;
QLine QLine::translated(int dx, int dy) const;

// 直线对象进行比较
bool QLine::operator!=(const QLine &line) const;
bool QLine::operator==(const QLine &line) const;

// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......

```



```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QPoint p1(10,10);
    QPoint p2(20,20);

//创建直线，传入有参构造的时候直接传入两个点point
 //先创建一个空对象，然后空对象.setpoints
    //直接用四个参数的有参构造函数创建
    QLine line(p1,p2);
    QLine line1(1,2,3,4);
    QLine line2;
    line2.setPoints(p1,p2);
//可以得到直线的坐标起点，中点，重点.四个坐标，x1,x2,y1,y2或者得到起/末点再 .x()
    qDebug()<<line.p1();
    qDebug()<<line.p2();
    qDebug()<<line.center();
//    QPoint(10,20)
//    QPoint(20,40)
//    QPoint(15,30)

    //这个是根据这个点平移后，修改直线相当于方法使用
    // 平移线段的起点和终点，偏移量为 (5, 5)
    line.translate(5, 5);

    qDebug() << line.p1(); // 输出 (15, 15)
    qDebug() << line.p2(); // 输出 (55, 55)

    //这个是根据这个点平移后返回线段对象,相当于函数使用
    QLine newline=line.translated(10,20);
    qDebug() << newline.p1(); // 输出 (15, 15)
    qDebug() << newline.p2(); // 输出 (55, 55)

}

MainWindow::~MainWindow()
{
    delete ui;
}


```



### QSIZE

![image-20230803143027470](E:\MD\QTT.assets\image-20230803143027470.png)

```c++
// 构造函数
// 构造空对象, 对象中的宽和高都是无效的
QSize::QSize();
// 使用宽和高构造一个有效对象
QSize::QSize(int width, int height);

// 设置宽度
void QSize::setWidth(int width)
// 设置高度
void QSize::setHeight(int height);

// 得到宽度
int QSize::width() const;
// 得到宽度的引用
int &QSize::rwidth();
// 得到高度
int QSize::height() const;
// 得到高度的引用
int &QSize::rheight();

// 交换高度和宽度的值
void QSize::transpose();
// 交换高度和宽度的值, 返回交换之后的尺寸信息
QSize QSize::transposed() const;

// 进行算法运算: 加减乘除
QSize &QSize::operator*=(qreal factor);
QSize &QSize::operator+=(const QSize &size);
QSize &QSize::operator-=(const QSize &size);
QSize &QSize::operator/=(qreal divisor);

// 其他API请自行查询Qt帮助文档, 不要犯懒哦哦哦哦哦......

```

```c++
#include "mainwindow.h"

#include <QApplication>
#include <QDebug>
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
//实例化对象，注意无参的时候千万不能有（）；
    QSize p;
    QSize p1(20,30);

//手动设置宽高
    p.setWidth(10);
    p.setHeight(20);

//得到宽和高
    qDebug()<<p.width();
    qDebug()<<p.height();
    qDebug()<<p1.width();
    qDebug()<<p1.height();
//得到宽和高的引用并且修改
    int &w1=p.rwidth();
    int &w2=p1.rwidth();
    int &h1=p.rheight();
    int &h2=p1.rheight();

    w1=1;
    w2=1;
    h1=2;
    h2=2;

    qDebug()<<p.width();
    qDebug()<<p.height();
    qDebug()<<p1.width();
    qDebug()<<p1.height();

//将宽和高反转
    p.transpose();
    p1.transpose();
    qDebug()<<p.width();
    qDebug()<<p.height();
    qDebug()<<p1.width();
    qDebug()<<p1.height();
qDebug()<<"------------------";
//
    QSize newp=p.transposed();
    QSize newp1=p1.transposed();
    qDebug()<<newp.width();
    qDebug()<<newp.height();
    qDebug()<<newp1.width();
    qDebug()<<newp1.height();

    return a.exec();
}
10
20
20
30
    
1
2
1
2
    
2
1
2
1
------------------
1
2
1
2
```







### QRECT

![image-20230803144048156](E:\MD\QTT.assets\image-20230803144048156.png)

**长/宽是末减初+1**

```c++
// 构造函数
// 构造一个空对象
QRect::QRect();
// 基于左上角坐标, 和右下角坐标构造一个矩形对象
QRect::QRect(const QPoint &topLeft, const QPoint &bottomRight);


默认是左上角和右下角的关系，如果穿了一个左下角和一个右上角的，顺序就相反了，避免
// 基于左上角坐标, 和 宽度, 高度构造一个矩形对象
QRect::QRect(const QPoint &topLeft, const QSize &size);

长/宽是末减初+1
    
    
// 通过 左上角坐标(x, y), 和 矩形尺寸(width, height) 构造一个矩形对象
QRect::QRect(int x, int y, int width, int height);

// 设置矩形的尺寸信息, 左上角坐标不变
void QRect::setSize(const QSize &size);
// 设置矩形左上角坐标为(x,y), 大小为(width, height)
void QRect::setRect(int x, int y, int width, int height);
// 设置矩形宽度
void QRect::setWidth(int width);
// 设置矩形高度
void QRect::setHeight(int height);

// 返回值矩形左上角坐标
QPoint QRect::topLeft() const;
// 返回矩形右上角坐标
// 该坐标点值为: QPoint(left() + width() -1, top())
QPoint QRect::topRight() const;
// 返回矩形左下角坐标
// 该坐标点值为: QPoint(left(), top() + height() - 1)
QPoint QRect::bottomLeft() const;
// 返回矩形右下角坐标
// 该坐标点值为: QPoint(left() + width() -1, top() + height() - 1)
QPoint QRect::bottomRight() const;
// 返回矩形中心点坐标
QPoint QRect::center() const;

// 返回矩形上边缘y轴坐标
int QRect::top() const;
int QRect::y() const;
// 返回值矩形下边缘y轴坐标
int QRect::bottom() const;
// 返回矩形左边缘 x轴坐标
int QRect::x() const;
int QRect::left() const;
// 返回矩形右边缘x轴坐标
int QRect::right() const;

// 返回矩形的高度
int QRect::width() const;
// 返回矩形的宽度
int QRect::height() const;
// 返回矩形的尺寸信息
QSize QRect::size() const;
```

## 日期和时间

### QDATE

需要引入头文件！

![image-20230804080321434](E:\MD\QTT.assets\image-20230804080321434.png)

```c++
// 构造函数
QDate::QDate();
QDate::QDate(int y, int m, int d);

// 公共成员函数
// 重新设置日期对象中的日期
bool QDate::setDate(int year, int month, int day);
// 给日期对象添加 ndays 天
QDate QDate::addDays(qint64 ndays) const;
// 给日期对象添加 nmonths 月
QDate QDate::addMonths(int nmonths) const;
// 给日期对象添加 nyears 月
QDate QDate::addYears(int nyears) const;

// 得到日期对象中的年/月/日
int QDate::year() const;
int QDate::month() const;
int QDate::day() const;
void QDate::getDate(int *year, int *month, int *day) const;

// 日期对象格式化
/*
    d    - The day as a number without a leading zero (1 to 31)
    dd   - The day as a number with a leading zero (01 to 31)
    ddd	 -  周四
    dddd - 星期四
    M    - The month as a number without a leading zero (1 to 12)
    MM   - The month as a number with a leading zero (01 to 12)
    MMM	 9月
    MMMM 九月
    yy   - The year as a two digit number (00 to 99)
    yyyy - The year as a four digit number. If the year is negative, a minus sign is prepended, making five characters.
*/
QString QDate::toString(const QString &format) const;

// 操作符重载 ==> 日期比较
bool QDate::operator!=(const QDate &d) const;
bool QDate::operator<(const QDate &d) const;
bool QDate::operator<=(const QDate &d) const;
bool QDate::operator==(const QDate &d) const;
bool QDate::operator>(const QDate &d) const;
bool QDate::operator>=(const QDate &d) const;

// 静态函数 -> 得到本地的当前日期
[static] QDate QDate::currentDate();
```

```c++
    #include "mainwindow.h"
    #include "ui_mainwindow.h"
    #include <QDate>
    #include <QDebug>
    MainWindow::MainWindow(QWidget *parent)
        : QMainWindow(parent)
        , ui(new Ui::MainWindow)
    {
        ui->setupUi(this);
        QDate a(2023,8,4);
        QDate b;
        b.setDate(2023,8,5);
        //////
        QDate c=QDate::currentDate();
        //////
        qDebug()<<c;
        c=c.addDays(10);
        c=c.addMonths(1);
        qDebug()<<c;
        qDebug()<<c.year();

        QString str=c.toString("yy-MMM-ddd");
        qDebug()<<str;


    }

    MainWindow::~MainWindow()
    {
        delete ui;
    }


```



### QTIME

![image-20230804082459651](E:\MD\QTT.assets\image-20230804082459651.png)

```c++
// 构造函数
QTime::QTime();
/*
    h 		==> 取值范围： 0 ~ 23
    m and s 	==> 取值范围： 0 ~ 59
    ms 		==> 取值范围： 0 ~ 999
*/ 
QTime::QTime(int h, int m, int s = 0, int ms = 0);

// 公共成员函数
// Returns true if the set time is valid; otherwise returns false.
bool QTime::setHMS(int h, int m, int s, int ms = 0);
QTime QTime::addSecs(int s) const;
QTime QTime::addMSecs(int ms) const;

// 示例代码
  QTime n(14, 0, 0);                // n == 14:00:00
  QTime t;
  t = n.addSecs(70);                // t == 14:01:10
  t = n.addSecs(-70);               // t == 13:58:50
  t = n.addSecs(10 * 60 * 60 + 5);  // t == 00:00:05
  t = n.addSecs(-15 * 60 * 60);     // t == 23:00:00

// 从时间对象中取出 时/分/秒/毫秒
// Returns the hour part (0 to 23) of the time. Returns -1 if the time is invalid.
int QTime::hour() const;
// Returns the minute part (0 to 59) of the time. Returns -1 if the time is invalid.
int QTime::minute() const;
// Returns the second part (0 to 59) of the time. Returns -1 if the time is invalid.
int QTime::second() const;
// Returns the millisecond part (0 to 999) of the time. Returns -1 if the time is invalid.
int QTime::msec() const;


// 时间格式化
/*
    -- 时 --
    h	==>	The hour without a leading zero (0 to 23 or 1 to 12 if AM/PM display)
    hh	==>	The hour with a leading zero (00 to 23 or 01 to 12 if AM/PM display)
    H	==>	The hour without a leading zero (0 to 23, even with AM/PM display)
    HH	==>	The hour with a leading zero (00 to 23, even with AM/PM display)
    -- 分 --
    m	==>	The minute without a leading zero (0 to 59)
    mm	==>	The minute with a leading zero (00 to 59)
    -- 秒 --
    s	==>	The whole second, without any leading zero (0 to 59)
    ss	==>	The whole second, with a leading zero where applicable (00 to 59)
    -- 毫秒 --
    zzz	==>	The fractional part of the second, to millisecond precision, 
			including trailing zeroes where applicable (000 to 999).
    -- 上午或者下午
    AP or A	==>	使用AM/PM(大写) 描述上下午, 中文系统显示汉字
    ap or a	==>	使用am/pm(小写) 描述上下午, 中文系统显示汉字
*/
QString QTime::toString(const QString &format) const;

// 阶段性计时
// 过时的API函数
// 开始计时
void QTime::start();
// 计时结束
int QTime::elapsed() const;
// 重新计时
int QTime::restart();

// 推荐使用的API函数
// QElapsedTimer 类
void QElapsedTimer::start();
qint64 QElapsedTimer::restart();
qint64 QElapsedTimer::elapsed() const;


// 操作符重载 ==> 时间比较
bool QTime::operator!=(const QTime &t) const;
bool QTime::operator<(const QTime &t) const;
bool QTime::operator<=(const QTime &t) const;
bool QTime::operator==(const QTime &t) const;
bool QTime::operator>(const QTime &t) const;
bool QTime::operator>=(const QTime &t) const;

// 静态函数 -> 得到当前时间
[static] QTime QTime::currentTime();
```

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QTime>
#include <QDebug>
#include <QElapsedTimer>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QElapsedTimer time;
    time.start();
    QTime a(8,26,40,999);
//    h 0~23
//    m 0~59
//    s 0~59
//    ms 0~999
    qDebug()<<a;
    qDebug()<<a.hour();
    qDebug()<<a.minute();
    qDebug()<<a.second();
    qDebug()<<a.msec();
    QTime b;
    b.setHMS(20,20,20,20);
    qDebug()<<b;
    QTime c=c.currentTime();
    qDebug()<<c;
//    QTime("08:35:08.486")
    qint64 time1=time.elapsed();
    qDebug()<<time1;

        QElapsedTimer timer;

        timer.start(); // 开始计时

        // 执行一些需要测量的代码
        for (int i = 0; i < 300; i++) {
            qDebug()<<"-";
        }

        qint64 elapsedTime = timer.elapsed(); // 获取经过的时间（以毫秒为单位）
        qDebug() << "Elapsed Time:" << elapsedTime << "ms";
//        Elapsed Time: 7 ms
}

MainWindow::~MainWindow()
{
    delete ui;
}
```



### QDATETIME

![image-20230804084530792](E:\MD\QTT.assets\image-20230804084530792.png)

```Cpp
// 构造函数
QDateTime::QDateTime();
QDateTime::QDateTime(const QDate &date, const QTime &time, Qt::TimeSpec spec = Qt::LocalTime);

// 公共成员函数
// 设置日期
void QDateTime::setDate(const QDate &date);
// 设置时间
void QDateTime::setTime(const QTime &time);
// 给当前日期对象追加 年/月/日/秒/毫秒, 参数可以是负数
QDateTime QDateTime::addYears(int nyears) const;
QDateTime QDateTime::addMonths(int nmonths) const;
QDateTime QDateTime::addDays(qint64 ndays) const;
QDateTime QDateTime::addSecs(qint64 s) const;
QDateTime QDateTime::addMSecs(qint64 msecs) const;

// 得到对象中的日期
QDate QDateTime::date() const;
// 得到对象中的时间
QTime QDateTime::time() const;

// 日期和时间格式, 格式字符参考QDate 和 QTime 类的 toString() 函数
QString QDateTime::toString(const QString &format) const;


// 操作符重载 ==> 日期时间对象的比较
bool QDateTime::operator!=(const QDateTime &other) const;
bool QDateTime::operator<(const QDateTime &other) const;
bool QDateTime::operator<=(const QDateTime &other) const;
bool QDateTime::operator==(const QDateTime &other) const;
bool QDateTime::operator>(const QDateTime &other) const;
bool QDateTime::operator>=(const QDateTime &other) const;

// 静态函数
// 得到当前时区的日期和时间(本地设置的时区对应的日期和时间)
[static] QDateTime QDateTime::currentDateTime();

```

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QTime>
#include <QDate>
#include <QDateTime>
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QDate date(2023,8,4);
    QTime time(8,55,30,876);
    QDateTime datetime(date,time);
    qDebug()<<datetime;

    QDateTime newtime;
    newtime.setDate(date);
    newtime.setTime(time);


    newtime=newtime.addDays(1);
    newtime=newtime.addSecs(23);
        qDebug()<<newtime;
        
    QDateTime now= QDateTime::currentDateTime();
qDebug()<<now;
        
   QString str=now.toString("yyyy-MM-dddd hh:mm:ss ap");
   qDebug()<<str;
}

MainWindow::~MainWindow()
{
    delete ui;
}


```



## QT坐标体系



![image-20230731112623738](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230731112623738.png)

子窗口相对于父窗口的坐标原点来进行的

用的坐标体系不一样



`MainWindow`类继承自`QMainWindow`，并且使用`Ui_MainWindow`类来进行界面的设置。所以在`MainWindow`构造函数中调用了`ui->setupUi(this)`方法，将`MainWindow`作为参数传递给它，从而创建和设置了界面。

![image-20230731114247952](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230731114247952.png)

至于为什么按钮不需要调用`show()`方法就可以显示，是因为在`ui->setupUi(this)`方法中已经包括了按钮的初始化和显示设置。`setupUi()`方法会创建和设置窗口中所有的控件，并根据布局和样式等配置来显示它们。所以当你调用`this->show()`来显示窗口时，已经包含了按钮的显示。

![image-20230731114232016](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230731114232016.png)

## QT内存回收机制

> Qt的内存回收机制主要是基于对象树的概念。当**你在Qt中创建一个对象并指定了父对象时，父对象会负责管理其子对象的生命周期。**具体来说，**当父对象被销毁时，它会自动销毁其所有子对象。**
>
> **这种内存回收机制的优势在于，你无需手动释放子对象的内存，而是将其交给父对象去管理。这简化了内存管理的工作，并确保了对象之间的正确关系。**
>
> 在你提到的情况中，当你在堆区创建一个控件并将其指定为父窗口的子控件时，父窗口会成为该控件的父对象。**当父窗口关闭时，它会自动销毁其所有子控件，包括在堆区创建的控件。这就利用了Qt的内存回收机制，确保了子控件的正确释放。**
>
> 需要注意的是，Qt的内存回收机制只适用于通过对象树进行管理的对象。如果你在堆区创建了一个对象，但没有设置其父对象，那么它将不会被自动释放，你需要手动管理其生命周期，确保在不再需要时进行释放。

**qt机制非常的聪明，他会检测一个内存是否被释放，如果被释放了就不再释放。！！！！！！**

**![image-20230808120713278](E:\MD\QTT.assets\image-20230808120713278.png)

![image-20230731114806690](E:\MD\QTT.assets\image-20230731114806690.png)

![image-20230731114857012](E:\MD\QTT.assets\image-20230731114857012.png)

![image-20230731115011091](E:\MD\QTT.assets\image-20230731115011091.png)



![image-20230731124251606](E:\MD\QTT.assets\image-20230731124251606.png)

![image-20230731195036189](E:\MD\QTT.assets\image-20230731195036189.png)

先析构自己后析构儿子



父类中创建子类 的话是，先构建儿子后构建父亲

设置父对象，父对象析构的时候会自动把儿子给析构掉

> 1. 当类对象作为类成员的时候，先构造儿子后构造父亲，析构相反



## QT的基础类型

![image-20230731195225067](E:\MD\QTT.assets\image-20230731195225067.png)





## LOG输出



QDebug类

qDebug（）方法

![image-20230731201638457](E:\MD\QTT.assets\image-20230731201638457.png)

实现控制台 在外部

## 信号和槽机制



![image-20230802140725492](E:\MD\QTT.assets\image-20230802140725492.png)

![image-20230802140908764](E:\MD\QTT.assets\image-20230802140908764.png)

​		



`connect`函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。

> #### connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。
>
> #### connect(btn,&QPushButton::clicked,this,&MainWindow::close);

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QPushButton>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    QPushButton*btn=new QPushButton(this);
    btn->show();
    btn->setText("第一个按钮");
    btn->setFixedSize(200,200);
    btn->move(300,300);

    //connect函数的连接参数应该是函数指针或者函数对象，并且需要使用信号槽机制进行连接。
    connect(btn,&QPushButton::clicked,this,&MainWindow::close);
}

MainWindow::~MainWindow()
{
    delete ui;
}


```







---

![image-20230802143040664](E:\MD\QTT.assets\image-20230802143040664.png)

![image-20230802143003435](E:\MD\QTT.assets\image-20230802143003435.png)

![image-20230802143021118](E:\MD\QTT.assets\image-20230802143021118.png)

![image-20230802143124345](E:\MD\QTT.assets\image-20230802143124345.png)

![image-20230802143142947](E:\MD\QTT.assets\image-20230802143142947.png)

![image-20230802143158612](E:\MD\QTT.assets\image-20230802143158612.png)

![image-20230802143235656](E:\MD\QTT.assets\image-20230802143235656.png)

![image-20230802143313999](E:\MD\QTT.assets\image-20230802143313999.png)



> ## **找的时候，如果没有，就去找他的基类！！！！！**
>
> #### 1.确定，信号发出者和信号接收者的类型 ！！！
>
> #### 2,确定 对应的信号和槽函数，传入函数的地址，&信号发出者::对应的信号函数,&信号接受者::对应的槽函数,

![image-20230802143351803](E:\MD\QTT.assets\image-20230802143351803.png)

![image-20230802161504786](E:\MD\QTT.assets\image-20230802161504786.png)

```
功能实现： 点击窗口上的按钮, 关闭窗口
功能分析:
	- 按钮: 信号发出者          -> QPushButton 类型
	- 窗口: 信号的接收者和处理者  -> QWidget 类型
```

![image-20230802143600142](E:\MD\QTT.assets\image-20230802143600142.png)

```
// 单击按钮发出的信号
[signal] void QAbstractButton::clicked(bool checked = false)
// 关闭窗口的槽函数
[slot] bool QWidget::close();
```

最终连接起来

```
// 单击按钮关闭窗口
connect(btn, &QPushButton::clicked, this, &MainWindow::close);
```



★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

> connect()操作一般写在**窗口的构造函数中**，相当于在***事件产生之前在qt框架中先进行注册***，这样在程序运行过程中**假设产生了按钮的点击事件，框架就会调用信号接收者对象对应的槽函数了，如果信号不产生，槽函数也就一直不会被调用。**可不是connect一调用就发生了

★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

## 自定义信号和槽



![image-20230802143851525](E:\MD\QTT.assets\image-20230802143851525.png)





### **创建新的类的注意事项**：：：：：：：：：：

---

在Qt中，创建新的类来定义自定义信号和槽时，有以下要求：

**如果要继承QObject和使用Q_OBJECT宏的时候就要引入对应的文件**

```
#include <QObject>
```

1. **继承自QObject类：**或者继承QObject的子类也就是间接继承QObject
   **新的类必须继承/间接继承自QObject类，以便能够使用Qt的信号和槽机制。**

   ```cpp
   class MyClass : public QObject
   {
       Q_OBJECT
       // ...
   };
   ```

2. **添加Q_OBJECT宏**：
   在新的类的声明中，需要添加Q_OBJECT宏。**这个宏告诉Qt元对象编译器（MOC）生成必要的代码，以支持信号和槽的使用。**

   ```cpp
   class MyClass : public QObject
   {
       Q_OBJECT
       // ...
   };
   ```

3. **声明信号和槽函数：**
   在新的类中，可以声明自定义的信号和槽函数。**信号函数声明在`signals`关键字下，槽函数声明在`public slots`关键字下。**

   ```cpp
   class MyClass : public QObject
   {
       Q_OBJECT
   public:
       explicit MyClass(QObject *parent = nullptr);
   
   signals:
       void mySignal(int value);
   
   public slots:
       void mySlot(int value);
   };
   ```

4. **实现信号和槽函数：**
   在新的类的实现中，可以实现自定义的信号和槽函数。**信号函数使用`emit`关键字来发出信号，槽函数用于接收信号并进行相应的处理。**

   ```cpp
   MyClass::MyClass(QObject *parent) : QObject(parent)
   {
       // ...
   }
   
   void MyClass::mySlot(int value)
   {
       // 处理槽函数的代码
   }
   
   void MyClass::mySignal(int value)
   {
       emit mySignal(value);
   }
   ```

### **信号和槽函数的要求**

信号L:::::::::::

![image-20230802145005632](E:\MD\QTT.assets\image-20230802145005632.png)

槽函数::":":"::""::"":

![image-20230802145635876](E:\MD\QTT.assets\image-20230802145635876.png)

---

**`explicit` 是一个关键字，用于指示该构造函数是显式的，即只能显式地调用该构造函数来创建对象，不能通过隐式转换进行对象的创建。**

![image-20230802150120972](E:\MD\QTT.assets\image-20230802150120972.png)

![image-20230802150135749](E:\MD\QTT.assets\image-20230802150135749.png)

![image-20230802211915437](E:\MD\QTT.assets\image-20230802211915437.png)

```
connect(const QObject *sender, &QObject::signal, 
        const QObject *receiver, &QObject::siganl-new);

```

**信号和槽是可以断开的！**

```
disconnect(const QObject *sender, &QObject::signal, 
        const QObject *receiver, &QObject::method);
```

信号和槽的链接

```
// 信号和槽函数也就是第2,4个参数传递的是地址, 编译器在编译过程中会对数据的正确性进行检测
connect(const QObject *sender, &QObject::signal, 
        const QObject *receiver, &QObject::method);
```

![image-20230804165512586](E:\MD\QTT.assets\image-20230804165512586.png)

![image-20230804170500811](E:\MD\QTT.assets\image-20230804170500811.png)

### 连接自定义的信号和槽

在这个表达式中，`void (Me::*mysignal)(QString)` 定义了一个函数指针类型，该函数指针可以指向 Me 类的成员函数，该成员函数的返回类型为 `void`，接受一个 `QString` 类型的参数。

`&Me::eat` 是一个成员函数的指针，它指向 Me 类的 `eat` 成员函数。

通过将 `&Me::eat` 赋值给 `mysignal`，将 `mysignal` 指向了 Me 类的 `eat` 成员函数。

这样，`mysignal` 就可以被用作函数指针，可以通过它来调用 Me 类的 `eat` 成员函数。



![image-20230802152316588](E:\MD\QTT.assets\image-20230802152316588.png)

![image-20230802152322169](E:\MD\QTT.assets\image-20230802152322169.png)

```
// 举例：
void (类名::*func1)(QString) = &Me::eat;	// func1指向带参的信号
void (Me::*func2)() = &Me::hungury;	// func2指向不带参的槽函数
```

> class Me : public QObject
> {
>     Q_OBJECT
>     // Qt4中的槽函数必须这样声明, qt5中的关键字 slots 可以被省略
> public slots:
>     void eat();
>     void eat(QString somthing);
>     signals:
>     void hungury();
>     void hungury(QString somthing);
> };
>
> // 基于上边的类写出解决方案
> // 处理如下逻辑: 我饿了, 我要吃东西
> // 分析: 信号的发出者是我自己, 信号的接收者也是我自己
> Me m;
> // Qt4处理方式
> connect(&m, SIGNAL(eat()), &m, SLOT(hungury()));
> connect(&m, SIGNAL(eat(QString)), &m, SLOT(hungury(QString)));
>
> // Qt5处理方式
> connect(&m, &Me::eat, &m, &Me::hungury);	// error
>
> 因为发生了重载
>
> //两个函数指针代替
>     //函数指针
> //    void (Student::*myslot)(QString)=&Student::treat_special;
> //    void (Teacher::*mysignal)(QString)=&Teacher::Teacher_is_hungery_but;
> //    connect(teacher,mysignal,student,myslot);

![image-20230804102156503](E:\MD\QTT.assets\image-20230804102156503.png)

**成员函数指针是一个与类相关联的指针**，它可以用来调用该类的成员函数。它不需要特定的对象实例来初始化，只需要指定成员函数的类型和类的名称即可。

按钮触发下课

下课触发老师饿了

老师饿了触发学生请吃饭



```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "student.h"
#include "teacher.h"
#include <QPushButton>

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
//    创建对象
    teacher=new Teacher;
    student=new Student;
//两个函数指针代替
    //函数指针
//    void (Student::*myslot)(QString)=&Student::treat_special;
//    void (Teacher::*mysignal)(QString)=&Teacher::Teacher_is_hungery_but;
//    connect(teacher,mysignal,student,myslot);
//    --------------
//    原始写法，函数名的地址
    connect(teacher,&Teacher::Teacher_is_hungery_but,student,&Student::treat_special);
//创建一个按钮
    QPushButton *btn=new QPushButton(this);
    btn->setFixedSize(100,100);
    btn->setText("老师饿了");
    btn->move(500,500);
    btn->show();

//#点击按钮触发下课函数
     connect(btn,&QPushButton::clicked,this,&MainWindow::classover);

//错误的写法
//     connect(btn,&QPushButton::clicked,teacher,&Teacher::Teacher_is_hungery_but("大竹比"));


//    信号连接信号,点击按钮触发老师饿了
//     connect(btn,&QPushButton::clicked,teacher,&Teacher::Teacher_is_hungery);
//     connect(btn,&QPushButton::clicked,std::bind(&Teacher::Teacher_is_hungery_but,teacher,"大竹比"));
//      connect(btn, &QPushButton::clicked, std::bind(&Teacher::Teacher_is_hungery_but, teacher, "大苏打"));
     classover();
        
        //////////////////
    void (QToolBox::*s)(int)=&QToolBox::currentChanged;

    connect(tb,s,this,[=](int index){
        qDebug()<<"新年好"<<index;
    });
        ////////////////////




     connect(ui->closebtn,&QPushButton::clicked,this,&MainWindow::close);




}

//下课函数触发老师饿了
void MainWindow:: classover(){
    //下课函数出发老师饿了的信号
//    emit zt->hungery();
    emit teacher->Teacher_is_hungery_but("宫保鸡丁");
}
MainWindow::~MainWindow()
{
    delete ui;
}


```

==**EMIT只是帮助程序员一眼看出这是在发出信号。。。。。不写也是ok的。**==

## 自定义类！继承

先添加一个继承自 `QObject` 的类，然后将其修改为继承自=== `QTextEdit`==。修改类的继承关系后，还需要在 `.cpp` 文件中做一些相应的修改。

首先，你需要将类的声明中的 `Qobject` 修改为 `QTextEdit`，如下所示：

```cpp
class MyTextEdit : public ////QTextEdit///
{
    Q_OBJECT

public:
    MyTextEdit(QWidget *parent = nullptr);
};
```

接下来，在 `.cpp` 文件中，你需要修改构造函数的定义，将 `Qobject` 修改为 `QTextEdit`，并将函数名改为 `MyTextEdit::MyTextEdit(QWidget *parent)`，如下所示：

```cpp
MyTextEdit::MyTextEdit(QWidget *parent)
    : //QTextEdit//(parent)
{

}
```



## ui控件的使用

![image-20230802162620319](E:\MD\QTT.assets\image-20230802162620319.png)

```cpp
     connect(ui->closebtn,&QPushButton::clicked,this,&MainWindow::close);
```

## 添加新的类

直接继承QOBject 巨好用

![image-20230802210658189](E:\MD\QTT.assets\image-20230802210658189.png)

## LAMBDA表达式

![image-20230804102405111](E:\MD\QTT.assets\image-20230804102405111.png)

![image-20230804102428896](E:\MD\QTT.assets\image-20230804102428896.png)

```c++
[capture](params) opt -> ret {body;};
    - capture: 捕获列表	
    - params: 参数列表
    - opt: 函数选项
    - ret: 返回值类型
    - body: 函数体
```

![image-20230804102818196](E:\MD\QTT.assets\image-20230804102818196.png)

![image-20230804103654121](E:\MD\QTT.assets\image-20230804103654121.png)

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
//定义
//    [](){
//        qDebug()<<"你好啊草";
//    };

        
        
//    [](){
//        qDebug()<<"你好啊草";
//    }();
        //()
/// /  ////   /  //相当于调用了这个函数//
    int a=[](int a)->int{
        return a;
    }(100);
    qDebug()<<"你好啊"<<a;

}

MainWindow::~MainWindow()
{
    delete ui;
}


```

![image-20230804103725913](E:\MD\QTT.assets\image-20230804103725913.png)

> 就是说如果[=]
>
> 把外部变量都捕获了，但只是可读的状态。
>
> 可以opt加上mutable，是可以修改了，但是修改的是拷贝过来的副本
>
> 
>
> 而[&]
>
> 也是把外部所有的变量以引用的形式拷贝过来，但是可以修改，因为操作的是内存地址
>
> [this]指代表我们只能访问我们类内的成员变量
>
> [=]/[&]，代表我们可以访问匿名函数体以外的所有外部变量，相当于是[this]的超集

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    [](){
        qDebug()<<"你好啊草";
    }();
    int a=[](int a)->int{
        return a;
    }(100);
    qDebug()<<"你好啊"<<a;

    int b=100;


    [&](){
        b=200;
    }();

    [=]()mutable{
        b=300;
    }();
    qDebug()<<"你好啊"<<b;

}

MainWindow::~MainWindow()
{
    delete ui;
}


```

```c++
      connect(btn, &QPushButton::clicked, std::bind(&Teacher::Teacher_is_hungery_but, teacher, "大苏打"));
      ////////////////////////////////////
      connect(btn, &QPushButton::clicked,teacher,[=](){
         emit teacher->Teacher_is_hungery_but("意大dasdadasdad利面");
      });
```



## QTIMER

![image-20230804140750932](E:\MD\QTT.assets\image-20230804140750932.png)

> ##### 启动器在启动的同时需要指定对应的时间间隔.

```c++
// 构造函数
// 如果指定了父对象, 创建的堆内存可以自动析构
QTimer::QTimer(QObject *parent = nullptr);

// 设置定时器时间间隔为 msec 毫秒
// 默认值是0，一旦窗口系统事件队列中的所有事件都已经被处理完，一个时间间隔为0的QTimer就会触发
void QTimer::setInterval(int msec);
// 获取定时器的时间间隔, 返回值单位: 毫秒
int QTimer::interval() const;

// 根据指定的时间间隔启动或者重启定时器, 需要调用 setInterval() 设置时间间隔
[slot] void QTimer::start();

// 启动或重新启动定时器，超时间隔为msec毫秒。
[slot] void QTimer::start(int msec);

// 停止定时器。
[slot] void QTimer::stop();

// 设置定时器精度
/*
参数: 
    - Qt::PreciseTimer -> 精确的精度, 毫秒级
    - Qt::CoarseTimer  -> 粗糙的精度, 和1毫秒的误差在5%的范围内, 默认精度
    - Qt::VeryCoarseTimer -> 非常粗糙的精度, 精度在1秒左右
*/
void QTimer::setTimerType(Qt::TimerType atype);
Qt::TimerType QTimer::timerType() const;	// 获取当前定时器的精度

// 如果定时器正在运行，返回true; 否则返回false。
bool QTimer::isActive() const;

// 判断定时器是否只触发一次
bool QTimer::isSingleShot() const;
// 设置定时器是否只触发一次, 参数为true定时器只触发一次, 为false定时器重复触发, 默认为false
void QTimer::setSingleShot(bool singleShot);


```

![image-20230804173619288](E:\MD\QTT.assets\image-20230804173619288.png)

> 1. ##### 首先要创建定时器
>
> 2. ##### 设置好时间间隔,这是必要的
>
> 3. 其次可以设置无关紧要的定时器类型
>
> 4. 有两个状态is
>
> 5. 有个静态函数，返回值为void,可以搞一个几秒钟发射信号给谁，谁在做出具体的行为
>
> 6. ![image-20230804165526274](E:\MD\QTT.assets\image-20230804165526274.png)

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include  <QTimer>
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
//创建定时器对象，默认是粗糙的定时器
    QTimer timer(this);
//    设置定时器的类型
    timer.setTimerType(Qt::PreciseTimer);
    timer.start(3000);
    qDebug()<<timer.isActive();
    qDebug()<<timer.isSingleShot();
    connect(ui->closebtn,&QPushButton::clicked,this,&MainWindow::close);
    qDebug()<<timer.timerType();
    //静态函数,返回为void，设置有几秒发射一次信号,谁来接受，以及行为
    QTimer::singleShot(3000,this,&MainWindow::close);


    //这个
 ///////////////////////////////
    connect(&timer,&QTimer::timeout,this,&MainWindow::close);

}

MainWindow::~MainWindow()
{
    delete ui;
}


```

> ##### 周期性定时器

```c++
// 创建定时器对象
QTimer* timer = new QTimer(this);

// 修改定时器对象的精度
timer->setTimerType(Qt::PreciseTimer);

// 按钮 loopBtn 的点击事件
// 点击按钮启动或者关闭定时器, 定时器启动, 周期性得到当前时间
connect(ui->loopBtn, &QPushButton::clicked, this, [=]()
{
    // 启动定时器
    if(timer->isActive())
    {
        timer->stop();  // 关闭定时器
        ui->loopBtn->setText("开始");
    }
    else
    {
        ui->loopBtn->setText("关闭");
        timer->start(1000); // 1000ms == 1s
    }
});

connect(timer, &QTimer::timeout, this, [=]()
{
    QTime tm = QTime::currentTime();
    // 格式化当前得到的系统时间
    QString tmstr = tm.toString("hh:mm:ss.zzz");
    // 设置要显示的时间
    ui->curTime->setText(tmstr);
});
```

> ##### 一次性定时器

```c++
// 点击按钮 onceBtn 只发射一次信号
// 点击按钮一次, 发射一个信号, 得到某一个时间点的时间
connect(ui->onceBtn, &QPushButton::clicked, this, [=]()
{
     // 获取2s以后的系统时间, 不创建定时器对象, 直接使用类的静态方法
    QTimer::singleShot(2000, this, [=](){
        QTime tm = QTime::currentTime();
        // 格式化当前得到的系统时间
        QString tmstr = tm.toString("hh:mm:ss.zzz");
        // 设置要显示的时间
        ui->onceTime->setText(tmstr);
    });
});
```

## QWIDGET

![image-20230805083036843](E:\MD\QTT.assets\image-20230805083036843.png)

```c++
    ui->setupUi(this);
    connect(this,&MainWindow::windowIconChanged,this,[=](const QIcon &icon){
        qDebug()<<"窗口的图标被修改了";
    });
    connect(this,&QMainWindow::windowTitleChanged,this,[=](const QString &title){
         qDebug()<<"窗口的标题被修改了"<<title;
    });

    this->setContextMenuPolicy(Qt::CustomContextMenu);
    //设置菜单策略
    connect(this,&QMainWindow::customContextMenuRequested,this,[=](){
        QMenu a;
        a.addAction("茄子");
        a.addAction("西红花是");
        a.addAction("牛马");
        a.addAction("Odasd");
        a.exec(QCursor::pos());
        //显示在当前光标所在的一个全局坐标。
    });
```



> #### 设置父对象

```c++
// 构造函数
QWidget::QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

// 公共成员函数
// 给当前窗口设置父对象
void QWidget::setParent(QWidget *parent);
void QWidget::setParent(QWidget *parent, Qt::WindowFlags f);
//Qt::WindowFlags f 一般不用
// 获取当前窗口的父对象, 没有父对象返回 nullptr
/////////////////////////////////
QWidget *QWidget::parentWidget() const;

```

setparent,**parentwidget**

> #### 窗口位置

```c++
//------------- 窗口位置 -------------
// 得到相对于当前窗口父窗口的几何信息, 边框也被计算在内
QRect QWidget::frameGeometry() const;


// 得到相对于当前窗口父窗口的几何信息, 不包括边框
const QRect &geometry() const;

frameGeometry()返回的是包括窗口边框的完整几何信息，而geometry()返回的是不包括窗口边框的几何信息。
    都是相对于父窗口
// 设置当前窗口的几何信息(位置和尺寸信息), 不包括边框
void setGeometry(int x, int y, int w, int h);
void setGeometry(const QRect &);
    
// 移动窗口, 重新设置窗口的位置
void move(int x, int y);
void move(const QPoint &);

```

**当指定了父亲，show之后被内嵌在父亲里面**

**不指定父亲show，就会独立显示**

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QWidget>
#include <QDebug>
#include <QSize>
#include <QRect>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QWidget *widget=new QWidget;
    widget->show();
    widget->frameSize();
//    qDebug()<<widget->parentWidget();
    qDebug()<<widget->frameSize();
//    qDebug()<<this->frameSize();
    qDebug()<<widget->geometry();
    widget->setWindowTitle("你好啊");
    widget->setGeometry(0,46,100,100);
    qDebug()<<widget->geometry();

    QSize a(250,250);
    QRect b(100,100,100,100);
    widget->setGeometry(b);
//    widget->showFullScreen();
//    this->showFullScreen();
    this->showMaximized();
    this->setVisible(false);
    widget->setVisible(false);
   this->setWindowIcon(QIcon("C:/Users/许闰博/Desktop/新建文件夹/1.png"));
    qDebug()<<this->windowIcon();
}

MainWindow::~MainWindow()
{
    delete ui;
}


```



> #### 窗口尺寸

设置的尺寸不包含上面那个

```c++
//------------- 窗口尺寸 -------------
// 获取当前窗口的尺寸信息
QSize size() const
// 重新设置窗口的尺寸信息
void resize(int w, int h);
void resize(const QSize &);
// 获取当前窗口的最大尺寸信息
QSize maximumSize() const;
// 获取当前窗口的最小尺寸信息
QSize minimumSize() const;
// 设置当前窗口固定的尺寸信息
void QWidget::setFixedSize(const QSize &s);
void QWidget::setFixedSize(int w, int h);
// 设置当前窗口的最大尺寸信息
void setMaximumSize(const QSize &);
void setMaximumSize(int maxw, int maxh);
// 设置当前窗口的最小尺寸信息
void setMinimumSize(const QSize &);
void setMinimumSize(int minw, int minh);


// 获取当前窗口的高度    
int height() const;
// 获取当前窗口的最小高度
int minimumHeight() const;
// 获取当前窗口的最大高度
int maximumHeight() const;
// 给窗口设置固定的高度
void QWidget::setFixedHeight(int h);
// 给窗口设置最大高度
void setMaximumHeight(int maxh);
// 给窗口设置最小高度
void setMinimumHeight(int minh);

// 获取当前窗口的宽度
int width() const;
// 获取当前窗口的最小宽度
int minimumWidth() const;
// 获取当前窗口的最大宽度
int maximumWidth() const;
// 给窗口设置固定宽度
void QWidget::setFixedWidth(int w);
// 给窗口设置最大宽度
void setMaximumWidth(int maxw);
// 给窗口设置最小宽度
void setMinimumWidth(int minw);
```

> #### 窗口标题和图标icon



```c++
//------------- 窗口图标 -------------
// 得到当前窗口的图标
QIcon windowIcon() const;
// 构造图标对象, 参数为图片的路径
QIcon::QIcon(const QString &fileName);
// 设置当前窗口的图标
void setWindowIcon(const QIcon &icon);

//------------- 窗口标题 -------------
// 得到当前窗口的标题
QString windowTitle() const;
// 设置当前窗口的标题
void setWindowTitle(const QString &);


```

> #### 信号



```c++
现设置发射策略
 QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);
 窗口的右键菜单策略 contextMenuPolicy() 参数设置为 Qt::CustomContextMenu, 按下鼠标右键发射该信号
[signal] void QWidget::customContextMenuRequested(const QPoint &pos);

pos得到的是相对父窗口的坐标
    QCursor::pos()是相对于屏幕的


// 窗口图标发生变化, 发射此信号	
[signal] void QWidget::windowIconChanged(const QIcon &icon);
// 窗口标题发生变化, 发射此信号
[signal] void QWidget::windowTitleChanged(const QString &title);

```

> ####  槽函数

```c++
//------------- 窗口显示 -------------
// 关闭当前窗口
[slot] bool QWidget::close();

// 隐藏当前窗口
[slot] void QWidget::hide();

// 显示当前创建以及其子窗口
[slot] void QWidget::show();

// 全屏显示当前窗口, 只对windows有效
[slot] void QWidget::showFullScreen();

// 窗口最大化显示, 只对windows有效
[slot] void QWidget::showMaximized();
// 窗口最小化显示, 只对windows有效
[slot] void QWidget::showMinimized();
// 将窗口回复为最大化/最小化之前的状态, 只对windows有效
[slot] void QWidget::showNormal();

//------------- 窗口状态 -------------
// 判断窗口是否可用
bool QWidget::isEnabled() const; // 非槽函数
// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件
// 参数true->可用, false->不可用
[slot] void QWidget::setEnabled(bool);
// 设置窗口是否可用, 不可用窗口无法接收和处理窗口事件
// 参数true->不可用, false->可用
[slot] void QWidget::setDisabled(bool disable);

// 设置窗口是否可见, 参数为true->可见, false->不可见
对于父亲来说没用
[slot] virtual void QWidget::setVisible(bool visible);。
```

```c++
this->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(this,&QMainWindow::customContextMenuRequested,this,[=](){
        QMenu a;
        a.addAction("茄子");
        a.addAction("西红花是");
        a.addAction("牛马");
        a.addAction("Odasd");
        a.exec(QCursor::pos());
        //显示在当前光标所在的一个全局坐标。
    });详细的解释一下
```

> 首先，设置了触发策略(自定义的)
>
> `this->setContextMenuPolicy(Qt::CustomContextMenu)` **设置了窗口的上下文菜单策略为自定义菜单。这意味着当用户右键单击窗口时，不会显示默认的上下文菜单，而是使用自定义的菜单。**
>
> 接下来，连接信号,QMainWindow::customContextMenuRequested
>
> `connect(this, &QMainWindow::customContextMenuRequested, this, [=]() { ... })` 用于连接 `customContextMenuRequested` 信号和一个 lambda 表达式。当用户请求上下文菜单时，即右键单击窗口时，该 lambda 表达式将被执行。
>
> 在 lambda 表达式中，首先创建了一个 `QMenu` 对象 `a`。然后，使用 `a.addAction("...")` 添加了多个动作（菜单项）。每个 `addAction` 调用都会创建一个新的 `QAction` 对象，并将其添加到菜单中。
>
> **接下来，使用 `a.exec(QCursor::pos())` 显示菜单。`QCursor::pos()` 返回当前鼠标光标的全局坐标位置，这样菜单就会显示在光标所在的位置。**
>
> 总结起来，这段代码的作用是：当用户右键单击窗口时，显示一个自定义的上下文菜单，菜单中包含了多个动作（菜单项）。菜单显示在当前鼠标光标的位置。

## QDILAG

![image-20230805113458609](E:\MD\QTT.assets\image-20230805113458609.png)

```c++
// 构造函数
QDialog::QDialog(QWidget *parent = nullptr, Qt::WindowFlags f = Qt::WindowFlags());

// 模态显示窗口
[virtual slot] int QDialog::exec();

// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Accepted1
[virtual slot] void QDialog::accept();

// 隐藏模态窗口, 并且解除模态窗口的阻塞, 将 exec() 的返回值设置为 QDialog::Rejected0
[virtual slot] void QDialog::reject();

// 关闭对话框并将其结果代码设置为r。finished()信号将发出r;
// 如果r是QDialog::Accepted 或 QDialog::Rejected，则还将分别发出accept()或Rejected()信号。
[virtual slot] void QDialog::done(int r);

[signal] void QDialog::accepted();
[signal] void QDialog::rejected();
[signal] void QDialog::finished(int result);

```

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "mydialog.h"
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_pushButton_clicked()
{
    MyDialog dig;
    connect(&dig,&QDialog::accepted,this,[=](){
        qDebug()<<"accepted信号发射了";
    });
    connect(&dig,&QDialog::rejected,this,[=](){
        qDebug()<<"rejected信号发射了";
    });
    connect(&dig,&QDialog::finished,this,[=](int result){
        qDebug()<<"finished信号发射了，且返回了"<<result;
    });
    
    ///////////////////////////////////////////
    int ret=dig.exec();
    //会有一个返回值，如果你点击的是accept会返回1,reject是0 done是对应的参数
    //就是在设置被点击的时候对象.done(r)
    //点击accept或者reject会发射两个信号，一个是对应自己的信号，另一个是finshed信号
    //finshed信号会知道返回的是多少	
    if(ret==QDialog::Accepted)
    {
        qDebug()<<"accepted clicked.....返回值为1";
    }
    else if (ret==QDialog::Rejected) {
        qDebug()<<"Rejected clicked.....返回值为0";
    }
    else {
        qDebug()<<"Done clicked.....返回值为"<<ret;
    }
}

```

> void QDialog::finished(int *result*)
>
> 这个信号 `finished(int result)` 是 `QDialog` 类的一个信号。当对话框的结果代码被设置时，无论是由用户操作还是通过调用 `done()`、`accept()` 或 `reject()` 方法设置，都会发出这个信号。
>
> 需要注意的是，当使用 `hide()` 或 `setVisible(false)` 隐藏对话框时，不会发出这个信号。这也包括在对话框可见时删除对话框。
>
> 换句话说，只有在对话框的结果代码被设置时，才会发出 `finished(int result)` 信号。
>
> 这个信号可以用于在对话框关闭后执行一些特定的操作，比如处理对话框的结果、清理资源等。
>
> **在 `connect` 函数中，通过指定 `&QDialog::finished` 作为信号参数，告诉 Qt 连接的信号是 `QDialog` 的 `finished` 信号。**
>
> 当 `finished` 信号被触发时，**Qt 会自动将信号的参数传递给槽函数。在这种情况下，`finished` 信号的参数是 `int result`，表示对话框的结果代码。**
>
> 在 lambda 表达式中，**通过声明 `[=](int result)` 来接收这个参数。`[=]` 表示以值捕获的方式捕获所有外部变量，包括 `result` 参数。因此，当 `finished` 信号被触发时，`result` 参数会被传递给 lambda 表达式，你就可以在 lambda 表达式中使用它了**。

### QDILAG-》qmessagebox

**参数依次是父对象、标题、主要文本和按钮参数。**

![image-20230807133721830](E:\MD\QTT.assets\image-20230807133721830.png)

```c++
// 显示一个模态对话框, 将参数 text 的信息展示到窗口中
[static] void QMessageBox::about(QWidget *parent, const QString &title, const QString &text);

/*
参数:
- parent: 对话框窗口的父窗口
- title: 对话框窗口的标题
- text: 对话框窗口中显示的提示信息
- buttons: 对话框窗口中显示的按钮(一个或多个)
- defaultButton
    1. defaultButton指定按下Enter键时使用的按钮。
    2. defaultButton必须引用在参数 buttons 中给定的按钮。
    3. 如果defaultButton是QMessageBox::NoButton, QMessageBox会自动选择一个合适的默认值。
*/
// 显示一个信息模态对话框
[static] QMessageBox::StandardButton QMessageBox::information(
           QWidget *parent, const QString &title, 
           const QString &text, 
           QMessageBox::StandardButtons buttons = Ok,
           QMessageBox::StandardButton defaultButton = NoButton);

// 显示一个错误模态对话框
[static] QMessageBox::StandardButton QMessageBox::critical(
           QWidget *parent, const QString &title, 
           const QString &text, 
           QMessageBox::StandardButtons buttons = Ok,
           QMessageBox::StandardButton defaultButton = NoButton);

// 显示一个问题模态对话框
[static] QMessageBox::StandardButton QMessageBox::question(
           QWidget *parent, const QString &title, 
           const QString &text, 
           QMessageBox::StandardButtons buttons = StandardButtons(Yes | No), 
           QMessageBox::StandardButton defaultButton = NoButton);

// 显示一个警告模态对话框
[static] QMessageBox::StandardButton QMessageBox::warning(
           QWidget *parent, const QString &title, 
           const QString &text, 
           QMessageBox::StandardButtons buttons = Ok,
           QMessageBox::StandardButton defaultButton = NoButton);
```



![image-20230807143709141](E:\MD\QTT.assets\image-20230807143709141.png)

不同按钮对应的枚举值，然后ifelse提示不同的信息。

![image-20230807143743669](E:\MD\QTT.assets\image-20230807143743669.png)

举例QDIALOG

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QDialog>
#include <QMessageBox>
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_msg_about_btn_clicked()
{
            QMessageBox::about(this,"你好","我真的超级喜欢你啊草");

}

void MainWindow::on_msg_about_QTbtn_clicked()
{
            QMessageBox::aboutQt(this,"helloworld");

}

void MainWindow::on_msg_critical_btn_clicked()
{
           QMessageBox::critical(this,"hello","这是违法行为！！！");
}

void MainWindow::on_msg_information_btn_clicked()
{
            QMessageBox::information(this,"information","你要噶那么");
}

void MainWindow::on_msg_warning_btn_clicked()
{
    QMessageBox::warning(this,"warning","吃屎是不对的!");
}
void MainWindow::on_msg_question_btn_clicked()
{
//    int ret=QMessageBox::question(this,"牛牛牛","你确定要吃屎吗？");
//    yes no
    int ret1=QMessageBox::question(this,"question","你确定要吃屎吗？",QMessageBox::Ok|QMessageBox::No);

    if(ret1==QMessageBox::Ok)
    {
        qDebug()<<"你可太牛了";

    }
    else {
        qDebug()<<"你shi都不敢吃，太胆小了";
    }
}

```

![image-20230807170048759](E:\MD\QTT.assets\image-20230807170048759.png)

---

### QFILEDIALOG



```c++
/*
通用参数:
  - parent: 当前对话框窗口的父对象也就是父窗口
  - caption: 当前对话框窗口的标题
  - dir: 当前对话框窗口打开的默认目录 e:\\dsad\\das
  - options: 当前对话框窗口的一些可选项,枚举类型, 一般不需要进行设置, 使用默认值即可
  - filter: 过滤器, 在对话框中只显示满足条件的文件, 可以指定多个过滤器, 使用 ;; 分隔
    - 样式举例: 
	- Images (*.png *.jpg)
	- Images (*.png *.jpg);;Text files (*.txt)
  - selectedFilter: 如果指定了多个过滤器, 通过该参数指定默认使用哪一个, 不指定默认使用第一个过滤器
*/
// 打开一个目录, 得到这个目录的绝对路径
[static] QString QFileDialog::getExistingDirectory(
                  QWidget *parent = nullptr, 
                  const QString &caption = QString(), 
                  const QString &dir = QString(), 
                  QFileDialog::Options options = ShowDirsOnly);

// 打开一个文件, 得到这个文件的绝对路径
[static] QString QFileDialog::getOpenFileName(
    	          QWidget *parent = nullptr, 
    		  const QString &caption = QString(), 
                  const QString &dir = QString(), 
                  const QString &filter = QString(), 
                  QString *selectedFilter = nullptr, 
                  QFileDialog::Options options = Options());

// 打开多个文件, 得到这多个文件的绝对路径
[static] QStringList QFileDialog::getOpenFileNames(
    	          QWidget *parent = nullptr, 
                  const QString &caption = QString(), 
                  const QString &dir = QString(), 
                  const QString &filter = QString(), 
                  QString *selectedFilter = nullptr, 
                  QFileDialog::Options options = Options());

// 打开一个目录, 使用这个目录来保存指定的文件
[static] QString QFileDialog::getSaveFileName(
    		  QWidget *parent = nullptr, 
                  const QString &caption = QString(), 
                  const QString &dir = QString(), 
                  const QString &filter = QString(), 
                  QString *selectedFilter = nullptr, 
                  QFileDialog::Options options = Options());
不能帮我们弄创建一个新的文件，需要用open，打开然后w
```

自己的项目QFILEDIALOG

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QFileDialog>
#include <QMessageBox>
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);



}

MainWindow::~MainWindow()
{
    delete ui;
}


//tr()的介绍
//    如果你的应用程序需要支持多种语言，并且你希望在不同的语言环境下显示不同的翻译，
//    那么你需要在应用程序中配置相应的翻译文件，并使用 tr() 函数对需要翻译的文本进行标记。
//    这样，Qt会根据当前的语言环境自动加载相应的翻译文件，并将文本翻译为适当的语言。

//    单个过滤器tr(选择名(*.h *.c))       tr("yuan(*.c *.h)")
//    多个过滤器   tr("yuan(*.c *.h);;ok(*.txt)"

//    默认会选择第一种过滤器，如果要想默认选择某个过滤器的话，就要传入对应的字符串指针
//    QString *se1ectedFilter = nullptr,
void MainWindow::on_pushButton_clicked()
{

    QString filename= QFileDialog::getExistingDirectory(this,"选撒大苏打","E:/QTPROJECT");
    QMessageBox::warning(this,"提示","你选择的路径是\n"+filename);
    //找的是目录

}

void MainWindow::on_pushButton_2_clicked()
{
     QString a("ok(*.txt)");
     QString filename= QFileDialog::getOpenFileName(this,"选择文件","E:/QTPROJECT","yuan(*.txt);;ok(*.c *.h)",&a);
     QMessageBox::warning(this,"提示","你选择的路径是\n"+filename);
     //找的是文件
}


void MainWindow::on_pushButton_3_clicked()
{
    QString a("ok(*.txt)");
    QStringList filename=QFileDialog::getOpenFileNames(this,"路径","E:/QTPROJECT","源件(*.c *.h)");
    for (int i=0;i<filename.length();i++) {
        QMessageBox::warning(this,"提示","你选择的路径是\n"+filename[i]+"\n");

    }
    //找的是多个文件
    qDebug()<<filename.length();
}

```

### QFONTDIALOG!!!

先引入Qfont

> **在 `QFont` 构造函数中，中间两个参数 `pointSize` 和 `weight` 的范围如下：**
>
> - **`pointSize`：表示字体的大小，是一个整数参数。它的范围是正整数，表示字体的点大小。例如，`pointSize` 为 18 表示字体大小为 18 点。**
> - **`weight`：表示字体的粗细程度，是一个整数参数。它的范围是 `QFont::Thin`（0）到 `QFont::Black`（99）之间的整数值。其中，`QFont::Thin` 表示最细的字体，`QFont::Black` 表示最粗的字体。Qt 提供了一些预定义的 `QFont::Weight` 值，如 `QFont::Light`、`QFont::Normal`、`QFont::Bold` 等，它们对应着不同的粗细程度。**

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QFont>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QFont f("你好啊",38,QFont::Black,false);
        
    ui->label->setFont(f);
    ui->label->setText("你好");
}

MainWindow::~MainWindow()
{
    delete ui;
}




```

```c++
// 构造函数
  QFont::QFont();
  /*
  参数:
    - family: 本地字库中的字体名, 通过 office 等文件软件可以查看
    - pointSize: 字体的字号
    - weight: 字体的粗细, 有效范围为 0 ~ 99
    - italic: 字体是否倾斜显示, 默认不倾斜
  */
  QFont::QFont(const QString &family, int pointSize = -1, int weight = -1, bool italic = false);
  
  // 设置字体
  void QFont::setFamily(const QString &family);

  // 根据字号设置字体大小
  void QFont::setPointSize(int pointSize);
  // 根据像素设置字体大小
  void QFont::setPixelSize(int pixelSize);
  // 设置字体的粗细程度, 有效范围: 0 ~ 99
  void QFont::setWeight(int weight);
  // 设置字体是否加粗显示
  void QFont::setBold(bool enable);
  // 设置字体是否要倾斜显示
  void QFont::setItalic(bool enable);
  
  // 获取字体相关属性(一般规律: 去掉设置函数的 set 就是获取相关属性对应的函数名)
  QString QFont::family() const;
  bool QFont::italic() const;
  int QFont::pixelSize() const;
  int QFont::pointSize() const;
  bool QFont::bold() const;
  int QFont::weight() const;
```

![image-20230807172557719](E:\MD\QTT.assets\image-20230807172557719.png)

```c++
/*
参数:
  - ok: 传出参数, 用于判断是否获得了有效字体信息, 指定一个布尔类型变量地址
  ,如果我们点击了选择了字体就是true，点击了cancle就是false
  - initial: 字体对话框中默认选中并显示该字体信息, 用于对话框的初始化
  - parent: 字体对话框窗口的父对象
  - title: 字体对话框的窗口标题
  - options: 字体对话框选项, 使用默认属性即可, 一般不设置
*/
  [static] QFont QFontDialog::getFont(
		bool *ok, const QFont &initial, 
		QWidget *parent = nullptr, const QString &title = QString(), 
		QFontDialog::FontDialogOptions options = FontDialogOptions());
  
  [static] QFont QFontDialog::getFont(bool *ok, QWidget *parent = nullptr);
```

![image-20230807172626468](E:\MD\QTT.assets\image-20230807172626468.png)

```c++
void MainWindow::on_pushButton_clicked()
{
    bool ok;
    QFont f=QFontDialog::getFont(&ok,QFont("微软雅黑",30,70),this,"设置字体");
//    QFont f=QFontDialog::getFont(NULL);
    ui->label->setFont(f);
}
不指定的话也能实现设置字体。
```

![image-20230807173444450](E:\MD\QTT.assets\image-20230807173444450.png)

```c++
void MainWindow::on_pushButton_clicked()
{
    bool ok;
    QFont f=QFontDialog::getFont(&ok,QFont("微软雅黑",30,70),this,"设置字体");
//    QFont f=QFontDialog::getFont(NULL);
    QApplication::setFont(f);
    //设置给当前应用程序的所有窗口的字体都一样
    ui->label->setFont(f);
}
```

### QCOLORDIALOG

QCOLOR

![image-20230807174210005](E:\MD\QTT.assets\image-20230807174210005.png)



```C++
// 构造函数
QColor::QColor(Qt::GlobalColor color);
QColor::QColor(int r, int g, int b, int a = ...);
QColor::QColor();

// 参数设置 red, green, blue, alpha, 取值范围都是 0-255
void QColor::setRed(int red);		// 红色
void QColor::setGreen(int green);	// 绿色
void QColor::setBlue(int blue);	// 蓝色
void QColor::setAlpha(int alpha);	// 透明度, 默认不透明(255)
void QColor::setRgb(int r, int g, int b, int a = 255);

int QColor::red() const;
int QColor::green() const;
int QColor::blue() const;
int QColor::alpha() const;
//都是传出参数，把参数作为返回值.
void QColor::getRgb(int *r, int *g, int *b, int *a = nullptr) const;


使用方法，就相当于之前函数有一个指针类型的参数我们要传入一个地址进去，的逆过程！！！能够的包原来的变量，
    原来是int....->int*
    现在是int*->int
    ui->setupUi(this);
    QColor color(234,22,13,150);

    int r;
    int g;
    int b;
    int a;
    color.getRgb(&r,&g,&b,&a);

    qDebug()<<r<<g<<b<<a;

//    234 22 13 150



```

qcolordialog

```c++
  // 弹出颜色选择对话框, 并返回选中的颜色信息
/*
参数:
    - initial: 对话框中默认选中的颜色, 用于窗口初始化
    - parent: 给对话框窗口指定父对象
    - title: 对话框窗口的标题
    - options: 颜色对话框窗口选项, 使用默认属性即可, 一般不需要设置
*/
  [static] QColor QColorDialog::getColor(
		const QColor &initial = Qt::white, 
		QWidget *parent = nullptr, const QString &title = QString(), 
		QColorDialog::ColorDialogOptions options = ColorDialogOptions());
```

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QColor>
#include <QColorDialog>
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    QColor color(234,22,13,150);

    int r;
    int g;
    int b;
    int a;
    color.getRgb(&r,&g,&b,&a);

    qDebug()<<r<<g<<b<<a;

//    234 22 13 150



}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_pushButton_clicked()
{
     QColor c= QColorDialog::getColor();
}

```

> ### static QColor qcolor(53,200,255,254);

这样就是全局变量！！！

```c++
QString color_str=QString("color:%1").arg(color.name());
ui->groupBox->setStyleSheet(c);
color.name方法得到颜色对应的16进制数据，然后设置css属性.
```

### qinputdialog

```c++
// 得到一个可以输入浮点数的对话框窗口, 返回对话框窗口中输入的浮点数
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - value: 对话框窗口中显示的浮点值, 默认为 0
  - min: 对话框窗口支持显示的最小数值
  - max: 对话框窗口支持显示的最大数值
  - decimals: 浮点数的精度, 默认保留小数点以后1位
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
*/
[static] double QInputDialog::getDouble(
    		QWidget *parent, const QString &title, 
    		const QString &label, double value = 0, 
    		double min = -2147483647, double max = 2147483647, 
    		int decimals = 1, bool *ok = nullptr, 
    		Qt::WindowFlags flags = Qt::WindowFlags());

// 得到一个可以输入整形数的对话框窗口, 返回对话框窗口中输入的整形数
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - value: 对话框窗口中显示的整形值, 默认为 0
  - min: 对话框窗口支持显示的最小数值
  - max: 对话框窗口支持显示的最大数值
  - step: 步长, 通过对话框提供的按钮调节数值每次增长/递减的量
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
*/
[static] int QInputDialog::getInt(
    		QWidget *parent, const QString &title, 
    		const QString &label, int value = 0, 
    		int min = -2147483647, int max = 2147483647, 
    		int step = 1, bool *ok = nullptr, 
    		Qt::WindowFlags flags = Qt::WindowFlags());

// 得到一个带下来菜单的对话框窗口, 返回选择的菜单项上边的文本信息
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - items: 字符串列表, 用于初始化窗口中的下拉菜单, 每个字符串对应一个菜单项
  - current: 通过菜单项的索引指定显示下拉菜单中的哪个菜单项, 默认显示第一个(编号为0)
  - editable: 设置菜单项上的文本信息是否可以进行编辑, 默认为true, 即可以编辑
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串
    - 如果有特殊需求, 可以参数帮助文档进行相关设置
*/
[static] QString QInputDialog::getItem(
    		QWidget *parent, const QString &title, 
    		const QString &label, const QStringList &items, 
    		int current = 0, bool editable = true, bool *ok = nullptr, 
    		Qt::WindowFlags flags = Qt::WindowFlags(), 
    		Qt::InputMethodHints inputMethodHints = Qt::ImhNone);

// 得到一个可以输入多行数据的对话框窗口, 返回用户在窗口中输入的文本信息
/*
参数:
  - parent: 对话框窗口的父窗口
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - text: 指定显示到多行输入框中的文本信息, 默认是空字符串
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串
    - 如果有特殊需求, 可以参数帮助文档进行相关设置
*/
[static] QString QInputDialog::getMultiLineText(
    		QWidget *parent, const QString &title, const QString &label, 
    		const QString &text = QString(), bool *ok = nullptr, 
    		Qt::WindowFlags flags = Qt::WindowFlags(), 
    		Qt::InputMethodHints inputMethodHints = Qt::ImhNone);

// 得到一个可以输入单行信息的对话框窗口, 返回用户在窗口中输入的文本信息
/*
参数:
  - parent: 对话框窗口的父窗口 
  - title: 对话框窗口显示的标题信息
  - label: 对话框窗口中显示的文本信息(用于描述对话框的功能)
  - mode: 指定单行编辑框中数据的反馈模式, 是一个 QLineEdit::EchoMode 类型的枚举值
    - QLineEdit::Normal: 显示输入的字符。这是默认值
    - QLineEdit::NoEcho: 不要展示任何东西。这可能适用于连密码长度都应该保密的密码。
    - QLineEdit::Password: 显示与平台相关的密码掩码字符，而不是实际输入的字符。
    - QLineEdit::PasswordEchoOnEdit: 在编辑时按输入显示字符，否则按密码显示字符。
  - text: 指定显示到单行输入框中的文本信息, 默认是空字符串
  - ok: 传出参数, 用于判断是否得到了有效数据, 一般不会使用该参数
  - flags: 对话框窗口的窗口属性, 使用默认值即可
  - inputMethodHints: 设置显示模式, 默认没有指定任何特殊显示格式, 显示普通文本字符串
     - 如果有特殊需求, 可以参数帮助文档进行相关设置
*/
[static] QString QInputDialog::getText(
    		QWidget *parent, const QString &title, const QString &label,
    		QLineEdit::EchoMode mode = QLineEdit::Normal, 
    		const QString &text = QString(), bool *ok = nullptr, 
    		Qt::WindowFlags flags = Qt::WindowFlags(), 
    		Qt::InputMethodHints inputMethodHints = Qt::ImhNone);

```

qinputdialog

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <QInputDialog>
#include <QDebug>
#include <QString>
#include <string>
using namespace std;
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_pushButton_clicked()
{
    bool ok;
    int a=QInputDialog::getInt(this,"输入","输入你的年龄",18,0,20,1,&ok);
    //不能跳跃参数
    qDebug()<<a;
}

void MainWindow::on_pushButton_2_clicked()
{
    bool ok;
    double a=QInputDialog::getDouble(this,"inputdouble","请输入你的长度",7,3,9,2,&ok);
    qDebug()<<a;
}

void MainWindow::on_pushButton_5_clicked()
{
    QStringList strlist={"小红","小绿","小紫"};
    QString text=QInputDialog::getItem(this,"输入item","选择输入喜欢的人",strlist,1,false);
    qDebug()<<text;
}

void MainWindow::on_pushButton_3_clicked()
{
    bool ok;
    QString text= QInputDialog::getText(this,"gettext","输入你喜欢的书",QLineEdit::NoEcho,"活着",&ok);
    qDebug()<<text;
}

void MainWindow::on_pushButton_4_clicked()
{
    bool ok;
    QString text= QInputDialog::getMultiLineText(this,"getmultiline","输入多行","大笨猪666",&ok);
     qDebug()<<text;
}

```

### qprogressdialog

```c++
// 构造函数
/*
参数:
  - labelText: 对话框中显示的提示信息
  - cancelButtonText: 取消按钮上显示的文本信息
  - minimum: 进度条最小值
  - maximum: 进度条最大值
  - parent: 当前窗口的父对象
  - f: 当前进度窗口的flag属性, 使用默认属性即可, 无需设置
*/
QProgressDialog::QProgressDialog(
	QWidget *parent = nullptr, 
	Qt::WindowFlags f = Qt::WindowFlags());

QProgressDialog::QProgressDialog(
	const QString &labelText, const QString &cancelButtonText, 
	int minimum, int maximum, QWidget *parent = nullptr,
	Qt::WindowFlags f = Qt::WindowFlags());


// 设置取消按钮显示的文本信息
[slot] void QProgressDialog::setCancelButtonText(const QString &cancelButtonText);

// 公共成员函数和槽函数
QString QProgressDialog::labelText() const;
void QProgressDialog::setLabelText(const QString &text);

// 得到进度条最小值
int QProgressDialog::minimum() const;
// 设置进度条最小值
void QProgressDialog::setMinimum(int minimum);

// 得到进度条最大值
int QProgressDialog::maximum() const;
// 设置进度条最大值
void QProgressDialog::setMaximum(int maximum);

// 设置进度条范围(最大和最小值)
[slot] void QProgressDialog::setRange(int minimum, int maximum);

// 得到进度条当前的值
int QProgressDialog::value() const;
// 设置进度条当前的值
void QProgressDialog::setValue(int progress);


bool QProgressDialog::autoReset() const;
// 当value() = maximum()时，进程对话框是否调用reset()，此属性默认为true。
void QProgressDialog::setAutoReset(bool reset);


bool QProgressDialog::autoClose() const;
// 当value() = maximum()时，进程对话框是否调用reset()并且隐藏，此属性默认为true。
void QProgressDialog::setAutoClose(bool close);

// 判断用户是否按下了取消键, 按下了返回true, 否则返回false
bool wasCanceled() const;


// 重置进度条
// 重置进度对话框。wascancelled()变为true，直到进程对话框被重置。进度对话框被隐藏。
[slot] void QProgressDialog::cancel();
// 重置进度对话框。如果autoClose()为真，进程对话框将隐藏。
[slot] void QProgressDialog::reset();   

// 信号
// 当单击cancel按钮时，将发出此信号。默认情况下，它连接到cancel()槽。
[signal] void QProgressDialog::canceled();
/////////////////////////////////////////////////////////////////////////////////////
这是他的积累的组件函数，基类！！！！！
// 设置窗口的显示状态(模态, 非模态)
    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
    需要写在show之前！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
/*
参数:
	Qt::NonModal  -> 非模态
	Qt::WindowModal	-> 模态, 阻塞父窗口
	Qt::ApplicationModal -> 模态, 阻塞应用程序中的所有窗口
*/
void QWidget::setWindowModality(Qt::WindowModality windowModality);


```

```C++
void MainWindow::on_pushButton_clicked()
{
    QProgressDialog *progress=new QProgressDialog(this);
//    指定了父亲，当大窗口关闭的时候，progress就被释放 了！！！
    progress->setWindowTitle("更新中");
    progress->show();

    QTimer *tmer=new QTimer(this);
    //    指定了父亲，当大窗口关闭的时候，tmer就被释放 了！！！
    tmer->start();
    tmer->setInterval(10);
    static int value=0;
    progress->setValue(value);

    connect(tmer,&QTimer::timeout,this,[=](){

        progress->setValue(value);
        value++;
        if(value>progress->maximum())
        {
            value=0;
            tmer->stop();
        }
    });
    if(progress->wasCanceled())
    {
        value=0;
        tmer->stop();
    }

//    connect(progress,&QProgressDialog::canceled,this,[=](){
//        value=0;
//        tmer->stop();
//    });
}
```

自己手动释放的话

一般都配合着定时器使用

```c++
void MainWindow::on_pushButton_clicked()
{
    QProgressDialog *progress=new QProgressDialog();
//    指定了父亲，当大窗口关闭的时候，progress就被释放 了！！！
    progress->setWindowTitle("更新中");
    progress->show();

    QTimer *tmer=new QTimer();
    //    指定了父亲，当大窗口关闭的时候，tmer就被释放 了！！！
    tmer->start();
    tmer->setInterval(10);
    static int value=0;
    progress->setValue(value);

    connect(tmer,&QTimer::timeout,this,[=](){

        progress->setValue(value);
        value++;
        if(value>progress->maximum())
        {
            value=0;
            tmer->stop();
            delete  progress;
            delete tmer;
        }
    });
    if(progress->wasCanceled())
    {
        value=0;
        tmer->stop();
        delete  progress;
        delete tmer;
    }

//    connect(progress,&QProgressDialog::canceled,this,[=](){
//        value=0;
//        tmer->stop();
//    });
}
```

## Qmainwindow

![image-20230808160356220](E:\MD\QTT.assets\image-20230808160356220.png)

![image-20230808160406271](E:\MD\QTT.assets\image-20230808160406271.png)

### 菜单栏

![image-20230808161932543](E:\MD\QTT.assets\image-20230808161932543.png)

![image-20230808161945774](E:\MD\QTT.assets\image-20230808161945774.png)

```c++
// 给菜单栏添加菜单
QAction *QMenuBar::addMenu(QMenu *menu);
QMenu *QMenuBar::addMenu(const QString &title);
QMenu *QMenuBar::addMenu(const QIcon &icon, const QString &title);

// 给菜单对象添加菜单项(QAction)
QAction *QMenu::addAction(const QString &text);
QAction *QMenu::addAction(const QIcon &icon, const QString &text);

// 添加分割线
QAction *QMenu::addSeparator();
```

> // 点击QAction对象发出该信号
>
> ```c++
> [signal] void QAction::triggered(bool checked = false);
> ```
>
> 
>
> ---
>
> ```c++
> // save_action 是某个菜单项对象名, 点击这个菜单项会弹出一个对话框
> connect(ui->save_action, &QAction::triggered, this, [=]()
> {
>       QMessageBox::information(this, "Triggered", "我是菜单项, 你不要调戏我...");
> });
> ```
>
> 
>

对应的方法就是set神马神马！

![image-20230808163239944](E:\MD\QTT.assets\image-20230808163239944.png)

![image-20230808163310859](E:\MD\QTT.assets\image-20230808163310859.png)

![image-20230808163320921](E:\MD\QTT.assets\image-20230808163320921.png)

![image-20230808163338503](E:\MD\QTT.assets\image-20230808163338503.png)

### 状态栏

![image-20230808163405209](E:\MD\QTT.assets\image-20230808163405209.png)

![image-20230808163440189](E:\MD\QTT.assets\image-20230808163440189.png)

## **有的控件我们不给他设置父对象的时候，他为谁服务谁就是他的父亲！**

![image-20230808172503102](E:\MD\QTT.assets\image-20230808172503102.png)

状态栏

```c++
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    ui->toolBar->setFixedSize(800,50);
    ui->toolBar->addWidget(new QPushButton("点击",this));
    ui->toolBar->addWidget(new QLineEdit(this));
    this->addToolBar("打住");
    ui->statusbar->showMessage("我是状态栏的message",10000);
    //第二个参数指定多少毫秒后消失
    //虽然但是这样就把覆盖了，那些还不现实
    QPushButton *btn= new QPushButton("按钮");
    QLabel *lb =new QLabel("不教胡马度阴山！");
    ui->statusbar->addWidget(btn);
    ui->statusbar->addWidget(lb);

    QTimer::singleShot(10000,this,[=](){
        btn->show();
        lb->show();

    });
}

MainWindow::~MainWindow()
{
    delete ui;
}


void MainWindow::on_pushButton_clicked()
{
   ui->statusbar->clearMessage();
}

```

## 停靠面板

![image-20230808180716646](E:\MD\QTT.assets\image-20230808180716646.png)

![image-20230808180848021](E:\MD\QTT.assets\image-20230808180848021.png)

## 资源文件

![image-20230808182015037](E:\MD\QTT.assets\image-20230808182015037.png)

资源放在和pro文件相同路静或者更深了

![image-20230808181951630](E:\MD\QTT.assets\image-20230808181951630.png)

![image-20230808182000941](E:\MD\QTT.assets\image-20230808182000941.png)

![image-20230808182047360](E:\MD\QTT.assets\image-20230808182047360.png)

## layout布局

![image-20230809102850405](E:\MD\QTT.assets\image-20230809102850405.png)

> 有问有答:
>     1. 控件的位置可以通过坐标指定, 为什么还要使用布局?
>     	- 坐标指定的位置是固定的, 当窗口大小发生改变, 子窗口位置不会变化
>         	- 使用坐标指定子窗口位置, 这个控件可能会被其他控件覆盖导致无法显示出来
>         	- 使用布局的方式可以完美解决以上的问题
>             	**- 一般在制作窗口的过程中都是给子控件进行布局, 而不是指定固定坐标位置**
>     2. 布局有局限性吗, 窗口结构复杂如何解决呢?
>         - 没有局限性, 并且布局的使用是非常灵活的
>     	- 各种布局是可以无限嵌套使用的, 这样就可以制作成非常复杂的窗口了
>         	- 思路是这样的: **给窗口设置**布局, 在布局中添加窗口, 子窗口中再设置布局,** 
>         	  在子窗口布局中再次添加窗口, ......(无限循环)**

![image-20230809103824470](E:\MD\QTT.assets\image-20230809103824470.png)

![image-20230809103831288](E:\MD\QTT.assets\image-20230809103831288.png)

![image-20230809103837334](E:\MD\QTT.assets\image-20230809103837334.png)	

![image-20230809103851464](E:\MD\QTT.assets\image-20230809103851464.png)

![image-20230809103859157](E:\MD\QTT.assets\image-20230809103859157.png)

![image-20230809103906937](E:\MD\QTT.assets\image-20230809103906937.png)



![image-20230816131302850](E:\MD\QTT.assets\image-20230816131302850.png)

### 通过aPI布局

![image-20230816131335828](E:\MD\QTT.assets\image-20230816131335828.png)

![image-20230816131357522](E:\MD\QTT.assets\image-20230816131357522.png)

![image-20230816131407076](E:\MD\QTT.assets\image-20230816131407076.png)

### Qlayout

![image-20230816131446315](E:\MD\QTT.assets\image-20230816131446315.png)

### Qhboxlayout

![image-20230816131604164](E:\MD\QTT.assets\image-20230816131604164.png)

![image-20230816131615468](E:\MD\QTT.assets\image-20230816131615468.png)

> 先创建布局对象
>
> 然后addwidget往布局里面放东西
>
> 然后再把布局setlayout给父亲窗口
>
> 这样父亲窗口就有这个布局了且是内嵌，
>
> #### 直接初始化的时候指定父亲和布局后再指定父亲的内嵌效果是有区别的

### QVboxlayout

![image-20230816133128199](E:\MD\QTT.assets\image-20230816133128199.png)

![image-20230816133211794](E:\MD\QTT.assets\image-20230816133211794.png)



### qgridboxlayout

```c++
// 构造函数
QGridLayout::QGridLayout();
QGridLayout::QGridLayout(QWidget *parent);

// 添加窗口对象到网格布局中
/*
参数:
  - widget: 添加到布局中的窗口对象
  - row: 添加到布局中的窗口对象位于第几行 (从0开始)
  - column: 添加到布局中的窗口对象位于第几列 (从0开始)
  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可
*/
void QGridLayout::addWidget(
	QWidget *widget, int row, int column, 
Qt::Alignment alignment = Qt::Alignment());

/*
参数:
  - widget: 添加到布局中的窗口对象
  - fromRow: 添加到布局中的窗口对象位于第几行 (从0开始)
  - fromColumn: 添加到布局中的窗口对象位于第几列 (从0开始)
  - rowSpan: 添加的窗口从 fromRow 行开始跨越的行数
  - columnSpan: 添加的窗口从 fromColumn 列开始跨越的列数
  - alignment: 窗口在布局中的对齐方式, 没有特殊需求使用默认值即可
*/
void QGridLayout::addWidget(
QWidget *widget, int fromRow, int fromColumn, 
int rowSpan, int columnSpan, 
Qt::Alignment alignment = Qt::Alignment());

// 设置 column 对应的列的最新宽度, 单位: 像素
void QGridLayout::setColumnMinimumWidth(int column, int minSize);

// 设置布局中水平方向窗口之间间隔的宽度
void QGridLayout::setHorizontalSpacing(int spacing);

// 设置布局中垂直方向窗口之间间隔的宽度
void QGridLayout::setVerticalSpacing(int spacing);
```



```c++

//    qDebug()<<area->takeWidget();
//    area->setWidgetResizable(true);
//    area->setAlignment(Qt::AlignHCenter);
//    ui->scrollArea_2->setAlignment(Qt::AlignHCenter);

    // 创建父窗口对象
    QWidget* window = new QWidget;
    // 创建子窗口对象
    QPushButton *button1 = new QPushButton("One");
    QPushButton *button2 = new QPushButton("Two");
    QPushButton *button3 = new QPushButton("Three");
    QPushButton *button4 = new QPushButton("Four");
    QPushButton *button5 = new QPushButton("Five");
    QPushButton *button6 = new QPushButton("Six");
    // 多行文本编辑框
    QTextEdit* txedit = new QTextEdit;
    txedit->setText("我占用了两行两列的空间哦。");

    QGridLayout* layout = new QGridLayout;
    // 按钮起始位置: 第1行, 第1列, 该按钮占用空间情况为1行1列
    layout->addWidget(button1, 0, 0);
    // 按钮起始位置: 第1行, 第2列, 该按钮占用空间情况为1行1列
    layout->addWidget(button2, 0, 1);
    // 按钮起始位置: 第1行, 第3列, 该按钮占用空间情况为1行1列
    layout->addWidget(button3, 0, 2);
    // 编辑框起始位置: 第2行, 第1列, 该按钮占用空间情况为2行2列
    layout->addWidget(txedit, 1, 0, 2, 2);
    // 按钮起始位置: 第2行, 第3列, 该按钮占用空间情况为1行1列
    layout->addWidget(button4, 1, 2);
    // 按钮起始位置: 第3行, 第3列, 该按钮占用空间情况为1行1列
    layout->addWidget(button5, 2, 2);
    // 按钮起始位置: 第4行, 第1列, 该按钮占用空间情况为1行3列
    layout->addWidget(button6, 3, 0, 1, 3);

    // 网格布局设置给父窗口对象
    window->setLayout(layout);
    // 显示父窗口
    window->show();
```

![image-20230816133845787](E:\MD\QTT.assets\image-20230816133845787.png)

## ----------------------------------

## qt窗口实现右键菜单8.14

学习目标：会熟练使用自定义信号来实现右键的时候弹出自己设置的menu菜单.,区别这四种方法

实现方法:

> 1. #### 通过鼠标事件实现
>
>    > 1. `QWidget`是Qt框架中的一个基类，用于创建用户界面的窗口部件。它提供了许多事件处理函数，其中包括`mousePressEvent`和`mouseReleaseEvent`。
>    >
>    >    这两个函数都是`virtual`和`protected`的，意味着它们**可以被子类重写**，并且**只能在类内部或其子类中访问**。
>    >
>    >    `mousePressEvent`函数在鼠标按下事件发生时被调用。它接收一个`QMouseEvent`类型的指针参数`event`，该参数包含有关鼠标事件的信息，如鼠标位置、按下的按钮等。你可以在重写的`mousePressEvent`函数中编写自定义的处理代码，以响应鼠标按下事件。
>    >
>    >    **qDebug()<<event->position();**
>    >
>    >    `mouseReleaseEvent`函数在**鼠标释放事件发生时被调用**。它也接收一个`QMouseEvent`类型的指针参数`event`，该参数包含有关鼠标事件的信息。你可以在重写的`mouseReleaseEvent`函数中编写自定义的处理代码，以响应鼠标释放事件。
>    >
>    >    通过重写这两个函数，你可以在`QWidget`的子类中实现自定义的鼠标交互行为。例如，你可以捕获鼠标按下和释放事件，并根据需要执行一些操作，如移动窗口、绘制图形等。
>    >
>    > 2. ```c++
>    >    //重写这个函数
>    >    void MainWindow::mousePressEvent(QMouseEvent*event)
>    >    {
>    >        if(event->button()==Qt::RightButton)
>    >        {
>    >            qDebug()<<event->position();
>    >          
>    >            //设置一个菜单栏menu!+menubar
>    >            QMenu *bar=new QMenu(this);
>    >            bar->addAction(new QAction("C++"));
>    >            bar->addAction(new QAction("Python"));
>    >            bar->addAction(new QAction("Javascript"));
>    >            //        bar->show();
>    >            //设置显示的位置，点击位置的右下角！
>    >           // QAction：QAction是一个表示菜单项的类。
>    >            QAction对象可以被添加到QMenu中，以在菜单中显示对应的菜单项。
>    >                QMenu是一个用于创建菜单的类。它可以包含多个菜单项（QAction对象）或子菜单（QMenu对象）。
>    >            bar->exec(QCursor::pos());
>    >        }
>    >          
>    >    }
>    >    ```
>    >    
>    > 3. ![image-20230814171018243](E:\MD\QTT.assets\image-20230814171018243.png)
>
>    ---
>
>    ```c++
>    // 函数原型:
>    上下文菜单策略用于定义在用户右键单击控件时如何显示上下文菜单。
>        上下文菜单策略只会影响右键单击事件。如果你想在其他事件（如鼠标中键单击、双击等）上显示上下文菜单，你需要根据具体的需求来处理。
>    void QWidget::setContextMenuPolicy(Qt::ContextMenuPolicy policy);
>    参数: 	
>      - Qt::NoContextMenu	     --> 不能实现右键菜单
>      - Qt::PreventContextMenu   --> 不能实现右键菜单
>      - Qt::DefaultContextMenu   --> 基于事件处理器函数 QWidget::contextMenuEvent() 实现
>      - Qt::ActionsContextMenu   --> 添加到当前窗口中所有 QAction 都会作为右键菜单项显示出来
>      - Qt::CustomContextMenu    --> 基于 QWidget::customContextMenuRequested() 信号实现
>    ```
>
>    ---
>
> 2. ####  通过Qt::CustomContextMenu菜单策略实现
>
>    > 1. `Qt::CustomContextMenu`策略会在用户右键单击控件时发射`QWidget::customContextMenuRequested()`信号。这个信号可以用于自定义处理右键菜单的显示和操作。
>    >
>    > 2. 使**用这个策略实现右键菜单, 当点击鼠标右键，窗口会产生一个 QWidget::customContextMenuRequested() 信号，注意仅仅只是发射信号，意味着要自己写显示右键菜单的槽函数（slot），这个信号是QWidget唯一与右键菜单有关的信号。**
>    >
>    > 3. **大家一定要注意这个坐标是当前窗口的窗口坐标, 不是屏幕坐标, 显示右键菜单需要使用屏幕坐标**
>    >
>    > 4. ```c++
>    >        this->setContextMenuPolicy(Qt::DefaultContextMenu);  
>    >        //Qt::CustomContextMenu策略会在用户右键单击控件时发射QWidget::customContextMenuRequested()信号。
>    >        //这个信号可以用于自定义处理右键菜单的显示和操作。
>    >        connect(this,&MainWindow::customContextMenuRequested,this,[=](){
>    >            QMenu *bar=new QMenu(this);
>    >            bar->addAction(new QAction("C++"));
>    >            bar->addAction("铸币");
>    >            bar->addAction(new QAction("Python"));
>    >            bar->addAction(new QAction("Javascript"));
>    >            //        bar->show();
>    >            //设置显示的位置，点击位置的右下角！
>    >            bar->exec(QCursor::pos());
>    >        });
>    >    ```
>    >
>    > 5. ![image-20230814173017444](E:\MD\QTT.assets\image-20230814173017444.png)
>
> 3. #### 通过 Qt::DefaultContextMenu菜单策略实现
>
>    >   
>    >
>    > ```c++
>    > 重写函数
>    >      this->setContextMenuPolicy(Qt::DefaultContextMenu);
>    > void MainWindow::contextMenuEvent(QContextMenuEvent *event)
>    > {
>    > 
>    >     //设置一个菜单栏menu!+menubar
>    >     QMenu *bar=new QMenu(this);
>    >     bar->addAction(new QAction("C++"));
>    >     bar->addAction(new QAction("Python"));
>    >     bar->addAction(new QAction("Javascript"));
>    >     //        bar->show();
>    >     //设置显示的位置，点击位置的右下角！
>    >     bar->exec(QCursor::pos());
>    > }
>    > ```
>    >
>    > 
>
> 4. #### 通过 Qt::ActionsContextMenu菜单策略实现（z最简单的）
>
>    **使用这个策略实现右键菜单, 是最简单的一种, 我们只需要创建一些 QAction类型的对象并且将他们添加到当前的窗口中, 当我们在窗口中点击鼠标右键这些QAction类型的菜单项就可以显示出来了。**
>
>    **但是它有一定的局限性，就是在一个窗口中不能根据不同的需求制作不同的右键菜单，这种方式只能得到一个唯一的右键菜单。**
>
>    直接在构造函数里面写！
>
>    ```c++
>        this->setContextMenuPolicy(Qt::ActionsContextMenu);
>          
>        QAction* act1  = new QAction("C++");
>        QAction* act2 = new QAction("Java");
>        QAction* act3  = new QAction("Python");
>        this->addAction(act1);
>        this->addAction(act2);
>        this->addAction(act3);
>    ```
>
> 

注意:

1. 默认的菜单策略是Qt::NoContextMenu	     --> 不能实现右键菜单

   ```c++
       QMenu *bar=new QMenu(this);
   //    bar.setParent(this);
       bar->resize(200,200);
       bar->addAction("野猪");
       bar->show();
   ```

   是无效的，要想生效得设置后两张菜单策略

2. 加一些对应的处理操作qaction有对应的信号

   ```c++
       connect(act1, &QAction::triggered, this, [=]()
       {
           QMessageBox::information(this, "title", "您选择的是C++...");
       });
   ```

3. tri ggered触发

   最后如果想要让自己的右键菜单项显示图标, 可以调用这个函数

4. ```
   // 只显示文本字符串
   QAction *QMenu::addAction(const QString &text);
   // 可以显示图标 + 文本字符串
   QAction *QMenu::addAction(const QIcon &icon, const QString &text);
   ```

   





## qt的按钮控件8.15

> 菜单类：
>
> ```c++
>         QMenu *m=new QMenu(this);
>         QAction *act1=m->addAction("1");
>         m->addAction("2");
>         m->addAction("3");
> 
>         QMenu *n=new QMenu(this);
>         n->addAction("1");
>         n->addAction("2");
>         QAction*act=n->addAction("3");
>         //设置标题
>         n->setTitle("adsds");
> 
>         m->addMenu(n);
> //给原来的菜单加了一个子菜单，当鼠标放到上面的时候会出现子菜单的内容，但是要手动设置那个标题
>         connect(act,&QAction::triggered,this,[=](){
> //            n->exec(QCursor::pos());
>             QMessageBox::about(this,"提示","去去去");
>         });
>         m->exec(QCursor::pos());
> ```
>
> ![image-20230902094949570](E:\MD\QTT.assets\image-20230902094949570.png)

### 1. 按钮基类 QAbstractButton

![image-20230815090815132](E:\MD\QTT.assets\image-20230815090815132.png)

后两个基本不需要使用

> 继承关系

![image-20230815090855947](E:\MD\QTT.assets\image-20230815090855947.png)





> 常用的api

1. 标题和图标

   > ```c++
   > // 参数text的内容显示到按钮上
   > void QAbstractButton::setText(const QString &text);
   > // 得到按钮上显示的文本内容, 函数的返回就是
   > QString QAbstractButton::text() const;
   > 
   > // 得到按钮设置的图标
   > QIcon icon() const;
   > // 给按钮设置图标
   > void setIcon(const QIcon &icon);
   > 
   > // 得到按钮图标大小
   > QSize iconSize() const
   > // 设置按钮图标的大小
   > [slot]void setIconSize(const QSize &size);
   > ```
   >
   > 对应实现
   >
   > ```c++
   > {
   >     ui->setupUi(this);
   >     QPushButton *btn=new QPushButton(this);
   >     btn->show();
   >     //    ---继承自qabstructbutton
   >     btn->setText("按钮");
   >     btn->setIcon(QIcon(":/D:/icon/img.png"));
   > 
   >     qDebug()<<btn->text();
   >     qDebug()<<btn->icon();
   > 
   > 
   > }
   > ```
   >
   > result
   >
   > ![image-20230815092044094](E:\MD\QTT.assets\image-20230815092044094.png)
   >
   > 总结:资源文件里的路径也不要有中文！！！！！

2. ![image-20230815092223821](E:\MD\QTT.assets\image-20230815092223821.png)

   ```c++
   // 判断按钮是否设置了checkable属性, 如果设置了点击按钮, 按钮一直处于选中状态
   // 默认这个属性是关闭的, not checkable
   bool QAbstractButton::isCheckable() const;
   // 设置按钮的checkable属性
   // 参数为true: 点击按钮, 按钮被选中, 松开鼠标, 按钮不弹起
   // 参数为false: 点击按钮, 按钮被选中, 松开鼠标, 按钮弹起
   void QAbstractButton::setCheckable(bool);
   -------------------------------------------------------------------------------------------
   
   // 判断按钮是不是被按下的选中状态
   bool QAbstractButton::isChecked() const;
   // 设置按钮的选中状态: true-选中, false-没选中
   // 设置该属性前, 必须先进行 checkable属性的设置
   void QAbstractButton::setChecked(bool);
   btn->setCheckable(true);//设置按钮也可以check，默认是不可以的.
   
   btn->setChecked(true);//设置默认是选中状态
   qDebug()<<btn->isChecked();//true
   qDebug()<<btn->isCheckable();//true
   ```

   ![image-20230815092710333](E:\MD\QTT.assets\image-20230815092710333.png)

3. ![image-20230815092840907](E:\MD\QTT.assets\image-20230815092840907.png)

   ```c++
   /*
   当按钮被激活时(即，当鼠标光标在按钮内时按下然后释放)，当键入快捷键时，或者当click()或animateClick()被调用时，这个信号被发出。值得注意的是，如果调用setDown()、setChecked()或toggle()，则不会触发此信号。
   */
   [signal] void QAbstractButton::clicked(bool checked = false);
   // 在按下按钮的时候发射这个信号
   [signal] void QAbstractButton::pressed();
   // 在释放这个按钮的时候发射直观信号
   [signal] void QAbstractButton::released();
   // 每当可检查按钮改变其状态时，就会发出此信号。checked在选中按钮时为true，在未选中按钮时为false。
   [signal] void QAbstractButton::toggled(bool checked);
   ```

4. 槽函数

   ```c++
   // 执行一个动画点击:按钮被立即按下，并在毫秒后释放(默认是100毫秒)。
   [slot] void QAbstractButton::animateClick(int msec = 100);
   // 执行一次按钮点击, 相当于使用鼠标点击了按钮
   [slot] void QAbstractButton::click();
   
   // 参考 1.2 中的函数介绍
   [slot] void QAbstractButton::setChecked(bool);
   // 设置按钮上图标大小
   [slot]void setIconSize(const QSize &size);//15/15
   // 切换可检查按钮的状态。 checked <==> unchecked
   [slot] void QAbstractButton::toggle();
   ```

### 2.QPushButton

![image-20230815101543434](E:\MD\QTT.assets\image-20230815101543434.png)

```c++
// 构造函数
/*
参数:
    - icon: 按钮上显示的图标
    - text: 按钮上显示的标题
    - parent: 按钮的父对象, 可以不指定,默认是不指定的
*/
QPushButton::QPushButton(const QIcon &icon, const QString &text, QWidget *parent = nullptr);
QPushButton::QPushButton(const QString &text, QWidget *parent = nullptr);
QPushButton::QPushButton(QWidget *parent = nullptr);

// 判断按钮是不是默认按钮
bool isDefault() const;
// 一般在对话框窗口中使用, 将按钮设置为默认按钮, 自动关联 Enter 键 
void setDefault(bool);
//////////////////////////////////////////////////
/*
将弹出菜单菜单与此按钮关联起来。这将把按钮变成一个菜单按钮，
在某些样式中会在按钮文本的右边产生一个小三角形。
*/
void QPushButton::setMenu(QMenu *menu);
////////////////////////////////////

/*
显示(弹出)相关的弹出菜单。如果没有这样的菜单，这个函数什么也不做。
这个函数直到弹出菜单被用户关闭后才返回。
*/
[slot] void QPushButton::showMenu();
    connect(btn,&QPushButton::clicked,btn1,&QPushButton::showMenu);
实现点击别的按钮，实现由带小三角的按钮，打开她的菜单。
    前提是这个按钮得setmenu
    槽函数其实就是行为函数，可以单独使用，也可以连接信号使用
```

```c++
    QMenu *menu=new QMenu(this);
    QAction action("铸币",this);
       QAction* act1  = new QAction("C++");
       QAction* act2 = new QAction("Java");
       QAction* act3  = new QAction("Python");
       menu->addAction(act1);
       menu->addAction(act2);
       menu->addAction(act3);

     connect(act3,&QAction::triggered ,this,[=](){
         QMessageBox::information(this,"提示","你选择了铸币");
     });
     //把菜单给关联起来
    btn1->setMenu(menu);
```

![image-20230815105246763](E:\MD\QTT.assets\image-20230815105246763.png)

> 1. 普通按钮
> 2. 带菜单的按钮
> 3. 可以设置选中的按钮

注意:

> [signal] void QAbstractButton::toggled(bool checked)
>
> 该信号的参数checked表示QAction的状态是否被切换为选中状态。
>
> ```c++
> connect(ui->checkedBtn, &QPushButton::toggled, this, [=](bool bl)
>         {
>             qDebug() << "我是一个checked按钮, 当前状态为:" << bl;
>         });意思是匿名函数可以捕获信号函数的参数。
> ```

### 3Qtoolbutton

![image-20230815140257037](E:\MD\QTT.assets\image-20230815140257037.png)

```c++
///////////////////////////// 构造函数 /////////////////////////////
QToolButton::QToolButton(QWidget *parent = nullptr);

/////////////////////////// 公共成员函数 ///////////////////////////
/*
    1. 将给定的菜单与此工具按钮相关联。
    2. 菜单将根据按钮的弹出模式显示。
    3. 菜单的所有权没有转移到“工具”按钮(不能建立父子关系)
*/
void QToolButton::setMenu(QMenu *menu);
// 返回关联的菜单，如果没有定义菜单，则返回nullptr。
QMenu *QToolButton::menu() const;

/*
弹出菜单的弹出模式是一个枚举类型: QToolButton::ToolButtonPopupMode, 取值如下:
    - QToolButton::DelayedPopup: 
        - 延时弹出, 按压工具按钮一段时间后才能弹出, 比如:浏览器的返回按钮
        - 长按按钮菜单弹出, 但是按钮的 clicked 信号不会被发射
    - QToolButton::MenuButtonPopup: 
        - 在这种模式下，工具按钮会显示一个特殊的箭头，表示有菜单。
	- 当按下按钮的箭头部分时，将显示菜单。按下按钮部分发射 clicked 信号
    - QToolButton::InstantPopup: 
        - 当按下工具按钮时，菜单立即显示出来。
        - 在这种模式下，按钮本身的动作不会被触发(不会发射clicked信号
*/
// 设置弹出菜单的弹出方式
void setPopupMode(QToolButton::ToolButtonPopupMode mode);
// 获取弹出菜单的弹出方式
QToolButton::ToolButtonPopupMode popupMode() const;

/*
QToolButton可以帮助我们在按钮上绘制箭头图标, 是一个枚举类型, 取值如下: 
    - Qt::NoArrow: 没有箭头
    - Qt::UpArrow: 箭头向上
    - Qt::DownArrow: 箭头向下
    - Qt::LeftArrow: 箭头向左
    - Qt::RightArrow: 箭头向右
*/
// 显示一个箭头作为QToolButton的图标。默认情况下，这个属性被设置为Qt::NoArrow。
void setArrowType(Qt::ArrowType type);
// 获取工具按钮上显示的箭头图标样式
Qt::ArrowType arrowType() const;

///////////////////////////// 槽函数 /////////////////////////////
// 给按钮关联一个QAction对象, 主要目的是美化按钮
[slot] void QToolButton::setDefaultAction(QAction *action);
// 返回给按钮设置的QAction对象
QAction *QToolButton::defaultAction() const;

/*
图标的显示样式是一个枚举类型->Qt::ToolButtonStyle, 取值如下:
    - Qt::ToolButtonIconOnly: 只有图标, 不显示文本信息
    - Qt::ToolButtonTextOnly: 不显示图标, 只显示文本信息
    - Qt::ToolButtonTextBesideIcon: 文本信息在图标的后边显示
    - Qt::ToolButtonTextUnderIcon: 文本信息在图标的下边显示
    - Qt::ToolButtonFollowStyle: 跟随默认样式(只显示图标)
*/
// 设置的这个属性决定工具按钮是只显示一个图标、只显示文本，还是在图标旁边/下面显示文本。
[slot] void QToolButton::setToolButtonStyle(Qt::ToolButtonStyle style);
// 返回工具按钮设置的图标显示模式
Qt::ToolButtonStyle toolButtonStyle() const;


// 显示相关的弹出菜单。如果没有这样的菜单，这个函数将什么也不做。这个函数直到弹出菜单被用户关闭才会返回。
[slot] void QToolButton::showMenu();
```

```c++
{
    ui->setupUi(this);
    QToolButton *tbtn=new QToolButton(this);
    QToolButton *tbtn1=new QToolButton(this);
    tbtn->show();
     tbtn1->show();
     tbtn1->setText("toolbtn普通");
     QToolButton *tbtn2=new QToolButton(this);
     tbtn2->show();
     tbtn2->setText("check");
     tbtn2->setCheckable(true);
     tbtn2->move(100,200);


     tbtn1->move(100,100);
    tbtn->setText("toolbtn");
    tbtn->setPopupMode(QToolButton::InstantPopup);

    QMenu *menu=new QMenu(this);
    QAction *act1=new QAction("牛");
    QAction *act2=new QAction("比");
    QAction *act3=new QAction("奶");
    QAction *act4=new QAction("嘴");
    QAction *act5=new QAction("嘴sdasdasd");
//tbtn->setArrowType(Qt::RightArrow);
    qDebug()<<tbtn->popupMode();
    tbtn->setIcon(QIcon("D:/icon/img.png"));
    menu->addAction(QIcon("D:/icon/img.png"),"牛逼");
    menu->addAction(act2);
    menu->addAction(act3);
    menu->addAction(act4);
    menu->setDefaultAction(act3);

    tbtn->setMenu(menu);
    //设置是菜单里某个加粗，相当于默认选择

    //设置的是toolbutton按钮上的字体
//    connect(ui->pushButton,&QPushButton::clicked,std::bind(&QToolButton::setDefaultAction,tbtn,(act1)));
    connect(ui->pushButton,&QPushButton::clicked,std::bind(&QToolButton::setToolButtonStyle,tbtn,(Qt::ToolButtonTextBesideIcon)));

}
```

![image-20230815151439198](E:\MD\QTT.assets\image-20230815151439198.png)

### 4Qradiobutton

![image-20230815153818178](E:\MD\QTT.assets\image-20230815153818178.png)

![image-20230815153919464](E:\MD\QTT.assets\image-20230815153919464.png)

![image-20230815154156522](E:\MD\QTT.assets\image-20230815154156522.png)

![image-20230815154634875](E:\MD\QTT.assets\image-20230815154634875.png)

**分组后，互相不打扰不干涉**

![image-20230815154725203](E:\MD\QTT.assets\image-20230815154725203.png)

测试是否发出clicked信号

![image-20230815154751505](E:\MD\QTT.assets\image-20230815154751505.png)

### 5Qcheckbox

![image-20230815154936709](E:\MD\QTT.assets\image-20230815154936709.png)

常用的API函数

```c++
// 构造函数
/*
参数:
    - text: 按钮上显示的文本信息
    - parent: 按钮的父对象
*/
QCheckBox::QCheckBox(const QString &text, QWidget *parent = nullptr);
QCheckBox::QCheckBox(QWidget *parent = nullptr);

// 判断当前复选框是否为三态复选框, 默认情况下为两种状态: 未选中, 选中
bool isTristate() const;
tri state
// 设置当前复选框为三态复选框: 未选中, 选中, 半选中
void setTristate(bool y = true);

/*
参数 state, 枚举类型 Qt::CheckState:
    - Qt::Unchecked	      --> 当前复选框没有被选中
    - Qt::PartiallyChecked    --> 当前复选框处于半选中状态, 部分被选中(三态复选框)
    - Qt::Checked	      --> 当前复选框处于选中状态
*/
// 设置复选框按钮的状态
void QCheckBox::setCheckState(Qt::CheckState state);
// 获取当前复选框的状态
Qt::CheckState QCheckBox::checkState() const;

```

信号signal

```c++
// 当复选框的状态改变时，即当用户选中或取消选中复选框时，他的信号就会发出。
// 参数 state 表示的是复选框的三种状态中某一种, 可参考 Qt::CheckState
[signal] void QCheckBox::stateChanged(int state);
利用槽函数去捕捉这个参数
    执行对应的操作
    是一个枚举值，对应着不同的状态！

```

```c++
{
    ui->setupUi(this);
    QCheckBox  *cb1=new QCheckBox("性感",this);
    QCheckBox  *cb2=new QCheckBox("性感1",this);
    QCheckBox  *cb3=new QCheckBox("性感2",this);
    cb1->show();
    cb2->show();
    cb3->show();
    cb2->move(0,40);
    cb3->move(0,80);
    cb3->setIcon(QIcon("D:/icon/img.png"));
    //开启三选功能
    cb3->setTristate(true);
    //是否开启了三选功能
    qDebug()<<cb3->isTristate();
    //设置默认的选择状态
    cb3->setCheckState(Qt::Unchecked);
//信号
    qDebug()<<cb3->checkState();
    connect(cb3,&QCheckBox::stateChanged,this,[=](){
        qDebug()<<"复选框的状态发生了改变！";
    });
}
```

实现完美的多选功能

```c++
    connect(ui->checkBox_5,&QCheckBox::stateChanged,this,&MainWindow::statenum);
    connect(ui->checkBox_6,&QCheckBox::stateChanged,this,&MainWindow::statenum);
    connect(ui->checkBox_7,&QCheckBox::stateChanged,this,&MainWindow::statenum);
    connect(ui->checkBox_8,&QCheckBox::stateChanged,this,&MainWindow::statenum);
//自定义个槽函数，当子选项的状态修改的时候，就利用我们自己的槽函数记录一下操作数,4个子选项
    connect(ui->checkBox_9,&QCheckBox::stateChanged,this,[=](){

        if(ui->checkBox_9->checkState()==Qt::Checked)
        {
            ui->checkBox_5->setCheckState(Qt::Checked);
            ui->checkBox_6->setCheckState(Qt::Checked);
            ui->checkBox_7->setCheckState(Qt::Checked);
            ui->checkBox_8->setCheckState(Qt::Checked);
        }
        else if(ui->checkBox_9->checkState()==Qt::Unchecked)
        {
            ui->checkBox_5->setCheckState(Qt::Unchecked);
            ui->checkBox_6->setCheckState(Qt::Unchecked);
            ui->checkBox_7->setCheckState(Qt::Unchecked);
            ui->checkBox_8->setCheckState(Qt::Unchecked);
        }

    });
    //实现父选项对子选项的控制
    
    void MainWindow::statenum(int s)
{
    if(s==Qt::Checked)
    {
        num++;
    }
    else if(s==Qt::Unchecked)
    {
        num--;
    }


    if(num==4)
    {
        ui->checkBox_9->setCheckState(Qt::Checked);
    }
    else if(num==0)
    {
        ui->checkBox_9->setCheckState(Qt::Unchecked);
    }
    else {
        ui->checkBox_9->setCheckState(Qt::PartiallyChecked);
    }
}
//自己的槽函数，记录一个数，执行对应的操作！！！

```

![image-20230815175052198](E:\MD\QTT.assets\image-20230815175052198.png)

完美实现！

## qt中容器类型的控件

![image-20230816102149246](E:\MD\QTT.assets\image-20230816102149246.png)

### Qwidget

![image-20230816101851752](E:\MD\QTT.assets\image-20230816101851752.png)

![image-20230816102059469](E:\MD\QTT.assets\image-20230816102059469.png)

![image-20230816102113462](E:\MD\QTT.assets\image-20230816102113462.png)

### Frame

![image-20230816102258664](E:\MD\QTT.assets\image-20230816102258664.png)

常用api

```c++
/*
边框形状为布尔类型, 可选项为:
    - QFrame::NoFrame: 没有边框
    
    - QFrame::Box: 绘制一个框
    
    - QFrame::Panel: 绘制一个面板，使内容显示为凸起或凹陷
    
    - QFrame::StyledPanel: 绘制一个外观取决于当前GUI样式的矩形面板。它可以上升也可以下沉。
    
    - QFrame::HLine: 画一条没有边框的水平线(用作分隔符)
    - QFrame::VLine: 画一条没有边框的垂直线(用作分隔符)
    
    - QFrame::WinPanel: 绘制一个矩形面板，可以像Windows 2000那样向上或向下移动。
	                指定此形状将线宽设置为2像素。WinPanel是为了兼容而提供的。
	                对于GUI风格的独立性，我们建议使用StyledPanel代替。
*/
// 获取边框形状
Shape frameShape() const;
// 设置边框形状
void setFrameShape(Shape);


/*
Qt中关于边框的阴影(QFrame::Shadow)提供了3种样式, 分别为: 
    - QFrame::Plain: 简单的,朴素的, 框架和内容与周围环境显得水平;
	             使用调色板绘制QPalette::WindowText颜色(没有任何3D效果)
    - QFrame::Raised: 框架和内容出现凸起;使用当前颜色组的明暗颜色绘制3D凸起线
    - QFrame::Sunken: 框架及内容物凹陷;使用当前颜色组的明暗颜色绘制3D凹线
*/

// 获取边框阴影样式
Shadow frameShadow() const;
// 设置边框阴影样式
void setFrameShadow(Shadow);

// 得到边框线宽度
int lineWidth() const;
// 设置边框线宽度, 默认值为1
void setLineWidth(int);

// 得到中线的宽度
int midLineWidth() const;
// 设置中线宽度, 默认值为0, 这条线会影响边框阴影的显示
设置边框线的宽度。中线的宽度大了，那么边框也就变厚了！
void setMidLineWidth(int);

```

```c++
{
    ui->setupUi(this);
    qDebug()<<ui->frame->frameShape();
    ui->frame->setFrameShape(QFrame::Box);
        qDebug()<<ui->frame->frameShape();
    qDebug()<<ui->frame->frameShadow();
        ui->frame->setFrameShadow(QFrame::Raised);
    qDebug()<<ui->frame->frameWidth();
        ///////是setlinwidth不是setframwidth
//    ui->frame->setLineWidth(10);
    qDebug()<<ui->frame->midLineWidth();
    ui->frame->setMidLineWidth(2);
}
```

![image-20230816103505118](E:\MD\QTT.assets\image-20230816103505118.png)

![image-20230816103629504](E:\MD\QTT.assets\image-20230816103629504.png)

![image-20230816103636361](E:\MD\QTT.assets\image-20230816103636361.png)

### Groupbox不常用

![image-20230816103720552](E:\MD\QTT.assets\image-20230816103720552.png)

![image-20230816103730019](E:\MD\QTT.assets\image-20230816103730019.png)

```c++
// 构造函数
QGroupBox::QGroupBox(QWidget *parent = Q_NULLPTR);
第二种食用
QGroupBox::QGroupBox(const QString &title, QWidget *parent = Q_NULLPTR);

// 公共成员函数
bool QGroupBox::isCheckable() const;
// 设置是否在组框中显示一个复选框
void QGroupBox::setCheckable(bool checkable);

/*
关于对齐方式需要使用枚举类型 Qt::Alignment, 其可选项为:
    - Qt::AlignLeft: 左对齐(水平方向)
    - Qt::AlignRight: 右对齐(水平方向)
    - Qt::AlignHCenter: 水平居中
    - Qt::AlignJustify: 在可用的空间内调整文本(水平方向)
	
    - Qt::AlignTop: 上对齐(垂直方向)
    - Qt::AlignBottom: 下对齐(垂直方向)
    - Qt::AlignVCenter: 垂直居中
*/
Qt::Alignment QGroupBox::alignment() const;
// 设置组框标题的对其方式
void QGroupBox::setAlignment(int alignment);

QString QGroupBox::title() const;
// 设置组框的标题
void QGroupBox::setTitle(const QString &title);

bool QGroupBox::isChecked() const;


// 设置组框中复选框的选中状态
[slot] void QGroupBox::setChecked(bool checked);
```

```c++
    QGroupBox*box=new QGroupBox("我是牛马",this);
    box->setGeometry(0, 0, 200, 200);
    box->setCheckable(true);
    qDebug()<<box->isCheckable();
    box->setChecked(false);
    qDebug()<<box->isChecked();


    qDebug()<<box->title();

    box->setAlignment(Qt::AlignVCenter);
    肥肠简单奥
```

![image-20230816105613333](E:\MD\QTT.assets\image-20230816105613333.png)

> flat间接的，平原
>
> 只能在属性窗口中设置，设置后组件的边框就没有了

![image-20230816110011195](E:\MD\QTT.assets\image-20230816110011195.png)

### Scroll Area

scroll滚筒，画卷

![image-20230816110150076](E:\MD\QTT.assets\image-20230816110150076.png)

![image-20230816110245793](E:\MD\QTT.assets\image-20230816110245793.png)

![image-20230816110321930](E:\MD\QTT.assets\image-20230816110321930.png)

```c++
// 构造函数
QScrollArea::QScrollArea(QWidget *parent = Q_NULLPTR);

// 公共成员函数
// 给滚动区域设置要显示的子窗口widget
void QScrollArea::setWidget(QWidget *widget);
// 删除滚动区域中的子窗口, 并返回被删除的子窗口对象
QWidget *QScrollArea::takeWidget();

/*
关于显示位置的设定, 是一个枚举类型, 可选项为:
    - Qt::AlignLeft: 左对齐
    - Qt::AlignHCenter: 水平居中
    - Qt::AlignRight: 右对齐
    - Qt::AlignTop: 顶部对齐
    - Qt::AlignVCenter: 垂直对其
    - Qt::AlignBottom: 底部对其
*/
// 获取子窗口在滚动区域中的显示位置
Qt::Alignment alignment() const;
// 设置滚动区域中子窗口的对其方式, 默认显示的位置是右上
void setAlignment(Qt::Alignment);

// 判断滚动区域是否有自动调节小部件大小的属性
bool widgetResizable() const;
/*
1. 设置滚动区域是否应该调整视图小部件的大小, 该属性默认为false, 滚动区域按照小部件的默认大小进行显示。
2. 如果该属性设置为true，滚动区域将自动调整小部件的大小，避免滚动条出现在本可以避免的地方，
   或者利用额外的空间。
3. 不管这个属性是什么，我们都可以使用widget()->resize()以编程方式调整小部件的大小，
   滚动区域将自动调整自己以适应新的大小。
*/
void setWidgetResizable(bool resizable);
```

```c++

{
    ui->setupUi(this);
    QScrollArea *area=new QScrollArea(this);
    area->setFixedHeight(200);
    ui->groupBox->setFixedSize(1000,1000);
    area->setWidget(ui->groupBox);
//    QWidget *a=area->takeWidget();
//    a->setFixedSize(100,100);

//    qDebug()<<area->takeWidget();
    area->setWidgetResizable(true);
}
```

![image-20230816125045128](E:\MD\QTT.assets\image-20230816125045128.png)

![image-20230816140215909](E:\MD\QTT.assets\image-20230816140215909.png)

```c++
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    // 创建一个垂直布局对象
    QVBoxLayout* vlayout = new QVBoxLayout;

    for(int i=0; i<11; ++i)
    {
        // 创建标签对象
        QLabel* pic = new QLabel;
        // 拼接图片在资源文件中的路径
        QString name = QString(":/images/%1.png").arg(i+1);
        // 给标签对象设置显示的图片
        pic->setPixmap(QPixmap(name));
        // 设置图片在便签内部的对其方式
        pic->setAlignment(Qt::AlignHCenter);
        // 将标签添加到垂直布局中
        vlayout->addWidget(pic);
    }

    // 创建一个窗口对象
    QWidget* wg = new QWidget;
    // 将垂直布局设置给窗口对象
    wg->setLayout(vlayout);
    // 将带有垂直布局的窗口设置到滚动区域中
    ui->scrollArea->setWidget(wg);
}

```

![image-20230816140310271](E:\MD\QTT.assets\image-20230816140310271.png)

### Toolbox（item）

![image-20230816221109227](E:\MD\QTT.assets\image-20230816221109227.png)

```c++
// 构造函数
QToolBox::QToolBox(QWidget *parent = Q_NULLPTR, Qt::WindowFlags f = Qt::WindowFlags());

// 公共成员
/*
addItem(), insertItem()函数相关参数:
    - widget: 添加到工具箱中的选项卡对应的子窗口对象
    - icon: 工具箱新的选项卡上显示的图标
    - text: 工具箱新的选项卡上显示的标题
    - index: 指定在工具箱中插入的新的选项卡的位置
*/
// 给工具箱尾部添加一个选项卡, 每个选项卡在工具箱中就是一个子窗口, 即参数widget
int QToolBox::addItem(QWidget *widget, const QString &text);
int QToolBox::addItem(QWidget *widget, const QIcon &icon, const QString &text);
// 在工具箱的指定位置添加一个选项卡, 即添加一个子窗口
int QToolBox::insertItem(int index, QWidget *widget, const QString &text);
int QToolBox::insertItem(int index, QWidget *widget, const QIcon &icon, 
                         const QString &text );
// 移除工具箱中索引index位置对应的选项卡, 注意: 只是移除对应的窗口对象并没有被销毁
void QToolBox::removeItem(int index);

// 设置索引index位置的选项卡是否可用, 参数 enabled=true为可用, enabled=false为禁用
void QToolBox::setItemEnabled(int index, bool enabled);
// 设置工具箱中index位置选项卡的图标
void QToolBox::setItemIcon(int index, const QIcon &icon);
// 设置工具箱中index位置选项卡的标题
void QToolBox::setItemText(int index, const QString &text);


// 设置工具箱中index位置选项卡的提示信息(需要鼠标在选项卡上悬停一定时长才能显示)
void QToolBox::setItemToolTip(int index, const QString &toolTip);

// 如果位置索引的项已启用，则返回true;否则返回false。
bool QToolBox::isItemEnabled(int index) const;


// 返回位置索引处项目的图标，如果索引超出范围，则返回空图标。
QIcon QToolBox::itemIcon(int index) const;
// 返回位于位置索引处的项的文本，如果索引超出范围，则返回空字符串。
QString QToolBox::itemText(int index) const;
// 返回位于位置索引处的项的工具提示，如果索引超出范围，则返回空字符串。
QString QToolBox::itemToolTip(int index) const;

// 得到当前工具箱中显示的选项卡对应的索引
int QToolBox::currentIndex() const;
// 返回指向当前选项卡对应的子窗口的指针，如果没有这样的项，则返回0。
QWidget *QToolBox::currentWidget() const;

// 返回工具箱中子窗口的索引，如果widget对象不存在，则返回-1
int QToolBox::indexOf(QWidget *widget) const;

// 返回工具箱中包含的项的数量。
int QToolBox::count() const;

// 信号
// 工具箱中当前显示的选项卡发生变化, 该信号被发射, index为当前显示的新的选项卡的对应的索引
[signal] void QToolBox::currentChanged(int index);

// 槽函数

// 通过工具箱中选项卡对应的索引设置当前要显示哪一个选项卡中的子窗口
[slot] void QToolBox::setCurrentIndex(int index);

// 通过工具箱中选项卡对应的子窗口对象设置当前要显示哪一个选项卡中的子窗口
[slot] void QToolBox::setCurrentWidget(QWidget *widget);

```



```c++
{
    ui->setupUi(this);
    QToolBox *tb=new QToolBox(this);
    QWidget *w1=new QWidget(this);

    QHBoxLayout *bj=new QHBoxLayout(this);
    QPushButton *btn1=new QPushButton("按钮1");
    QPushButton *btn2=new QPushButton("按钮2");
    QPushButton *btn3=new QPushButton("按钮3");
    bj->addWidget(btn1);
    bj->addWidget(btn2);
    bj->addWidget(btn3);
    w1->setLayout(bj);


    QWidget *w2=new QWidget(this);
    QWidget *w3=new QWidget(this);
    QWidget *w4=new QWidget(this);

    //选项卡就是一个子窗口，通过布局设置自定义窗口
    tb->addItem(w1,"选项卡1");
    tb->addItem(w2,"选项卡2");
    tb->addItem(w3,"选项卡3");
    //插入在index的位置
    tb->insertItem(0,w4,"我是插入进来的");
    //移除index位置的选项卡，但是并没有销毁这个选项卡。
    tb->removeItem(1);
    delete w1;
    //Qt 使用了自动内存管理机制，即对象树（object tree）机制。根据对象树机制，当一个对象作为另一个对象的子对象时，父对象负责管理子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。

    //在你的代码中，bj 布局的父对象对象是 w1 ，因此在 w1 被销毁时，bj 会负责销毁其中的按钮对象 btn1、btn2 和 btn3。这意味着你不需要手动删除这些按钮对象，它们会在适当的时候自动被销毁。

    tb->setFixedSize(500,500);

    //全部都不能用了
//    tb->setEnabled(false);
    //限制具体的选项卡

//    tb->setItemEnabled(1,false);

//    tb->setItemIcon();
//    tb->setItemText();
    tb->setItemToolTip(2,"我是牛马");
    tb->setCurrentIndex(2);
    //获取默认打开的选项卡的对象和下标
    qDebug()<<tb->currentWidget();
    qDebug()<<tb->currentIndex();
    //得到子窗口的下标
    qDebug()<<tb->indexOf(w3);
    //得到现存的选项卡的数量
    qDebug()<<tb->count();
//    QToolBox::currentChanged(int)
    void (QToolBox::*s)(int)=&QToolBox::currentChanged;

    connect(tb,s,this,[=](int index){
        qDebug()<<"新年好"<<index;
    });


}
```

Qt 使用了自动内存管理机制，即对象树（object tree）机制。根据对象树机制，当一个对象作为另一个对象的子对象时，父对象负责管理子对象的生命周期。当父对象被销毁时，它会自动销毁其所有子对象。

在你的代码中，`bj` 布局对象是 `w1` 的父对象，因此在 `w1` 被销毁时，`bj` 会负责销毁其中的按钮对象 `btn1`、`btn2` 和 `btn3`。这意味着你不需要手动删除这些按钮对象，它们会在适当的时候自动被销毁。

qtool属性设置

![image-20230817105510340](E:\MD\QTT.assets\image-20230817105510340.png)

### Tabwidget(tab)

![image-20230817105534856](E:\MD\QTT.assets\image-20230817105534856.png)

![image-20230817105556763](E:\MD\QTT.assets\image-20230817105556763.png)

```c++
// 构造函数
QTabWidget::QTabWidget(QWidget *parent = Q_NULLPTR);

// 公共成员函数
/*
添加选项卡addTab()或者插入选项卡insertTab()函数相关的参数如下:
    - page: 添加或者插入的选项卡对应的窗口实例对象
    - label: 添加或者插入的选项卡的标题
    - icon: 添加或者插入的选项卡的图标
    - index: 将新的选项卡插入到索引index的位置上
*/
int QTabWidget::addTab(QWidget *page, const QString &label);
int QTabWidget::addTab(QWidget *page, const QIcon &icon, const QString &label);
int QTabWidget::insertTab(int index, QWidget *page, const QString &label);
int QTabWidget::insertTab(int index, QWidget *page, 
                          const QIcon &icon, const QString &label);
// 删除index位置的选项卡
void QTabWidget::removeTab(int index);

// 得到选项卡栏中的选项卡的数量
int count() const;
// 从窗口中移除所有页面，但不删除它们。调用这个函数相当于调用removeTab()，直到选项卡小部件为空为止。
void QTabWidget::clear();
// 获取当前选项卡对应的索引
int QTabWidget::currentIndex() const;
// 获取当前选项卡对应的窗口对象地址
QWidget *QTabWidget::currentWidget() const;
// 返回索引位置为index的选项卡页，如果索引超出范围则返回0。
QWidget *QTabWidget::widget(int index) const;

/*
标签上显示的文本样式为枚举类型 Qt::TextElideMode, 可选项为:
    - Qt::ElideLeft: 省略号应出现在课文的开头，例如：.....是的,我很帅。
    - Qt::ElideRight: 省略号应出现在文本的末尾，例如：我帅吗.....。
    - Qt::ElideMiddle: 省略号应出现在文本的中间，例如：我帅.....很帅。
    - Qt::ElideNone: 省略号不应出现在文本中
*/
// 获取标签上显示的文本模式
Qt::TextElideMode QTabWidget::elideMode() const;
// 如何省略标签栏中的文本, 此属性控制在给定的选项卡栏大小没有足够的空间显示项时如何省略项。
void QTabWidget::setElideMode(Qt::TextElideMode);
    
// 得到选项卡上图标的尺寸信息
QSize QTabWidget::iconSize() const
// 设置选项卡上显示的图标大小
void QTabWidget::setIconSize(const QSize &size)

// 判断用户是否可以在选项卡区域内移动选项卡, 可以返回true, 否则返回false
bool QTabWidget::isMovable() const;
// 此属性用于设置用户是否可以在选项卡区域内移动选项卡。默认情况下，此属性为false;
void QTabWidget::setMovable(bool movable);

// 判断选项卡是否可以自动隐藏, 如果可以自动隐藏返回true, 否则返回false
bool QTabWidget::tabBarAutoHide() const;
// 如果为true，则当选项卡栏包含少于2个选项卡时，它将自动隐藏。默认情况下，此属性为false。
void QTabWidget::setTabBarAutoHide(bool enabled);

// 判断index对应的选项卡是否是被启用的, 如果是被启用的返回true, 否则返回false
bool QTabWidget::isTabEnabled(int index) const;
// 如果enable为true，则在索引位置的页面是启用的;否则，在位置索引处的页面将被禁用。
void QTabWidget::setTabEnabled(int index, bool enable);

// 得到index位置的标签对应的图标
QIcon QTabWidget::tabIcon(int index) const;
// 在位置索引处设置标签的图标。
void QTabWidget::setTabIcon(int index, const QIcon &icon);

/*
选项卡标签的位置通过枚举值进行指定, 可使用的选项如下:
	- QTabWidget::North: 北(上), 默认
	- QTabWidget::South: 南(下)
	- QTabWidget::West:	 西(左)
	- QTabWidget::East:  东(右)
*/
// 得到选项卡中显示的标签的位置, 即: 东, 西, 南, 北
TabPosition QTabWidget::tabPosition() const;
// 设置选项卡中标签显示的位置, 默认情况下，此属性设置为North。
void QTabWidget::setTabPosition(TabPosition);

/*
选项卡标签的形状通过枚举值进行指定, 可使用的选项如下:
	- QTabWidget::Rounded: 标签以圆形的外观绘制。这是默认形状
	- QTabWidget::Triangular: 选项卡以三角形外观绘制。
*/
// 获得选项卡标签的形状
TabShape QTabWidget::tabShape() const;
// 设置选项卡标签的形状
void QTabWidget::setTabShape(TabShape s);

// 得到index位置的标签的标题
QString QTabWidget::tabText(int index) const;
// 设置选项卡index位置的标签的标题
void QTabWidget::setTabText(int index, const QString &label);


// 获取index对应的标签页上设置的提示信息
QString QTabWidget::tabToolTip(int index) const;
// 设置选项卡index位置的标签的提示信息(鼠标需要悬停在标签上一定时长才能显示)
void QTabWidget::setTabToolTip(int index, const QString &tip);


// 判断选项卡标签也上是否有关闭按钮, 如果有返回true, 否则返回false
bool QTabWidget::tabsClosable() const;
// 设置选项卡的标签页上是否显示关闭按钮, 该属性默认情况下为false
void QTabWidget::setTabsClosable(bool closeable);


// 判断选项卡栏中是否有滚动按钮, 如果有返回true, 否则返回false
bool QTabWidget::usesScrollButtons() const;
// 设置选项卡栏有许多标签时，它是否应该使用按钮来滚动标签。
// 当一个选项卡栏有太多的标签时，选项卡栏可以选择扩大它的大小，或者添加按钮，让标签在选项卡栏中滚动。
void QTabWidget::setUsesScrollButtons(bool useButtons);

// 判断窗口是否设置了文档模式, 如果设置了返回true, 否则返回false
bool QTabWidget::documentMode() const;
// 此属性保存选项卡小部件是否以适合文档页面的模式呈现。这与macOS上的文档模式相同。
// 不设置该属性, QTabWidget窗口是带边框的, 如果设置了该属性边框就没有了。
void QTabWidget::setDocumentMode(bool set);

```

```c++
    ui->setupUi(this);
    QTabWidget *tw=new QTabWidget(this);
    tw->setFixedSize(200,200);
    QHBoxLayout *bj=new QHBoxLayout;
    QPushButton *btn1=new QPushButton("按钮1");
     QPushButton *btn2=new QPushButton("按钮2");
      QPushButton *btn3=new QPushButton("按钮3");
     bj->addWidget(btn1);
     bj->addWidget(btn2);
     bj->addWidget(btn3);

     QWidget *w1=new QWidget(this);

     QWidget *w2=new QWidget(this);
     QWidget *w3=new QWidget(this);
      QWidget *w4=new QWidget(this);
      QWidget *w5=new QWidget(this);
       QWidget *w6=new QWidget(this);
//     w3->setLayout(bj);
//     在你的代码中，你尝试将 bj 布局对象同时设置给了 w1 和 w3，这是不正确的。一个布局对象只能被设置给一个父部件，否则会导致布局对象的所有权问题。
     w1->setLayout(bj);

     
     tw->addTab(w1,"111");
     tw->addTab(w2,"222");
     tw->addTab(w4,"222");
     tw->addTab(w5,"222");
     tw->addTab(w6,"222");



     tw->insertTab(1,w3,"333");
     //插入到下标为index的位置
     tw->removeTab(0);
//     delete w3;

     qDebug()<<tw->count();
     qDebug()<<tw->currentIndex();
     qDebug()<<tw->currentWidget();
     qDebug()<<tw->elideMode();
//设置当文本不适合的时候省略号出现的位置
     tw->setElideMode(Qt::ElideMiddle);
//     Qt::ElideLeft（值为0）表示省略号应该出现在文本的开头。
//     Qt::ElideRight（值为1）表示省略号应该出现在文本的末尾。
//     Qt::ElideMiddle（值为2）表示省略号应该出现在文本的中间。
//     Qt::ElideNone（值为3）表示省略号不应该出现在文本中。


     //设置具体的选项卡的icon
     tw->setTabIcon(0,QIcon("://D:/icon/hig.png"));
     //设置所有选项卡的icon的尺寸
     tw->setIconSize(QSize(10,10));
//得到具体位置的icon的信息
     qDebug()<<tw->tabIcon(0);


     qDebug()<<tw->isMovable();
     //是指选项卡的移动，不是整个tab移动

     tw->setMovable(true);


     qDebug()<<tw->tabBarAutoHide();
//     tw->setTabBarAutoHide(true);
     //选项卡只有一个的时候会隐藏掉上面的选项卡栏

//     tw->removeTab(1);


     qDebug()<<tw->isTabEnabled(1);
//设置具体选项卡的权限
     tw->setTabEnabled(1,false);

     qDebug()<<tw->tabPosition();
     //设置选项卡的方向，东南西北
     tw->setTabPosition(QTabWidget::East);



     qDebug()<<tw->tabShape();
     tw->setTabShape(QTabWidget::Triangular);

//鼠标悬浮在上面的时候tooltip
     qDebug()<<tw->tabToolTip(0);
     tw->setTabToolTip(0,"选项阿卡！@！#@##@#");


    //给选项卡添加关闭按钮
     tw->setTabsClosable(true);
          qDebug()<<tw->tabsClosable();
     tw->setTabEnabled(1,true);
\
      //设置
     tw->setUsesScrollButtons(false);
     qDebug()<<tw->usesScrollButtons();

     qDebug()<<tw->documentMode();
     //设置了文档模式就没有了边框
     tw->setDocumentMode(true);



     tw->setCurrentWidget(w1);

     connect(tw,&QTabWidget::tabCloseRequested,this,[=](int index){
         tw->removeTab(index);
     });

     connect(tw,&QTabWidget::tabBarClicked,this,[=](){
         qDebug()<<"单击";

     });
     connect(tw,&QTabWidget::tabBarDoubleClicked,this,[=](int index){
         qDebug()<<"双击";
         tw->removeTab(index);
     });

```

![image-20230817145000425](E:\MD\QTT.assets\image-20230817145000425.png)

![image-20230817143941679](E:\MD\QTT.assets\image-20230817143941679.png)

![image-20230817144054580](E:\MD\QTT.assets\image-20230817144054580.png)



#### ==QQueue==

> `QQueue` 是 Qt 提供的一个**队列（queue）容器类**，用于存储一系列的元素。它是一个**先进先出（FIFO）的数据结构**，类似于现实生活中的排队。在 `QQueue` 中，**元素从队列的尾部添加，从队列的头部移除**。
>
> `QQueue` 是一个模板类，**可以存储任意类型的元素**。在你的代码中，`QQueue<QWidget*>` 表示一个存储 `QWidget*` 类型指针的队列，即存储 `QWidget` 对象的指针。
>
> 以下是一些常用的 `QQueue` 函数：
>
> - `enqueue(const T &value)`：**将元素添加到队列的尾部。**
> - `dequeue()`：**移除并返回队列头部的元素。**
> - `head()`：**返回队列头部的元素，但不会移除它。**
> - `isEmpty()`：**检查队列是否为空。**
> - `size()`：**返回队列中元素的数量。**

### Stacked widget（addwidget）

![image-20230817162315762](E:\MD\QTT.assets\image-20230817162315762.png)

![image-20230817162347283](E:\MD\QTT.assets\image-20230817162347283.png)

```c++
// 构造函数
QStackedWidget::QStackedWidget(QWidget *parent = Q_NULLPTR);

// 公共成员函数
// 在栈窗口中后边添加一个子窗口, 返回这个子窗口在栈窗口中的索引值(从0开始计数)
int QStackedWidget::addWidget(QWidget *widget);
// 将子窗口widget插入到栈窗口的index位置
int QStackedWidget::insertWidget(int index, QWidget *widget);
// 将子窗口widget从栈窗口中删除
void QStackedWidget::removeWidget(QWidget *widget);

// 返回栈容器窗口中存储的子窗口的个数
int QStackedWidget::count() const;
// 得到当前栈窗口中显示的子窗口的索引
int QStackedWidget::currentIndex() const;
// 得到当前栈窗口中显示的子窗口的指针(窗口地址)
QWidget *QStackedWidget::currentWidget() const;
// 基于索引index得到栈窗口中对应的子窗口的指针
QWidget *QStackedWidget::widget(int index) const;
// 基于子窗口的指针(实例地址)得到其在栈窗口中的索引
int QStackedWidget::indexOf(QWidget *widget) const;

////////////////////////////////////////////////
// 信号
// 切换栈窗口中显示子窗口, 该信息被发射出来, index为新的当前窗口对应的索引值
[signal] void QStackedWidget::currentChanged(int index);
// 当栈窗口的子窗口被删除, 该信号被发射出来, index为被删除的窗口对应的索引值
[signal] void QStackedWidget::widgetRemoved(int index);

/////////////////////////////////////////
// 槽函数
// 基于子窗口的index索引指定当前栈窗口中显示哪一个子窗口
[slot] void QStackedWidget::setCurrentIndex(int index);
[slot] void QStackedWidget::setCurrentWidget(QWidget *widget);

```

```c++
    ui->setupUi(this);

    QStackedWidget *sw=new QStackedWidget(this);
    sw->setFixedSize(400,400);



    QHBoxLayout *bj=new QHBoxLayout;
    QPushButton *btn1=new QPushButton("按钮1");
     QPushButton *btn2=new QPushButton("按钮2");
      QPushButton *btn3=new QPushButton("按钮3");
     bj->addWidget(btn1);
     bj->addWidget(btn2);
     bj->addWidget(btn3);

     QWidget *w1=new QWidget(this);




     QWidget *w2=new QWidget(this);

     w1->setLayout(bj);
              sw->addWidget(w1);
              sw->addWidget(w2);
                            qDebug()<<sw->count();
     sw->setCurrentWidget(w1);

     qDebug()<<sw->currentIndex();

     qDebug()<<sw->widget(1);

     qDebug()<<sw->indexOf(w2);


```

![image-20230817163236990](E:\MD\QTT.assets\image-20230817163236990.png)

![image-20230817163341666](E:\MD\QTT.assets\image-20230817163341666.png)

![image-20230817164113991](E:\MD\QTT.assets\image-20230817164113991.png)

> 可以在属性面板直接（添加页）,然后拖拽相应的 控件！！！所有控件都是他妈的容器





## QT事件处理

![image-20230818135346990](E:\MD\QTT.assets\image-20230818135346990.png)

```c++
int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    MainWindow w;
    w.show();
    //框架内部开始事件检测了
    return a.exec();
}
```

> **事件在Qt中产生之后，的分发过程是这样的：**
>
> 1. 当事件产生之后，Qt使用用应用程序对象调用notify()(通知)函数将事件**发送到指定的窗口**
>
>    ```c++
>    [override virtual] bool QApplication::notify(QObject *receiver, QEvent *e);
>    ```
>
> 2. 事件在发送过程中可以通过事件**过滤器进行过滤，默认不对任何产生的事件进行过滤。**
>
>    ```c++
>    [virtual] bool QObject::eventFilter(QObject *watched, QEvent *event)
>    ```
>
> 3. 当事件发送到指定窗口之后，窗口的**事件分发器会对收到的事件进行分类:**
>
>    ```c++
>    [override virtual protected] bool QWidget::event(QEvent *event);
>    ```
>
> 4. 事件分发器会将分类之后的事件**（鼠标事件、键盘事件、绘图事件。。。）**==分发给对应的事件处理器函数进行处理==，每个**事件处理器函数都有默认的处理动作（我们也可以重写这些事件处理器函数）**，比如：鼠标事件：
>
>    ```c++
>    // 鼠标按下
>    [virtual protected] void QWidget::mousePressEvent(QMouseEvent *event);
>    // 鼠标释放
>    [virtual protected] void QWidget::mouseReleaseEvent(QMouseEvent *event);
>    // 鼠标移动
>    [virtual protected] void QWidget::mouseMoveEvent(QMouseEvent *event);
>    ```

### 事件处理器函数

![image-20230818140257416](E:\MD\QTT.assets\image-20230818140257416.png)

#### 鼠标事件mouse....Event,特别2

> 1. ### 鼠标按下事件
>
>    > **当鼠标左键、鼠标右键、鼠标中键被按下，该函数被==自动调用==**，**通过参数可以得到当前按下的是哪个鼠标键**
>    >
>    > ```c++
>    > [virtual protected] void QWidget::mousePressEvent(QMouseEvent *event);
>    > ```
>    >
>    > ```c++
>    > void MainWindow::mousePressEvent(QMouseEvent *event)
>    > {
>    >     qDebug()<<event->button();
>    > 
>    >     if(event->button()==Qt::RightButton)
>    >     {
>    > //        Qt::RightButton
>    > //            Qt::LeftButton
>    > //            Qt::MiddleButtonq
>    > 
>    >     qDebug()<<event->position();
>    >         //设置一个菜单栏menu!+menubar
>    >         QMenu *bar=new QMenu(this);
>    >         bar->addAction(new QAction("C++"));
>    >         bar->addAction(new QAction("Python"));
>    >         bar->addAction(new QAction("Javascript"));
>    >         //        bar->show();
>    >         //设置显示的位置，点击位置的右下角！
>    >         bar->exec(QCursor::pos());
>    >     }
>    > 
>    > }
>    > ```
>    >
>    > 
>
> 2. ### 鼠标释放事件
>
>    > 当鼠标左键、鼠标右键、鼠标中键被释放，该函数被自动调用，**通过参数可以得到当前释放的是哪个鼠标键**
>    >
>    > ```c++
>    > [virtual protected] void QWidget::mouseReleaseEvent(QMouseEvent *event);
>    > ```
>    >
>    > ```c++
>    > void MainWindow::mouseReleaseEvent(QMouseEvent *event)
>    > {
>    >     qDebug()<<event->button();
>    >     if(event->button()==Qt::RightButton)
>    >     {
>    >         qDebug()<<"你按下了右键";
>    >     }
>    > }
>    > ```
>    >
>    > 和上面的触发相比，只是触发时机不
>
> 3. ### 鼠标移动事件
>
>    > 当鼠标移动（也可以按住一个或多个鼠标键移动），该函数被自动调用，通过参数可以得到在移动过程中哪些鼠标键被按下了。
>    >
>    > ```c++
>    > [virtual protected] void QWidget::mouseMoveEvent(QMouseEvent *event);
>    > ```
>    >
>    > ```c++
>    > void MainWindow:: mouseMoveEvent(QMouseEvent *event)
>    > {
>    >     qDebug()<<event->buttons()<<"经过";
>    > }
>    > 
>    > ```
>    >
>    > 1. `event->buttons()`：这是一个成员函数，用于获取鼠标移动事件发生时的鼠标按钮状态。它返回一个枚举值，表示当前按下的鼠标按钮。在 `qDebug()` 输出语句中，**它将输出当前按钮状态。**
>    > 2. `event->button()`：这也是一个成员函数，用于获取鼠标移动事件发生时的鼠标按钮。它返回一个枚举值，表示最后一次按下或释放的鼠标按钮。在 `qDebug()` 输出语句中，**它将输出最后一次按下或释放的按钮。**
>    >
>    > 所以，`event->buttons()` 输出的是当前按钮状态，而 `event->button()` 输出的是最后一次按下或释放的按钮。
>
> 4. ### 鼠标双鸡事件
>
>    > 当鼠标双击该函数被调用，通过参数可以得到是通过哪个鼠标键进行了双击操作。
>    >
>    > ```c++
>    > [virtual protected] void QWidget::mouseDoubleClickEvent(QMouseEvent *event);
>    > 
>    > ```
>    >
>    > ```c++
>    > void MainWindow::mouseDoubleClickEvent(QMouseEvent *event)
>    > {
>    >     qDebug()<<event->buttons()<<"双鸡了";
>    > }
>    > ```
>    >
>    > 
>
> 5. ### 鼠标进入事件--------------------------------------------
>
>    > ```c++
>    > [virtual protected] void QWidget::enterEvent(QEvent *event);
>    > 
>    > void MainWindow::enterEvent(QEnterEvent *event)
>    > ```
>    >
>    > 
>    >
>    > ```c++
>    > void MainWindow::enterEvent(QEnterEvent *event)
>    > {
>    >     qDebug()<<event->button()<<"大苏打";
>    > }
>    > void Widget::enterEvent(QEnterEvent *event)
>    > {
>    >     qDebug()<<"dasdasd";
>    > }
>    > ```
>    >
>    > 特别注意一下，这里面不是qevent而是qenterevent
>
> 6. ### 鼠标离开事件
>
>    > ```c++
>    > void Widget::enterEvent(QEnterEvent *event)
>    > {
>    >     qDebug()<<"dasdasd";
>    > }
>    > ```
>    >
>    > ```c++
>    > void MainWindow::leaveEvent(QEvent *event)
>    > {
>    >     qDebug()<<"移出去了";
>    > }
>    > ```
>
>    ---
>
>    //    void mousePressEvent(QMouseEvent *event);
>    //    void mouseReleaseEvent(QMouseEvent *event);
>    //    void mouseMoveEvent(QMouseEvent *event);
>    //    void mouseDoubleClickEvent(QMouseEvent *event);
>    //    void enterEvent(QEnterEvent *event);
>    //    void leaveEvent(QEvent *event);

#### 键盘事件key......Event

> 1. 键盘按下事件
>
>    > 当键盘上的按键被按下了，该函数被自动调用，通过参数可以得知按下的是哪个键。
>    >
>    > ```c++
>    > [virtual protected] void QWidget::keyPressEvent(QKeyEvent *event);
>    > ```
>    >
>    > ```c++
>    > void MainWindow::keyPressEvent(QKeyEvent *event)
>    > {
>    >     qDebug()<<event->key()<<"被按下了";
>    > }
>    > ```
>
> 2. 键盘释放事件
>
>    > 当键盘上的按键被释放了，该函数被自动调用，通过参数可以得知释放的是哪个键。
>    >
>    > ```c++
>    > [virtual protected] void QWidget::keyReleaseEvent(QKeyEvent *event);
>    > ```
>    >
>    > ```c++
>    > void MainWindow::keyReleaseEvent(QKeyEvent *event)
>    > {
>    >  qDebug()<<event->key()<<"被按下了";
>    > }
>    > ```
>    >
>    > ![image-20230820101016537](E:\MD\QTT.assets\image-20230820101016537.png)

#### 窗口重绘事件paintEvent

> 当窗口需要刷新的时候，该函数就会自动被调用。窗口需要刷新的情景很多，比如：**窗口大小发生变化，窗口显示等，另外我们还可以通过该函数给窗口绘制背景图**，总之这是一个需要经常被重写的一个事件处理器函数。
>
> ```c++
> [virtual protected] void QWidget::paintEvent(QPaintEvent *event);
> ```
>
> ```c++
> void MainWindow::paintEvent(QPaintEvent *event)
> {
> //    event->type();
>     qDebug()<<"窗口他妈重绘了！！";
> }
> ```
>
> 窗口的缩放，打开，都有
>
> 

#### 窗口关闭事件closeEvent

> 当窗口标题栏的**关闭按钮被按下并且在窗口关闭之前该函数被调用**，可以通过该函数控制窗口是否被关闭。
>
> ```c++
> [virtual protected] void QWidget::closeEvent(QCloseEvent *event);
> ```
>
> ```c++
> void MainWindow::closeEvent(QCloseEvent *event)
> {
>     //在点击了关闭按钮之后，窗口关闭之前，这个函数被调用
>     qDebug()<<"窗口被关闭；了啊";
> }
> ```
>
> 

#### 重置窗口大小事件resize Event

> ​	当窗口的大小发生变化，该函数被调用。
>
> ```c++
> [virtual protected] void QWidget::resizeEvent(QResizeEvent *event);
> ```
>
> ```c++
> 
> void MainWindow::resizeEvent(QResizeEvent *event)
> {
>     qDebug()<<"我去";
> }
> ```
>
> 当窗口的大小发生变化，该函数被调用。

//    void keyPressEvent(QKeyEvent *event);
//    void keyReleaseEvent(QKeyEvent *event);
//    void paintEvent(QPaintEvent *event);
//    void closeEvent(QCloseEvent *event);
//    void resizeEvent(QResizeEvent *event);

---

#### 以上总结的规律

除此之外，关于Qt窗口提供的其他事件处理器函数还有很多，感兴趣的话可以仔细阅读Qt的帮助文档，窗口的事件处理器函数非常好找，规律是这样的：

> **受保护的虚函数**
> 函数名分为两部分: **事件描述+Event**
> **函数带一个事件类型的参数**

#### 重写得到你自己的方案

![image-20230818155940410](E:\MD\QTT.assets\image-20230818155940410.png)

```c++
{
    ui->setupUi(this);
    this->setFixedSize(828,509);

}

MainWindow::~MainWindow()
{
    delete ui;
}


void  MainWindow::closeEvent(QCloseEvent *event)
{
    int ret=QMessageBox::question(this,"信息","你确定要关闭吗",QMessageBox::Yes|QMessageBox::No);
    if(ret==QMessageBox::Yes)
    {
        event->accept();
//        event->ignore();

    }
    else
    {
        event->ignore();
        QMessageBox::warning(this,"!","干嘛想要干我");
    }

}

void MainWindow::resizeEvent(QResizeEvent *event)
{
    qDebug()<<"老的尺寸"<<event->oldSize()<<"新的尺寸"<<event->size();
}

```

![image-20230818161109114](E:\MD\QTT.assets\image-20230818161109114.png)

![image-20230818161127925](E:\MD\QTT.assets\image-20230818161127925.png)

### 自定义按钮

![image-20230818161233519](E:\MD\QTT.assets\image-20230818161233519.png)

在Qt中，`p.drawPixmap(rect(), img)` 是用于在绘图设备上绘制一个图片的函数调用。

`p` 是一个绘图设备（通常是一个 `QPainter` 对象），用于在其上进行绘制操作。

`drawPixmap()` 是 `QPainter` 类的成员函数，用于绘制一个 `QPixmap` 对象或者其子类的图像。



**`rect()` 是一个成员函数，用于获取当前对象的矩形区域。在这个上下文中，`rect()` 是 `QWidget` 类的成员函数，用于获取 `QWidget` 对象的矩形区域。**

所以，`rect()` 返回了一个描述当前 `QWidget` 对象矩形区域的 `QRect` 对象。

在 `p.drawPixmap(rect(), img)` 中，`rect()` 返回的矩形区域作为绘制的目标区域，**`img` 是要绘制的图片对象。**

这样的调用将在绘图设备上绘制 `img` 图片对象，绘制的区域为当前 `QWidget` 对象的矩形区域。

![image-20230818171009657](E:\MD\QTT.assets\image-20230818171009657.png)

#### 源文件

```c++
#include "mybutton.h"
#include <QPainter>
mybutton::mybutton(QWidget *parent)
    : QWidget{parent}
{

    img.load("://D:/sucai/girl1.jpg");
    setFixedSize(500,800);
    //提升，相当于把父类当成子类，
}

void mybutton::mousePressEvent(QMouseEvent *ev)
{
img.load("://D:/sucai/girl2.jpg");
    //相当于手动刷新
    update();
}

void mybutton::mouseReleaseEvent(QMouseEvent *ev)
{
img.load("://D:/sucai/girl3.jpg");
    update();
}

void mybutton::enterEvent(QEnterEvent *ev)
{
img.load("://D:/sucai/girl7.jpg");
    update();
}

void mybutton::leaveEvent(QEvent *ev)
{
img.load("://D:/sucai/girl6.jpg");
    update();
}

void mybutton::paintEvent(QPaintEvent *event)
{
QPainter p(this);

    p.drawPixmap(rect(),img);
}


```

#### 头文件

```c++
#ifndef MYBUTTON_H
#define MYBUTTON_H

#include <QWidget>

class mybutton : public QWidget
{
    Q_OBJECT
public:
    explicit mybutton(QWidget *parent = nullptr);

    void setImage(QString normal, QString hover, QString pressed);

protected:
    void mousePressEvent(QMouseEvent* ev);
    void mouseReleaseEvent(QMouseEvent* ev);
    void enterEvent(QEnterEvent* ev);
    void leaveEvent(QEvent* ev);
    void paintEvent(QPaintEvent *event);
    //qt框架调用

//需要自己写信号发射
signals:
    void clicked();


private:
    QPixmap m_normal;
    QPixmap img;
    QPixmap m_press;
    QPixmap m_hover;
//    qpixmap专注于显示，效率更高，qimg是像素级别的修改，绘图
//    都能用于显示
//    QPixmap(const QString &fileName, const char *format = nullptr)
//    加在磁盘图片
//    或者load加载
    QPixmap m_current;
};

#endif // MYBUTTON_H

```

#### 注意事项

对于没有使用的函数参数有两种解决方案

1. ### Q_UNUSED(ev);

   ![image-20230819082950999](E:\MD\QTT.assets\image-20230819082950999.png)

2. #### 通过省略参数名，你告诉编译器你不会在函数体内使用该参数，这样就不会再收到未使用参数的警告。这是一种常见的做法，特别是在事件处理函数中，因为有些事件处理函数可能不需要使用事件对象的信息。

   ![image-20230819083020837](E:\MD\QTT.assets\image-20230819083020837.png)

```c++
void Mybtn::mousePressEvent(QMouseEvent *ev)
{
    img.load("://D:/sucai/girl5.jpg");
    update();
    QPushButton::mousePressEvent(ev);
    emit clicked();
//    QPushButton::mouseReleaseEvent(ev);
//    在默认情况下，QPushButton 的 mousePressEvent() 函数会在鼠标按钮按下后发射 clicked() 信号，
//    并在鼠标按钮释放后再次发射 clicked() 信号。这是为了模拟按钮的点击效果。

}
```

![image-20230819092014059](E:\MD\QTT.assets\image-20230819092014059.png)

这样才能发射出父亲原来的信号

![image-20230819092044956](E:\MD\QTT.assets\image-20230819092044956.png)

qwidget窗口的特点指定父亲就内嵌进去了 







#### 案例！

1. ```c++
   ui->setupUi(this);
   Buterfly *win=new Buterfly(this);
   win->move((width()-win->width())/2,(height()-win->height())/2);
   ```

2. ```c++
   #include "buterfly.h"
   #include <QPainter>
   Buterfly::Buterfly(QWidget *parent)
       : QWidget{parent}
   {
       img.load(":/1");
       setFixedSize(img.size());
       startTimer(100);
   }
   
   void Buterfly::paintEvent(QPaintEvent *ev)
   {
       QPainter p(this);
       p.drawPixmap(rect(),img);
   }
   
   void Buterfly::timerEvent(QTimerEvent *ev)
   {
       //123
       //
       m++;
       if(m==2)
       {
           m=2;
       }
       else if(m==3)
       {
           m=3;
       }
       else if(m==4)
       {
           m=4;
       }
       else
           m=1;
       QString name=QString(":%1").arg(m);
       img.load(name);
       update();
   }
   
   ```

3. ```c++
   #ifndef BUTERFLY_H
   #define BUTERFLY_H
   
   #include <QWidget>
   
   class Buterfly : public QWidget
   {
       Q_OBJECT
   public:
       explicit Buterfly(QWidget *parent = nullptr);
   protected:
       void paintEvent(QPaintEvent *ev);
       void timerEvent(QTimerEvent *ev);
   
   private:
       QPixmap img;
       int m=1;
   
   };
   
   #endif // BUTERFLY_H
   
   ```



![image-20230819100809654](E:\MD\QTT.assets\image-20230819100809654.png)

> 222222222222222222

###### 2.73逻辑运算符-与或非-

1. 与and   **==第一个为0就返回0，第一个为1就返回第二个操作数==**

2. ###### 或or   ==第一个为1就返回1，第一个为0就返回第二个操作数==

3. 根据第一个操作数的真假来确定是否返回第二个操作数

4. 非not

5. ==注意逻辑运算符左右不能直接与操作数直接接触==

`if(ev->buttons() & Qt::LeftButton)` 是一个条件判断语句，用于检查鼠标事件中的按钮状态。

`ev->buttons()` 返回一个表示当前鼠标按钮状态的整数值。`Qt::LeftButton` 是一个常量，表示鼠标左键。

通过使用位运算符 `&`，将 `ev->buttons()` 和 `Qt::LeftButton` 进行按位与运算。如果结果为非零值，则表示鼠标左键处于按下状态。

因此，`if(ev->buttons() & Qt::LeftButton)` 的意思是，如果鼠标左键处于按下状态，就执行 `if` 语句块中的代码。



```c++
void Buterfly::mousePressEvent(QMouseEvent *ev)
{
    //得到一个非零的数，然后与操作，就相当于看后面的数据了
    if(ev->button()==Qt::LeftButton)
    {
        index=ev->globalPos()-this->geometry().topLeft();
    }
}

void Buterfly::mouseMoveEvent(QMouseEvent *ev)
{
    if(ev->buttons()&Qt::LeftButton)
    {
        this->move(ev->globalPos()-index);
    }
}

```





---

```c++
    int setpx=QRandomGenerator::global()->bounded(10,50);
    int setpy=QRandomGenerator::global()->bounded(10,50);

    int curx=this->geometry().topLeft().x()+setpx;
    int cury=this->geometry().topLeft().y()+setpy;

    QScreen *screen = QGuiApplication::primaryScreen();
    if(curx>=screen->geometry().right())
    {
        curx=screen->geometry().left();
    }
    if(cury>=screen->geometry().bottom())
    {
        cury=screen->geometry().top();
    }

    move(curx,cury);

```

实现移动和边界处理

Mainwindow文件cpp

```c++
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include <buterfly.h>
#include <QRandomGenerator>
#include <QScreen>
#include <QMessageBox>
#include <QCloseEvent>
#include <QInputDialog>
#include <QDebug>
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
//    this->setFixedSize(2560,1440);


//去掉边框
    setWindowFlags(windowFlags()|Qt::FramelessWindowHint);
//设置窗口透明
    setAttribute(Qt::WA_TranslucentBackground);
//窗口最大化显示

    showMaximized();
    QScreen *screen = QGuiApplication::primaryScreen();
    qDebug()<<screen->geometry();
    for(int i=0;i<25;i++)
    {

        Buterfly *win=new Buterfly(this);
        win->move(QRandomGenerator::global()->bounded(this->width()),QRandomGenerator::global()->bounded(this->height()));
        win->show();
    };


}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::closeEvent(QCloseEvent *ev)
{
//    ev->ignore;
    ev->ignore();
    QMessageBox::warning(this,"warning","你真的以为你能关掉我嘛？",QMessageBox::No);
//    int ret=QMessageBox::question(this,"作答","4+4=?");

    int ret=QInputDialog::getInt(this,"作答","4+4=?",8);
        if(ret!=5)
        {
        ev->ignore();
        QMessageBox::information(this,"不对！","再试试吧");

        }
        else
        {
        ev->accept();
        QMessageBox::information(this,"恭喜!","恭喜你答对了！");
        }

}


```

butfly.h

```c++
#ifndef BUTERFLY_H
#define BUTERFLY_H

#include <QWidget>

class Buterfly : public QWidget
{
    Q_OBJECT
public:
    explicit Buterfly(QWidget *parent = nullptr);
protected:
    void paintEvent(QPaintEvent *ev);
    void timerEvent(QTimerEvent *ev);
    void mousePressEvent(QMouseEvent *ev);
    void mouseMoveEvent(QMouseEvent*ev);
    void enterEvent(QEnterEvent* ev);
    void fly();
    void fly(int min,int max);

private:
    QPixmap img;
    int m=1;

//    ----
    QPoint index;

};

#endif // BUTERFLY_H

```

butflycpp

```c++
#include "buterfly.h"
#include <QMouseEvent>
#include <QPainter>
#include <QRandomGenerator>
#include <QScreen>
#include <QGuiApplication>
Buterfly::Buterfly(QWidget *parent)
    : QWidget{parent}
{
    img.load(":/1");
    setFixedSize(img.size());
    
    startTimer(100);
}

void Buterfly::paintEvent(QPaintEvent *)
{
    QPainter p(this);
    p.drawPixmap(rect(),img);
}

void Buterfly::timerEvent(QTimerEvent *)
{
    fly();
}
///////////////////////////////////////////////////
void Buterfly::mousePressEvent(QMouseEvent *ev)
{
    //得到一个非零的数，然后与操作，就相当于看后面的数据了
    if(ev->button()==Qt::LeftButton)
    {
        index=ev->globalPos()-this->geometry().topLeft();
    }
}

void Buterfly::mouseMoveEvent(QMouseEvent *ev)
{
    if(ev->buttons()&Qt::LeftButton)
    {
        this->move(ev->globalPos()-index);
    }
}

void Buterfly::enterEvent(QEnterEvent *ev)
{
    fly(-200,200);
}


void Buterfly::fly()
{
    fly(10,50);
}




void Buterfly::fly(int min, int max)
{
    m++;
    if(m==2)
    {
        m=2;
    }
    else if(m==3)
    {
        m=3;
    }
    else if(m==4)
    {
        m=4;
    }
    else
        m=1;
    QString name=QString(":%1").arg(m);
    img.load(name);
    update();
    int setpx=QRandomGenerator::global()->bounded(min,max);
    int setpy=QRandomGenerator::global()->bounded(min,max);

    int curx=this->geometry().topLeft().x()+setpx;
    int cury=this->geometry().topLeft().y()+setpy;

    QScreen *screen = QGuiApplication::primaryScreen();
    if(curx>=screen->geometry().right())
    {
        curx=screen->geometry().left();
    }
    if(cury>=screen->geometry().bottom())
    {
        cury=screen->geometry().top();
    }
    move(curx,cury);
}

```

在 Qt 6 中，可以直接使用 `QGuiApplication::primaryScreen()` 来获取主屏幕的 `QScreen` 对象。所以你可以继续使用这个方法来获取屏幕对象。

简单地说，在 Qt 6 中，没有替代 `QGuiApplication::primaryScreen()` 的更简单的方法来获取主屏幕的 `QScreen` 对象。因此，你可以继续使用这个方法来获取主屏幕信息。



## QT事件分发器



![image-20230820091925794](E:\MD\QTT.assets\image-20230820091925794.png)

**关于窗口事件的分发，对应一个事件分发器，叫做event**

```c++
[override virtual protected] bool QWidget::event(QEvent *event);
```

> #### `override` 是 C++11 中的一个关键字，用于显式地指示派生类中的成员函数是对基类中的虚函数的重写（override）。在你提到的情况下，`override` 关键字用于指示派生类中的 `event` 函数是对 `QWidget` 基类中的 `event` 函数的重写。

通过事件分发器的函数原型可以得知，**关于事件类型的判断是基于参数完成的，**这个参数是一个**QEvent类**型的对象，下面来看一下这个类中常用的一些API函数:

```
void QEvent::accept();
```

该函数的作用是**让窗口接受传递过来的事件**，**事件不会向上层窗口（父窗口）传递**。--到此为止

```
void QEvent::ignore();
```

该函数的作用是**让窗口忽略传递过来的事件**，事件**被传递给父窗口（向上传递）**。--继续传递

---

```
bool QEvent::isAccepted() const;
void QEvent::setAccepted(bool accepted);
```

> **设置传递过来的事件是被接受还是被忽略**
> **setAccepted(true) == accept()**
> **setAccepted(false) == ignore()**

```c++
QEvent::Type QEvent::type() const;
```

**得到传递的窗口的事件的类型**，**返回值是一个枚举类型**，内容很多可以自己查帮助文档，简单的贴个图：

![image-20230820093000591](E:\MD\QTT.assets\image-20230820093000591.png)

### 事件分发器

**在不需要人为干预的情况下**，**事件分发器会自主的完成相关事件的分发**，下面来还原一下事件分发器的分发流程，以下是这个函数的部分源码展示：

```c++
bool QWidget::event(QEvent *ev)
{
    switch(ev->type())
    {
    // 鼠标移动
    case QEvent::MouseMove:		
        mouseMoveEvent((QMouseEvent*)event);
        break;
    // 鼠标按下
    case QEvent::MouseButtonPress:	
        mousePressEvent((QMouseEvent*)event);
        break;
    // 鼠标释放
    case QEvent::MouseButtonRelease:	
        mouseReleaseEvent((QMouseEvent*)event);
        break;
    // 鼠标双击
    case QEvent::MouseButtonDblClick:	
        mouseDoubleClickEvent((QMouseEvent*)event);
        break;
    // 键盘按键被按下事件
    case QEvent::KeyPress:
        break;
        ...
        ...
        ...
    default:
        break;
    }
}

```

>看到事件分发器在对事件进行判定之后会调用相关的事件处理器函数，这样事件就被最终处理掉了。

如果我们不想让某些触发的事件进入到当前窗口中，**可以在事件分发器中进行拦截**，拦截之前**先来了解一下事件分发器函数的返回值：**

> 如果传入的事件**已被识别并且处理，则需要返回 true，否则返回 false。**如果**返回值是 true，那么 Qt 会认为这个事件已经处理完毕**，**不会再将这个事件发送给其它对象**，而**是会继续处理事件队列中的下一事件**。
>
> 在event()函数中，**调用事件对象的 accept() 和 ignore() 函数是没有作用的，不会影响到事件的传播。**
>

举个例子，在窗口中**过滤掉鼠标按下的事件**:

```c++
bool MainWindow::event(QEvent *ev)
{
    if(ev->type() == QEvent::MouseButtonPress ||
            ev->type() == QEvent::MouseButtonDblClick)
    {
        // 过滤调用鼠标按下的事件
        return true;
    }
    return QWidget::event(ev);
    /////是具体的窗口
    return qtextevent::event(ev);
}
```

**这样窗口就再也收不到鼠标的单击和双击事件了**，对于这两个事件以外的其他事件是没有任何影响的，因为在重写的事件分发器函数的==**最后调用了父类的事件分发器函数**==

> ```c++
> return QWidget::event(ev);
> ```
>
> ##### 这样就能保证其他事件按照默认的分发流程进行分发，并最终被窗口处理掉。

## QT事件过滤器(fliter)



**除了使用事件分发器来过滤Qt窗口中产生的事件，还可以通过事件过滤器过滤相关的事件**。当Qt的事件通过应用程序对象发送给相关窗口之后，**窗口接收到数据之前这个期间可对事件进行过滤**，**过滤掉的事件就不能被继续处**理了。**==QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：==**

```c++
[virtual] bool QObject::eventFilter(QObject *watched, QEvent *event);
```

**watched：要过滤的事件的所有者对象**  过滤流
**event：要过滤的具体的事件**    过滤对象

**返回值：*****如果想过滤掉这个事件，停止它被进一步处理，返回true，否则返回 false**



### 方法！！

既然要过滤传递中的事件，**首当其冲还是要搞明白如何通过事件过滤器进行事件的过滤，主要分为两步：**



> 1. 给要被过滤事件的**类对象安装事件过滤器**
>
>    ```c++
>    void QObject::installEventFilter(QObject *filterObj);
>    ```
>
>    假设调用installEventFilter()函数的对象为当前对象，那么就可以基于参数指定的filterObj对象来过滤当前对象中的指定的事件了。
>
>    **QObject *filterObj);是修改过默认事件过滤器的对象**
>
> 2. 在要进行事件过滤的类中**（filterObj 参数对应的类）****==**重写从QObject类继承的虚函数eventFilter()**==

### 事件过滤器的使用

[举一个例子](https://blog.csdn.net/xideaha/article/details/132389149?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22132389149%22%2C%22source%22%3A%22xideaha%22%7D)

> 在一个窗口中**有一个多行文本输入框QTextEdit，****需要让我们屏蔽掉键盘上的回车键**，也就是按回车键之**后在这个文本编辑框中再也不能换行了。**

这三种方法 

1.自定义一个新的类让其继承QTextEdit，在这个子类中重写键盘事件keyPressEvent，在这个函数里边屏蔽掉回车键

2.自定义一个新的类让其继承QTextEdit，在这个子类中重写事件分发器event，在这个函数里边屏蔽掉回车键

3.给QTextEdit安装事件过滤器，基于QTextEdit的父窗口对这个控件的事件进行过滤

**820**

**Qt::Key_Enter是小键盘上的回车（确认）键，有些键盘没有小键盘，因此也就没有该按键。**
**Qt::Key_Return是大键盘上的回车键**



**通过这样的处理，事件在被应用程序对象发送出去之后，进入到对应的窗口之前就被其父窗口过滤掉了。**

**如果在Qt的窗口中有多层嵌套的窗口，如下图：**

![image-20230820105739083](E:\MD\QTT.assets\image-20230820105739083.png)

先来描述一下这四层窗口的关系：

顶层窗口A的直接子窗口是 B，间接子窗口是 C，QTextEdit
二级窗口B的直接子窗口是 C，间接子窗口是 QTextEdit
三级窗口C的直接子窗口是 QTextEdit

在这种多层嵌套窗口中如果想要过滤掉QTextEdit的某些事件，可以交给A或者B或者C去处理，当然也可以给QTextEdit同时安装多个过滤器：

**ui->textEdit->installEventFilter(窗口A对象);**
**ui->textEdit->installEventFilter(窗口B对象);**
**ui->textEdit->installEventFilter(窗口C对象);**

> 如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是说窗口C先进行事件过滤，然后窗口B，最后窗口A。 
>
> ---
>
> ---
>
> 注意事项：
>
> **事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。**

---

> ### **在Qt中，事件传递是根据对象树结构进行的，从父级对象向子级对象传递。**
>
> 当一个事件发生时，**它首先被发送给顶层窗口**（也就是**应用程序的主窗口**），然后**通过对象树结构一层层向下传递，直到找到合适的接收者**。
>
> 具体来说，事件传递的过程如下：
>
> 1. 事件首先被发送给顶层窗口，即应用程序的主窗口。
> 2. 如果顶层窗口不处理该事件，它会将事件传递给它的直接子窗口（也就是窗口A）。
> 3. 如果窗口A不处理该事件，它会将事件继续传递给它的直接子窗口（也就是窗口B）。
> 4. 如果窗口B不处理该事件，它会将事件继续传递给它的直接子窗口（也就是窗口C）。
> 5. 如果窗口C不处理该事件，它会将事件继续传递给它的直接子窗口（也就是QTextEdit）。
> 6. **如果QTextEdit不处理该事件，事件将被丢弃。**
>
> 在这个过程中，**每个窗口或控件都有机会处理事件。如果某个窗口或控件处理了事件，那么该事件就不会继续传递给它的子窗口或控件。**
>
> 在这种多层嵌套窗口的情况下，如果你想要过滤掉 `QTextEdit` 的某些事件，你有几种选择：
>
> 1. 将事件过滤器安装在顶层窗口A上：你可以在顶层窗口A的代码中安装一个事件过滤器，并在过滤器中对 `QTextEdit` 的事件进行处理。这样，所有发生在 `QTextEdit` 上的事件都会首先经过顶层窗口A的事件过滤器，然后再传递给 `QTextEdit` 进行处理。
>
> 2. 将事件过滤器安装在二级窗口B上：类似地，你也可以在二级窗口B的代码中安装一个事件过滤器，并在过滤器中对 `QTextEdit` 的事件进行处理。这样，所有发生在 `QTextEdit` 上的事件都会首先经过二级窗口B的事件过滤器，然后再传递给 `QTextEdit` 进行处理。
>
> 3. 将事件过滤器安装在三级窗口C上：同样地，你可以在三级窗口C的代码中安装一个事件过滤器，并在过滤器中对 `QTextEdit` 的事件进行处理。这样，所有发生在 `QTextEdit` 上的事件都会首先经过三级窗口C的事件过滤器，然后再传递给 `QTextEdit` 进行处理。
>
> 4. 给 `QTextEdit` 同时安装多个过滤器：你也可以给 `QTextEdit` 同时安装多个事件过滤器。这样，每个过滤器都会对 `QTextEdit` 的事件进行处理。这种方法适用于需要多个过滤器分别处理不同类型的事件的情况。
>
>    
>
>    流下来的时候直接被过滤掉了
>
> 事件过滤器是按照安装的顺序依次处理事件的。**==如果多个过滤器都对同一个事件进行了处理，最后安装的过滤器会先被调用。==**

## QT基于TCP的Qt网络通信

![image-20230820170203941](E:\MD\QTT.assets\image-20230820170203941.png)

tcp安全较于udp双向断开

### 1.QTcpServer

1.可以监听有没有客户端连接我

2.可以建立和客户端的连接

---

#### 常用API！

> 1. 构造函数
>
>    ```c++
>    QTcpServer::QTcpServer(QObject *parent = Q_NULLPTR);
>    ```
>
> 2. ```c++
>    // 判断当前对象是否在监听, 是返回true，没有监听返回false
>    bool QTcpServer::isListening() const;
>    // 如果当前对象正在监听返回监听的服务器地址信息, 否则返回 QHostAddress::Null
>    QHostAddress QTcpServer::serverAddress() const;
>    // 如果服务器正在侦听连接，则返回服务器的端口; 否则返回0
>    quint16 QTcpServer::serverPort() const
>    //设置监听对象
>    bool QTcpServer::listen(const QHostAddress &address = QHostAddress::Any, quint16 port = 0);
>    参数：
>    address：通过类QHostAddress可以封装IPv4、IPv6格式的IP地址，QHostAddress::Any表示自动绑定
>    port：如果指定为0表示//随机//绑定一个可用端口。【0，65535】》=5000
>    返回值：绑定成功返回true，失败返回false
>    ```
>
> 3. ```c++
>    //////////////////////////////////////////////
>    QTcpSocket *QTcpServer::nextPendingConnection();
>    
>        
>    得到和客户端建立连接之后用于通信的QTcpSocket套接字对象
>    它是QTcpServer的一个子对象
>    当QTcpServer对象析构的时候会自动析构这个子对象，当然也可自己手动析构
>    建议用完之后自己手动析构这个通信的QTcpSocket对象。
>    ```
>
> 4. ```c++
>    bool QTcpServer::waitForNewConnection(int msec = 0, bool *timedOut = Q_NULLPTR);
>    阻塞等待客户端发起的连接请求
>    不推荐在单线程程序中使用，建议使用非阻塞方式处理新连接，
>    即使用信号 newConnection() 。
>        参数：
>    msec：指定阻塞的最大时长，单位为毫秒（ms）
>    timeout：传出参数，如果操作超时timeout为true，没有超时timeout为false
>    ```
>
>    

#### 信号

```c++
[signal] void QTcpServer::acceptError(QAbstractSocket::SocketError socketError);
当接受新连接导致错误时，将发射如下信号。socketError参数描述了发生的错误相关的信息。
```

```c++
[signal] void QTcpServer::newConnection();
每次有新连接可用时都会发出 newConnection() 信号。
```

### 2.QTcpsSocket继承于qtcpserver

![image-20230820171252982](E:\MD\QTT.assets\image-20230820171252982.png)

#### 常用API

> 1. ```c++
>    QTcpSocket::QTcpSocket(QObject *parent = Q_NULLPTR);
>    构造函数
>    ```
>
> 2. ```c++
>    virtual] void QAbstractSocket::connectToHost(const QString &hostName, quint16 port, OpenMode openMode = ReadWrite, NetworkLayerProtocol protocol = AnyIPProtocol);
>                   
>    [virtual] void QAbstractSocket::connectToHost(const QHostAddress &address, quint16 port, OpenMode openMode = ReadWrite);
>    连接服务器
>                   
>    ```
>
>    **在Qt中不管调用读操作函数接收数据，还是调用写函数发送数据**，操作的对象都是**本地的由Qt框架维护的一块内存**。因此，调用了发送函数数据不一定会马上被发送到网络中，调用了接收函数也不是直接从网络中接收数据，**关于底层的相关操作是不需要使用者来维护的.**
>
> 3. ```c++
>    // 指定可接收的最大字节数 maxSize 的数据到指针 data 指向的内存中
>    qint64 QIODevice::read(char *data, qint64 maxSize);
>    // 指定可接收的最大字节数 maxSize，返回接收的字符串
>    QByteArray QIODevice::read(qint64 maxSize);
>    // 将当前可用操作数据全部读出，通过返回值返回读出的字符串
>    QByteArray QIODevice::readAll();
>    接收数据
>    ```
>
> 4. ```c++
>    // 发送指针 data 指向的内存中的 maxSize 个字节的数据
>    qint64 QIODevice::write(const char *data, qint64 maxSize);
>    // 发送指针 data 指向的内存中的数据，字符串以 \0 作为结束标记
>    qint64 QIODevice::write(const char *data);
>    // 发送参数指定的字符串
>    qint64 QIODevice::write(const QByteArray &byteArray);
>    发送数据
>    ```
>
>    

#### 信号

```c++
[signal] void QIODevice::readyRead();
在使用QTcpSocket进行套接字通信的过程中，如果该类对象发射出readyRead()信号，说明对端发送的数据达到了，之后就可以调用 read 函数接收数据了。
```

```c++
[signal] void QAbstractSocket::connected();
调用connectToHost()函数并成功建立连接之后发出connected()信号。
    检测客户端是否与服务器连接成功，再客户端使用
```

```c++
[signal] void QAbstractSocket::disconnected();
在套接字断开连接时发出disconnected()信号。
    两端都能使用，一旦使用就发出disconnect的信号
```

**qt维护的那一块内存是中间人**

### 通信流程

***使用Qt提供的类进行套接字通信比使用标准C API进行网络通信要简单***（因为在内部进行了封装）

**接收就是读，发送就是写**

1. 服务器端

   > 1.创建套接字服务器QTcpServer对象
   >
   > ```c++
   > m_s=new QTcpServer(this);
   > ```
   >
   > 2.通过QTcpServer对象设置监听，即：QTcpServer::listen()
   >
   > ```c++
   >     connect(m_s,&QTcpServer::newConnection,this,[=](){
   >         //接受连接成功后的子对象qtcpsocket
   > //        QTcpSocket *tcp=m_s->nextPendingConnection();
   >         m_o=m_s->nextPendingConnection();
   >          m_l->setPixmap(QPixmap(":/pass.png").scaled(20,20));
   > //        ui->hmsg->append("和客户端连接成功!");
   >          ui->hmsg->append("帅到汽车爆胎的小帅上线了");
   >          QMessageBox::information(this,"提示","小帅上线了！！！");
   > 
   >         connect(m_o,&QTcpSocket::readyRead,this,[=](){
   > //            qDebug()<<"信息来咯";
   >             //先读取信息
   >             QByteArray data=m_o->readAll();
   > 
   >             //把信息添加到历史画框里
   >             QDateTime now= QDateTime::currentDateTime();
   >             QString str=now.toString("[yyyy-MM-dd hh:mm:ss AP]>>");
   >             ui->hmsg->append("小帅"+str+data);
   >         });
   >         connect(m_o,&QTcpSocket::disconnected,this,[=](){
   >             m_o->close();
   >             m_o->deleteLater();
   >             m_l->setPixmap(QPixmap(":/pass.png").scaled(20,20));
   >             ui->hmsg->append("小帅断开了连接....难道是我不够美吗？呜呜呜");
   >             m_l->setPixmap(QPixmap(":/wrong.png").scaled(20,20));
   >             ui->playserver->setDisabled(false);
   >         });
   > ```
   >
   > 3.基于QTcpServer::newConnection()信号检测是否有新的客户端连接
   > 4.如果有新的客户端连接调用QTcpSocket *QTcpServer::nextPendingConnection()得到通信的套接字对象
   > 5.使用通信的套接字对象QTcpSocket和客户端进行通信
