# Linux第四次实验

## /etc/resolv.conf

`/etc/resolv.conf` 是 Linux 系统中的一个配置文件，用于指定域名解析器（DNS，Domain Name System）的配置信息。DNS 负责将人类可读的域名转换为计算机可理解的 IP 地址，以便进行网络通信。



![image-20231207193127857](C:/Users/%E8%AE%B8%E9%97%B0%E5%8D%9A/AppData/Roaming/Typora/typora-user-images/image-20231207193127857.png) 

## /etc/hosts

`/etc/hosts` 文件是一个本地的静态映射文件，用于将主机名与IP地址关联起来，从而绕过 DNS 解析直接进行地址解析。这个文件允许你手动指定某个主机名与相应的 IP 地址的映射关系，而不必依赖于 DNS 服务器。

在 `/etc/hosts` 文件中，每一行的格式通常如下：

```
<IP 地址>    <主机名>    <别名1> <别名2> ...
```

例如：

```
127.0.0.1    localhost
192.168.1.1  mycomputer
```

这表示将 `localhost` 映射到 `127.0.0.1`，将 `mycomputer` 映射到 `192.168.1.1`。这样，当系统尝试访问这些主机名时，会首先查看 `/etc/hosts` 文件，如果找到对应的映射，就会使用这个映射进行地址解析。

使用 `/etc/hosts` 文件的一个常见场景是在开发和测试环境中，当你想要模拟域名解析而不依赖于真实的 DNS 服务器时，可以在这个文件中添加自定义的映射关系。

需要注意的是，`/etc/hosts` 中的映射是静态的，不会自动更新。如果网络拓扑发生变化，或者你希望使用最新的 DNS信息，那么仍然需要通过 DNS 服务器进行解析。

![image-20231207193121447](C:/Users/%E8%AE%B8%E9%97%B0%E5%8D%9A/AppData/Roaming/Typora/typora-user-images/image-20231207193121447.png)



## `/etc/services` 

在 Linux 系统中，`/etc/services` 文件是一个用于**存储网络服务与其对应端口号的静态映射文件**。该文件包含了一些常见网络服务的名称、协议类型和默认端口号的信息。这样，系统和应用程序可以通过查询这个文件来了解服务名称与端口号之间的关系，而无需硬编码这些信息。

每一行的格式通常如下：

```
<服务名称> <端口号>/<协议类型> [<别名1> <别名2> ...]
```

例如：

```
http    80/tcp    www http
ssh     22/tcp
```

这表示 HTTP 服务通常使用 TCP 协议的端口号 80，而 SSH 服务通常使用 TCP 协议的端口号 22。

应用程序可以通过查询 `/etc/services` 文件来**获取服务的默认端口号**，而无需硬编码这些信息。这样的设计使得配置更加灵活，方便管理员或开发人员对服务端口号进行修改，而不需要修改应用程序代码。

需要注意的是，`/etc/services` 文件中的信息是静态的，不会动态更新。如果网络服务的端口号发生变化，或者有新的服务添加到系统中，`/etc/services` 文件可能需要手动更新。



## 四种主流Linux文件系统

1. **Ext4 (Fourth Extended File System)**
   - **特点：** 日志功能，支持更大文件和文件系统，向下兼容。

2. **XFS (X File System)**
   - **特点：** 高性能，支持快照，文件系统可扩展。

3. **Btrfs (B-Tree File System)**
   - **特点：** 快照和校验和，支持压缩，多设备支持。

4. **ZFS (Zettabyte File System)**
   - **特点：** 强调数据完整性，快照和克隆功能，自修复。



## 磁盘分区、格式化、挂载，主分区、扩展分区和逻辑分区。



1. **磁盘分区：**
   - **含义：** 磁盘分区是将硬盘分成若干个独立的区域，每个区域称为一个分区。分区有助于组织和管理数据，使操作系统能够有效地利用硬盘空间。
  
2. **格式化：**
   - **含义：** 格式化是指在磁盘分区上创建文件系统，以便操作系统能够在分区上存储和管理文件。格式化会清除分区上的所有数据，并为文件系统建立索引和元数据结构。

3. **挂载：**
   - **含义：** 挂载是将一个文件系统关联到计算机文件系统的特定目录上，使得该文件系统中的文件和目录能够被访问。挂载是一个将存储设备（如硬盘分区）与文件系统层级结构连接起来的过程。

4. **主分区、扩展分区和逻辑分区的关系：**
   - **主分区：** 主分区是硬盘上的一个独立区域，最多可以有四个主分区。每个主分区都可以包含一个文件系统，用于存储操作系统和用户数据。
   - **扩展分区：** 由于主分区数量有限，扩展分区的作用是扩展主分区的数量。一个硬盘上只能有一个扩展分区。扩展分区本身不能用来存储数据，但可以被划分为多个逻辑分区。
   - **逻辑分区：** 逻辑分区是在扩展分区内创建的分区，它们的数量没有限制。逻辑分区可以用于存储数据，扩展分区的作用是在硬盘上创建额外的逻辑分区。

总体来说，主分区和逻辑分区是用于存储数据的，而扩展分区则是为了克服主分区数量的限制，扩展硬盘的存储能力。逻辑分区都位于一个扩展分区内，而主分区则直接存在于硬盘上。







## 首先说明ifconfig**、ping、netstat三个命令的作用并举例说明

1. **ifconfig 命令：**
   
   - **作用：** `ifconfig` 命令用于配置和显示网络接口的信息，包括IP地址、子网掩码、MAC地址等。在一些新的 Linux 系统中，`ip` 命令已经逐渐替代了 `ifconfig`。
   
   - **例子：**
     ```bash
     # 显示所有网络接口信息
     ifconfig
     
     # 显示指定网络接口信息（例如eth0）
     ifconfig eth0
     
     # 设置IP地址和子网掩码
     sudo ifconfig eth0 192.168.1.2 netmask 255.255.255.0
     ```
   
2. **ping 命令：**
   
   - **作用：** `ping` 命令用于测试与目标主机之间的网络连接和延迟。通过向目标主机发送 ICMP 回显请求并等待回应，可以检查网络是否通畅。
   
   - **例子：**
     ```bash
     # 发送 ICMP 回显请求到目标主机（例如google.com）
     ping google.com
     
     # 发送指定数量的请求
     ping -c 5 google.com
     
     # 持续发送请求，直到手动停止（Ctrl+C）
     ping -t google.com
     ```
   
3. **netstat 命令：**
   
   - **作用：** `netstat` 命令用于显示网络状态和统计信息，包括网络接口、路由表、连接状态等。
   
   - **例子：**默认就好用
     
     ```bash
     # 显示所有网络连接和监听端口
     netstat -a
     
     # 显示网络接口信息
     netstat -i
     
     # 显示路由表
     netstat -r
     ```

这些命令在网络故障排除、配置网络参数和监控网络状态时非常有用。请注意，具体的命令选项和参数可能会因操作系统的不同而有所不同。上述示例中的命令适用于大多数 Linux 系统，但也可以根据需要进行适当的调整。







## Linux系统中的tar命令作用是什么？并举例说明tar调用gzip；tar调用bzip2；tar调用xz这三种压缩命令的用法。

`tar` 是一个用于在 Linux 系统中创建、查看和提取归档文件的命令。它的名字源自 "tape archive"，最初设计用于在磁带上存档文件。`tar` 可以将一组文件和目录打包成一个单一的文件，并且可以选择是否使用压缩算法对归档文件进行压缩。

以下是 `tar` 命令结合 `gzip`、`bzip2` 和 `xz` 这三种压缩命令的用法示例：

1. **tar 调用 gzip：**
   
   - **作用：** 使用 `gzip` 压缩算法对归档文件进行压缩。
   
   - **例子：**
     
     ```bash
     # 创建一个tar归档文件并用gzip压缩
     tar -czvf archive.tar.gz /path/to/directory
     
     # 解压缩tar归档文件
     tar -xzvf archive.tar.gz
     ```
   
2. **tar 调用 bzip2：**
   
   - **作用：** 使用 `bzip2` 压缩算法对归档文件进行压缩。
   
   - **例子：**
     ```bash
     # 创建一个tar归档文件并用bzip2压缩
     tar -cjvf archive.tar.bz2 /path/to/directory
     
     # 解压缩tar归档文件
     tar -xjvf archive.tar.bz2
     ```
   
3. **tar 调用 xz：**
   - **作用：** 使用 `xz` 压缩算法对归档文件进行压缩。

   - **例子：**
     ```bash
     # 创建一个tar归档文件并用xz压缩
     tar -cJvf archive.tar.xz /path/to/directory
     
     # 解压缩tar归档文件
     tar -xJvf archive.tar.xz
     ```

在上述例子中：
- `-c` 表示创建一个新的归档文件。
- `-v` 表示详细模式，显示处理的文件列表。
- `-f` 后跟着文件名，指定归档文件的名称。
- 对于压缩命令，`-z` 用于 gzip，`-j` 用于 bzip2，`-J` 用于 xz。
- `-x` 表示提取（解压）归档文件的内容。 



## 什么是rpm及yum，并简要描述其作用

**RPM (Red Hat Package Manager):**
- **作用：** RPM 是一种用于管理和分发软件包的包管理系统，最初由 Red Hat 开发。RPM 格式的软件包包含预编译的二进制文件、配置文件、文档等，并提供了一种简便的方式来安装、升级和删除软件。

**YUM (Yellowdog Updater Modified):**
- **作用：** YUM 是一个用于在基于 RPM 的 Linux 发行版中管理软件包的高级工具。YUM 可以自动解决软件包之间的依赖关系，简化了软件安装和更新的过程。它允许用户轻松地安装、升级、删除和查询软件包，同时自动处理相关的依赖关系。

**简要描述：**

1. **RPM：**
   - RPM 是一种软件包格式，用于封装和分发软件。
   - 使用 RPM，你可以通过命令行或图形界面轻松地安装、升级和删除软件包。
   - RPM 提供了一种标准化的方式来管理软件，适用于多个基于 RPM 的 Linux 发行版，如 Red Hat Enterprise Linux (RHEL)、Fedora、CentOS 等。

2. **YUM：**
   - YUM 是一个构建在 RPM 之上的高级包管理工具。
   - YUM 简化了软件包的管理过程，可以轻松解决依赖关系，自动下载和安装所需的软件包。
   - YUM 的软件仓库概念允许用户从远程服务器获取软件包，确保系统上的软件始终是最新的，并且可以一次性处理多个软件包的依赖关系。

在使用 YUM 时，你可以通过简单的命令（如 `yum install`、`yum update`）来处理软件包的安装和更新，而 YUM 将负责处理所有相关的依赖性和下载所需的软件包。这使得在基于 RPM 的系统上管理软件变得更加方便和高效。





## ps&top命令

**进程和程序的区别：**

- **程序：** **程序是存储在磁盘上的可执行文件**，它是一组指令和数据的集合，尚未被加载到内存中执行。
- **进程：** **进程是程序的实例**，是在内存中运行的程序。**一个程序可以同时运行多个进程**
- 每个进程有独立的内存空间和资源。
- ==线程之间内存空间和资源是共享的==

**进程的状态及状态转换：**

在操作系统中，进程有不同的状态，主要包括：

1. **创建态（New）：** 进程正在被创建，尚未进入就绪队列。
2. **就绪态（Ready）：** 进程已经准备好运行，等待被调度执行。
3. **运行态（Running）：** 进程正在 CPU 上执行指令。
4. **阻塞态（Blocked）：** 进程因为等待某个事件的发生而暂时停止执行，如等待输入/输出完成。
5. **终止态（Terminated）：** 进程执行完成或被终止，等待被移出系统。

状态之间的转换如下：
- **创建态 → 就绪态：** 进程已经创建完成，等待被调度执行。
- **就绪态 → 运行态：** 进程从就绪队列中被调度，开始执行。
- **运行态 → 阻塞态：** 进程因等待某事件而被阻塞，例如等待输入输出完成。
- **阻塞态 → 就绪态：** 等待的事件发生，进程重新准备好运行。
- **运行态 → 就绪态：** 进程被抢占，或者执行完成，重新进入就绪队列。
- **运行态 → 终止态：** 进程执行完成，或者因某种原因被强制终止。

**在Linux系统中查看进程：**

1. **ps 命令：**
   
   - **作用：** `ps` 命令用于显示当前运行在系统中的进程。
   - **例子：**
     ```bash
     # 显示当前用户的所有进程
     ps
     
     # 显示系统中所有进程的详细信息
     ps aux
     ```
   
2. **top 命令：**
   - **作用：** `top` 命令实时显示系统中运行的进程的信息，包括 CPU 占用、内存使用等。
   - **例子：**
     ```bash
     # 显示实时进程信息
     top
     ```
   - **区别：**
     
     - `ps` 提供一次性的进程快照，而 `top` 提供实时动态的进程信息。
     - `top` 显示的信息更为动态和全面，适用于查看系统资源状况。





![image-20231207195821838](C:/Users/%E8%AE%B8%E9%97%B0%E5%8D%9A/AppData/Roaming/Typora/typora-user-images/image-20231207195821838.png) 

父进程和子进程之间的关系是通过进程创建操作来建立的。在 UNIX/Linux 操作系统中，使用 `fork` 系统调用来创建一个新的进程。下面是父进程和子进程的关系：

1. **父进程：**
   - **PID（进程标识符）：** 父进程的 PID 是一个正整数，表示操作系统分配给父进程的唯一标识符。
   - **PPID（父进程的进程标识符）：** 父进程的 PPID 是指创建它的进程的 PID。在 `fork` 后，父进程中的 `fork` 调用返回子进程的 PID。

2. **子进程：**
   - **PID：** 子进程的 PID 是一个新的正整数，不同于父进程的 PID。它是操作系统为子进程分配的唯一标识符。
   - **PPID：** 子进程的 PPID 是指创建它的进程的 PID，即父进程的 PID。

通过这种方式，父进程和子进程在进程标识符上有所区别，但它们之间共享某些资源，如文件描述符、内存映射、信号处理等。

在 `fork` 后，父进程和子进程将继续执行原始代码的副本，但它们各自拥有独立的内存空间。修改一个进程的内存空间不会影响另一个进程的内存空间。

父子进程通常用于实现并发执行，其中父进程和子进程可以同时执行不同的任务。在实际应用中，父子进程之间的通信和同步是需要特别注意的问题，可以使用进程间通信（IPC）机制来实现。 



## **说明进程和程序的区别，并说明进程分为几种状态，以及进程各种状态如何转换；在Linux系统中查看进程时，举例说明ps和top命令的区别**

**进程和程序的区别：**

- **程序：** 程序是存储在磁盘上的可执行文件，它是一组指令和数据的集合，尚未被加载到内存中执行。
  
- **进程：** 进程是程序的实例，是在内存中运行的程序。一个程序可以同时运行多个进程，每个进程有独立的内存空间和资源。

**进程的状态及状态转换：**

在操作系统中，进程有不同的状态，主要包括：

1. **创建态（New）：** 进程正在被创建，尚未进入就绪队列。
2. **就绪态（Ready）：** 进程已经准备好运行，等待被调度执行。
3. **运行态（Running）：** 进程正在 CPU 上执行指令。
4. **阻塞态（Blocked）：** 进程因为等待某个事件的发生而暂时停止执行，如等待输入/输出完成。
5. **终止态（Terminated）：** 进程执行完成或被终止，等待被移出系统。

状态之间的转换如下：
- **创建态 → 就绪态：** 进程已经创建完成，等待被调度执行。
- **就绪态 → 运行态：** 进程从就绪队列中被调度，开始执行。
- **运行态 → 阻塞态：** 进程因等待某事件而被阻塞，例如等待输入输出完成。
- **阻塞态 → 就绪态：** 等待的事件发生，进程重新准备好运行。
- **运行态 → 就绪态：** 进程被抢占，或者执行完成，重新进入就绪队列。
- **运行态 → 终止态：** 进程执行完成，或者因某种原因被强制终止。

**在Linux系统中查看进程：**

1. **ps 命令：**
   - **作用：** `ps` 命令用于显示当前运行在系统中的进程。
   - **例子：**
     ```bash
     # 显示当前用户的所有进程
     ps
     
     # 显示系统中所有进程的详细信息
     ps aux
     ```

2. **top 命令：**
   
   - **作用：** `top` 命令实时显示系统中运行的进程的信息，包括 CPU 占用、内存使用等。
   - **例子：**
     ```bash
     # 显示实时进程信息
     top
     ```
   - **区别：**
     - `ps` 提供一次性的进程快照，而 `top` 提供实时动态的进程信息。
     - `top` 显示的信息更为动态和全面，适用于查看系统资源状况。