# 图

![image-20240426084310597](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426084310597.png) 

## 图的定义和基本术语

### 图的定义

<a id="连通"></a>

图（Graph）是由节点（Vertex）和边（Edge）组成的一种抽象数据类型。

图可以用来表示各种实体之间的关系，例如网络中的计算机节点、社交网络中的用户以及道路交通中的路线等。

1. **节点（Vertex）**：也称为顶点，是图中的基本元素，可以表示任意实体或对象。节点可以有标签或属性来描述其特征。
2. **边（Edge）**：边是节点之间的连接，用于表示节点之间的关系或连接。边可以是有向的（箭头指向一个方向）或无向的（没有方向）。
3. **权重（Weight）**：有些图的边可能会关联一个权重，表示连接两个节点之间的某种度量或成本。例如，在路线图中，边的权重可以表示两地之间的距离或时间。
4. **路径（Path）**：路径是图中连接节点的序列，由一系列的边组成。路径可以是简单路径（不经过同一节点两次）、环路（起点和终点相同的路径）、长度等等。
5. **有向图和无向图**：有向图中，边是有方向的，即从一个节点指向另一个节点；无向图中，边没有方向，可以双向连接两个节点。
6. **连通图和非连通图**：如果图中的任意两个节点之间都存在路径，则称该图是连通图；否则称为非连通图。
7. **图的表示方法**：图可以使用邻接矩阵、邻接表、关联矩阵等方式来表示。

> 图：G=(V,E)
>
> V: 顶点(数据元素)的**有穷非空集合**；
>
> E：边的**有穷**集合

Graph=(Vertex,Edge)



### 图的基本术语

#### 有/无向图

![image-20240426084518481](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426084518481.png) 



#### 完全图

![image-20240426084634050](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426084634050.png) 



#### 稀疏图&稠密图&网

1. **稀疏图（Sparse Graph）**：
   - 稀疏图是指**图中的边相对于节点的数量较少的图**。
   - 在稀疏图中，节点之间的连接并不是非常密集，大部分节点之间都没有直接的边相连。
   - 通常情况下，稀疏图的边数远远小于节点数的平方级别。
2. **稠密图（Dense Graph）**：
   - 稠密图是指**图中的边相对于节点的数量较多的图**。
   - 在稠密图中，节点之间的连接比较密集，大部分节点之间都有直接的边相连。
   - 通常情况下，稠密图的边数接近于节点数的平方级别。

网：边上带权值的图

#### 邻接&关联(依附)

> 邻接: 
>
> '有边/弧相连的两个顶点之间的关系。 
>
> 存在**(Vi, Vj)**，则称vi和vjj**互为邻接点**;
>
> 存在**<Vi,Vj>**，则称**vi邻接到vj**，Vj邻接于Vi;

关联:边/弧与顶点之间的关系。

存在(Vi, Vj)/ <V, Vj>，则称该边/弧关联于vi和vj



#### 顶点的度

顶点的度：与该顶点像关联的边的数目记作TD(v)

有向图里面又分为入度和出度

入度：是以 **v 为终点的有向边的条数**, 记作 ID(v)

出度:   是**以v为始点的有向边的条数**，记作 OD(v)

![image-20240426085822035](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426085822035.png) 

> 仅有一个顶点的入度为0，其余顶点的入度均为1，此时为树

#### 路径&路径长度

路径：接续的边构成的**顶点序列**；

路径长度：路径上边或弧的**数目/权值的之和;**

回路(环)：**第一个顶点和最后一个顶点相同**的路径

简单路径：**除路径起点和终点可以相同外**，其余顶点均不相同的路径

简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径

![image-20240426090309058](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426090309058.png) 



#### 连通图&强连通图

在无(有）向图G=(V,{E})中，若对**任何两个顶点v、u都存在从v到u的路径**则称G是连通图(**强连通图**)

![image-20240426090450364](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426090450364.png) 

![image-20240426090516585](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426090516585.png) 



#### 权与网

> 图中**边或弧所具有的相关数**称为**权**。表明从一个顶点到另-一个顶点的距离或耗费。
>
> 带权的图称为**网**,



#### 子图

设有两个图G= （V，{E}）、G1= （V1，{E1}），若V1∈ V，E1 ∈E,则称 G1是G的子图。

主图抹去线得到子图；

![image-20240426090735665](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426090735665.png) 



#### 连通分量

> 1. **连通分量**：在无向图 G 中，一个连通分量是**指 G 的一个子图**，该子图中是连通的，即任意两个顶点之间存在路径。换句话说，连通分量是一个**最大的连通子图**，其中任意两个顶点都可以通过路径相互到达，而且**不能再添加其他顶点来保持连通性**。
>
> 2. **极大连通子图**：在图论中，极大连通子图指的是一个连通子图，如果**再添加****任何不在该子图中的顶点，该子图就不再连通**。换句话说，**极大连通子图是不能再扩展的连通子图**，再添加任何其他顶点都会破坏连通性。
>
> 3. **连通分量是极大连通子图**：由上述定义可知，**连通分量就是无向图中的一个极大连通子图**。这是因为连通分量已经是一个最大的连通子图，再添加任何其他顶点都会破坏连通性，因此它同时也是一个极大连通子图。
>

![image-20240426091446439](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426091446439.png) 

有向图G的极大强连通子图是G的强连通分量

极大强连通子图意思是：该子图是G的强连通子图，将D的任何不在该子图中的顶点加入，子图不再是强连通的 

![image-20240426091631778](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426091631778.png) 



#### 极小连通子图

> 1. **极小连通子图**：在无向图 G 中，一个极小连通子图是指 G 的一个连通子图，如果移除任何一个顶点或者边，该子图就不再连通。换句话说，极小连通子图是在保持连通性的前提下，不能再移除任何顶点或者边，否则子图就不再连通。

- 极大连通子图关注的是在保持连通性的情况下，不能再**添加**任何顶点，否则子图就不再连通。
- 极小连通子图关注的是在保持连通性的前提下，不能再**移除**任何**顶点或者边**，否则子图就不再连通。



#### 生成树&生成森林

生成树：包含无向图G所有顶点的极小连通子图

生成森林：对非连通图，由各个连通分量的生成树的集合

> 1. **生成树**（Spanning Tree）：
>
>    - 生成树是原图的一个子图，它保留了原图的所有节点，并且通过连接这些节点的边构成了一棵树。
>    - 生成树中的边数量恰好为节点数量减去1，因为树结构中任意两个节点之间只有一条路径，所以树中的边数等于节点数减1，这样才能确保没有形成环路。
>
>    ![image-20240426092202321](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426092202321.png) 
>
> 2. **生成森林**（Spanning Forest）：
>
>    - 如果一个图不是连通图，那么它就不可能有生成树。但是，如果一个图是非连通的，那么它可能由多个连通分量组成。在这种情况下，每个连通分量都可以找到一个生成树，这些生成树的集合就被称为生成森林。
>    - 生成森林是由多棵生成树组成的，每棵生成树对应图的一个连通分量。每个生成树都包含了对应连通分量的所有节点，且保留了原图中的部分边，使得每个连通分量形成一棵树结构。





## 六度空间理论

 ![image-20240426105758159](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426105758159.png) 

> 但是米尔格兰姆的理论从来没有得到过严谨的证明，虽然屡屡应验虽然很多社会学家一直都对其兴趣浓厚，但它只是一种假说。现在，许多科学家对此进行研究，它们都不约而同地使用了网络时代的新型通讯手段对“小世界现象”进行验证把六度空间理论中的人际关系网络抽象成一个无向图G。用图G中的个顶点表示一个人，两个人认识与否用代表这两个人的顶点之间是否有--条边来表示。从任一顶点出发用**广度优先方法对图进行遍历**，统计所有路径长度不超过7的顶点



## 图的类型定义&存储结构

### 图的抽象类型定义

```
ADT Graph{
    数据对象V：具有相同特性的数据元素的集合，称为顶点集
    数据关系R：R={<v,w> | <v,w>表示从顶点v到顶点w的边}
    约束条件P(v,w)：定义了边<v,w>的信息

    CreateGraph(&G,V,VR)
        初始条件：V 是图的顶点集，VR 是图中边的集合
        操作结果：按照顶点集 V 和边集 VR 的定义构造图 G

    DFSTraverse(G)
        初始条件：图 G 存在
        操作结果：对图进行深度优先遍历

    BFSTraverse(G)
        初始条件：图 G 存在
        操作结果：对图进行广度优先遍历
}

```

### 图的存储结构

> 多对多：
>
> **图没有顺序存储结构**
>
> 但可以借助二维数组来表示元素间的关系，数组表示法（邻接矩阵）
>
> 链式存储结构，图有多少个指针域呢？（不确定因为不知道有多少个度）
>
> 所以用多重链表：**邻接表，邻接多重表，十字链表**
>
> ---
>
> 终点：邻接矩阵（数组）表示法
>
> 邻接表（链式）表示法

---



#### 1邻接矩阵（数组）表示法

##### 无向图

![image-20240426110915448](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426110915448.png) 

![image-20240426111107486](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426111107486.png) 

> **对角线元素都是0**：对角线代表每个顶点和自身的关系，没有到自身的边就是0
>
> **无向图的邻接矩阵是对称的**：因为是无向图，两个顶点之间有边，互为邻接关系
>
> **顶点i的度=第 i行 (列) 中1 的个数;**
>
> 邻接矩阵是唯一的
>
> 空间复杂度是O(n<sup>2</sup>)

完全图的邻接矩阵中，对角线元素为0，其余为1・



##### 有向图

![image-20240426115908902](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426115908902.png) 

> 从列来看就是谁入了
>
> 从行来看就是谁出了

> 如何得到某个顶点的度呢？
>
> 顶点i的度=第 i行中1 的个数`出度`  +   第列中1 的个数`入度`



##### 网

![image-20240426120409249](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240426120409249.png) 





#### 邻接矩阵的实现

> 用两个数组分别存储**顶点表**和**邻接矩阵**

```c
#define MVNum 100 // 最大顶点数
#define Maxint 32767//表示极大值，也就是∞
typedef char VerTexType; // 顶点的数据类型为字符型
typedef int ArcType; // 假设边的权值类型为整型

typedef struct {
    VerTexType vexs[MVNum];       // 顶点表
    ArcType arcs[MVNum][MVNum];    // 邻接矩阵
} AMGraph; // Adjacency Matrix Graph

```

##### 无向网和有向网的实现

算法的思路：

> 输入总顶点数和总边数
>
> 依次输入点的信息存入顶点表
>
> 初始化邻接矩阵，每个权值初始化为极大值
>
> 构造邻接矩阵

```C++
#include <iostream>
using namespace std;

#define MaxInt 999999 // 假设MaxInt代表权值的最大值
#define MVNum 100 // 最大顶点数

typedef char VerTexType; // 顶点数据类型
typedef int ArcType; // 边权值数据类型

typedef struct {
    VerTexType vexs[MVNum];       // 顶点数组
    ArcType arcs[MVNum][MVNum];    // 邻接矩阵
    int vexnum, arcnum; // 顶点数和边数
} AMGraph;

// 定义状态
enum Status { OK };

// 查找顶点位置
int LocateVex(AMGraph G, VerTexType v) {
    for(int i = 0; i < G.vexnum; ++i) {
        if(G.vexs[i] == v)
            return i; // 如果找到顶点，返回其下标
    }
    return -1; // 如果没找到，返回-1
}

// 创建无向网
Status CreateUDN(AMGraph &G) {
    cout << "输入总顶点数和总边数: ";
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和总边数
    
    cout << "输入每个顶点的信息:" << endl;
    for(int i = 0; i < G.vexnum; ++i)
        cin >> G.vexs[i]; // 依次输入每个顶点的信息
    
    // 初始化邻接矩阵
    for(int i = 0; i < G.vexnum; ++i)
        for(int j = 0; j < G.vexnum; ++j)
            G.arcs[i][j] = MaxInt; // 将边的权值初始化为一个很大的值
    
    VerTexType v1, v2;
    ArcType w;
    int i, j;

    cout << "输入每条边的信息（顶点1 顶点2 权值）:" << endl;
    for(int k = 0; k < G.arcnum; ++k) {
        cin >> v1 >> v2 >> w; // 输入每条边的信息
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        if(i != -1 && j != -1) { // 如果找到了两个顶点
            G.arcs[i][j] = w; // 设置边<v1, v2>的权值
            
            
            
             //switch是否是有向的还是无向的-----------------------------------------------------
            G.arcs[j][i] = G.arcs[i][j]; // 设置对称边<v2, v1>的权值
        }
        // 处理顶点没找到的情况
    }
    
    return OK; // 创建图成功，返回OK状态
}

int main() {
    AMGraph G;
    Status result = CreateUDN(G);
    if (result == OK) {
        cout << "无向网创建成功！" << endl;
        cout << "邻接矩阵表示为：" << endl;
        for (int i = 0; i < G.vexnum; ++i) {
            for (int j = 0; j < G.vexnum; ++j) {
                cout << G.arcs[i][j] << " ";
            }
            cout << endl;
        }
    } else {
        cout << "创建无向网失败！" << endl;
    }
    return 0;
}

```

![image-20240427131557432](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427131557432.png)  

##### 无向图和有向图的实现

> 无向图和无向网的区别是，邻接矩阵初始化的时候都为0，然后构造的时候有关系的放入1就欧克了。
>
> 有向图的区别是：不用去生成对称的关系，也就是只需要对`G.arcs[i][j]`复制不需要对`G.arcs[j][i]`赋值了 

```c
#include <iostream>
using namespace std;

#define MaxInt 999999 // 假设MaxInt代表权值的最大值
#define MVNum 100 // 最大顶点数

typedef char VerTexType; // 顶点数据类型
typedef bool ArcType; // 边存在与否的数据类型（无向图中可以用布尔值表示边的存在与否）

typedef struct {
    VerTexType vexs[MVNum];       // 顶点数组
    ArcType arcs[MVNum][MVNum];    // 邻接矩阵
    int vexnum, arcnum; // 顶点数和边数
} AMGraph;

// 定义状态
enum Status { OK };

// 查找顶点位置
int LocateVex(AMGraph G, VerTexType v) {
    for(int i = 0; i < G.vexnum; ++i) {
        if(G.vexs[i] == v)
            return i; // 如果找到顶点，返回其下标
    }
    return -1; // 如果没找到，返回-1
}

// 创建无向图
Status CreateUDG(AMGraph &G) {
    cout << "输入总顶点数和总边数: ";
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和总边数
    
    cout << "输入每个顶点的信息:" << endl;
    for(int i = 0; i < G.vexnum; ++i)
        cin >> G.vexs[i]; // 依次输入每个顶点的信息
    // 初始化邻接矩阵
    for(int i = 0; i < G.vexnum; ++i)
        for(int j = 0; j < G.vexnum; ++j)
            G.arcs[i][j] = false; // 将边的存在与否初始化为false
    
    VerTexType v1, v2;
    int i, j;

    cout << "输入每条边是哪两个顶点确定的（顶点1 顶点2）:" << endl;
    for(int k = 0; k < G.arcnum; ++k) {
        cin >> v1 >> v2; // 输入每条边的信息
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        if(i != -1 && j != -1) { // 如果找到了两个顶点
            G.arcs[i][j] = true; // 设置边<v1, v2>的存在
            
            //switch是否是有向的还是无向的-----------------------------------------------------
            G.arcs[j][i] = true; // 设置对称边<v2, v1>的存在（无向图）
        }
        // 处理顶点没找到的情况
    }
    
    return OK; // 创建图成功，返回OK状态
}

int main() {
    AMGraph G;
    Status result = CreateUDG(G);
    if (result == OK) {
        cout << "无向图创建成功！" << endl;
        cout << "邻接矩阵表示为：" << endl;
        for (int i = 0; i < G.vexnum; ++i) {
            for (int j = 0; j < G.vexnum; ++j) {
                cout << G.arcs[i][j] << " ";
            }
            cout << endl;
        }
    } else {
        cout << "创建无向图失败！" << endl;
    }
    return 0;
}

```

![image-20240427165010683](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427165010683.png)  



##### 邻接矩阵的优缺点

优点：

> 1. 直观：邻接矩阵**直观地表示了图中各个顶点之间的关系**，易于理解。
> 2. 快速查询：可以在常量时间内**查询两个顶点之间是否存在边，以及边的权值。**
> 3. 方便找到任一顶点的所有`邻接点`
> 4. 方便计算：方便计算任一顶点的度！

缺点：

> 1. 不方便增删顶点
> 2. 当存储稀疏图的时候会有浪费空间，但是对于稠密图还是比较适合的
> 3. 浪费时间：统计稠密图中一共有多少条边的时候





#### 2邻接表（链式）表示法

![image-20240427134940764](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427134940764.png) 

##### 无向图

![image-20240427135328990](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427135328990.png) 

> 若干个单链表构成的多重链表结构

> 空间复杂度是**O(n+2e)**
>
> 某个顶点的**度**是？第i个结点中单链表中的结点数





##### 有向图

和无向图的区别是不用记录两对了

> 只记录出度边！

> 存储空间;n+e
>
> 找出度方便，入度难找
>
> 出度如何计算：第i个结点中单链表中的结点数
>
> 入度如何计算：顶点Vi的入度为整个单链表中**邻接点域值**是`i-1`的结点个数

或者单独建立一个存入度的邻接表

![image-20240427154700397](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427154700397.png) 









##### 邻接表转化为图

> 当邻接表的存储结构形成后，图便唯一确定！

![image-20240427155226081](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427155226081.png) 







#### 邻接表的实现

```c
typedef struct ArcNode {
    int adjvex;             // 邻接顶点下标
    ArcType weight;         // 边权值
    struct ArcNode *next;   // 指向下一条边的指针
} ArcNode;
//图的边结点结构

typedef struct VNode {
    VerTexType data;        // 顶点信息
    ArcNode *firstarc;      // 指向第一条依附该顶点的边的指针
} VNode，AdjList[MVNum];
//

typedef struct {
    AdjList vertices;   // vertices表示顶点的复数形式
    int vexnum, arcnum; // 图的当前顶点数和弧数
} ALGraph;


```

 ![image-20240427160241333](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427160241333.png) 



##### 有向图和无向图的实现

算法思路

> [算法思想]----无向网，其实就是有没有带weight，然后有没有实现对称位置的关系
>
> 1. 输入**总顶点数**和**总边数**
>
> 2. 建立**顶点表**
>
>    **依次输入点的信息存入顶点表中**
>
>    使每个**表头结点**的**指针域初始化为NULL**
>
> 3. **创建邻接表**
>
>    依次输入每条边依附的两个顶点
>
>    确定两个顶点的序号`i`和`j`，建立边结点
>
>    将此边结点分别插入到`vi`和`vj`;对应的两个边链表的头部

```c++
#include <iostream>
using namespace std;

typedef char VerTexType; // 顶点数据类型
typedef bool ArcType; // 边存在与否的数据类型（无向图中可以用布尔值表示边的存在与否）
#define MVNum 100
typedef struct ArcNode {
    int adjvex;             // 邻接顶点下标
    ArcType weight;         // 边权值
    struct ArcNode *next;   // 指向下一条边的指针
} ArcNode;

typedef struct VNode {
    VerTexType data;        // 顶点信息
    ArcNode *firstarc;      // 指向第一条依附该顶点的边的指针
} VNode, AdjList[MVNum];

typedef struct {
    AdjList vertices;   // vertices表示顶点的复数形式
    int vexnum, arcnum; // 图的当前顶点数和弧数
} ALGraph;

enum Status { OK };

int LocateVex(ALGraph G, VerTexType v) {
    for(int i = 0; i < G.vexnum; ++i) {
        if(G.vertices[i].data == v)
            return i; // 如果找到顶点，返回其下标
    }
    return -1; // 如果没找到，返回-1
}
Status CreateUDG(ALGraph &G) {
    cout << "输入总顶点数和总边数: ";
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和总边数
    
    // 输入各点，构造表头结点表
    for (int i = 0; i < G.vexnum; ++i) {
        cout << "输入顶点" << i << "的值: ";
        cin >> G.vertices[i].data; // 输入顶点值
        G.vertices[i].firstarc = NULL; // 初始化表头结点的指针域
    }


    VerTexType v1, v2;
    int i, j;

    // 输入各边，构造邻接表
    for (int k = 0; k < G.arcnum; ++k) {
        cout << "输入一条边依附的两个顶点: ";
        cin >> v1 >> v2; // 输入一条边依附的两个顶点
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        
        // 生成一个新的边结点*p1，将其插入顶点vi的边表头部
        ArcNode *p1 = new ArcNode;
        p1->adjvex = j; // 邻接点序号为j
        p1->next = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;

//-=--------------------------------------------------------------------------------------
        //switch对应有向，无向
        // 生成另一个对称的新的边结点*p2，将其插入顶点vj的边表头部
        ArcNode *p2 = new ArcNode;
        p2->adjvex = i; // 邻接点序号为i
        p2->next = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }

    return OK;
}

int main() {
    ALGraph G;
    Status result = CreateUDG(G);
    if (result == OK) {
        cout << "无向图创建成功！" << endl;
        cout << "邻接表表示为：" << endl;
        for (int i = 0; i < G.vexnum; ++i) {
            cout << "顶点 " << G.vertices[i].data << ": ";
            ArcNode *p = G.vertices[i].firstarc;
            while (p) {
                cout << G.vertices[p->adjvex].data << " ";
                p = p->next;
            }
            cout << endl;
        }
    } else {
        cout << "创建无向图失败！" << endl;
    }
    return 0;
}


```

![image-20240427162341648](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427162341648.png) 



> 如果去掉

##### 有向网和无向网的实现

```c
#include <iostream>
using namespace std;

typedef char VerTexType; // 顶点数据类型
typedef int ArcType;     // 边权值数据类型

#define MVNum 100

typedef struct ArcNode {
    int adjvex;             // 邻接顶点下标
    ArcType weight;         // 边权值
    struct ArcNode *next;   // 指向下一条边的指针
} ArcNode;

typedef struct VNode {
    VerTexType data;        // 顶点信息
    ArcNode *firstarc;      // 指向第一条依附该顶点的边的指针
} VNode, AdjList[MVNum];

typedef struct {
    AdjList vertices;   // vertices表示顶点的复数形式
    int vexnum, arcnum; // 图的当前顶点数和弧数
} ALGraph;

enum Status { OK };

int LocateVex(ALGraph G, VerTexType v) {
    for(int i = 0; i < G.vexnum; ++i) {
        if(G.vertices[i].data == v)
            return i; // 如果找到顶点，返回其下标
    }
    return -1; // 如果没找到，返回-1
}

Status CreateUDN(ALGraph &G) {
    cout << "输入总顶点数和总边数: ";
    cin >> G.vexnum >> G.arcnum; // 输入总顶点数和总边数
    
    // 输入各点，构造表头结点表
    for (int i = 0; i < G.vexnum; ++i) {
        cout << "输入顶点" << i << "的值: ";
        cin >> G.vertices[i].data; // 输入顶点值
        G.vertices[i].firstarc = NULL; // 初始化表头结点的指针域
    }

    VerTexType v1, v2;
    ArcType w;
    int i, j;

    // 输入各边，构造邻接表
    for (int k = 0; k < G.arcnum; ++k) {
        cout << "输入一条边依附的两个顶点及权值: ";
        cin >> v1 >> v2 >> w; // 输入一条边依附的两个顶点及权值
        i = LocateVex(G, v1);
        j = LocateVex(G, v2);
        
        // 生成一个新的边结点*p1，将其插入顶点vi的边表头部
        ArcNode *p1 = new ArcNode;
        p1->adjvex = j; // 邻接点序号为j
        p1->weight = w; // 边权值为w
        p1->next = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;
//-=--------------------------------------------------------------------------------------
        //switch对应有向，无向
        // // 生成另一个对称的新的边结点*p2，将其插入顶点vj的边表头部
        // ArcNode *p2 = new ArcNode;
        // p2->adjvex = i; // 邻接点序号为i
        // p2->weight = w; // 边权值为w
        // p2->next = G.vertices[j].firstarc;
        // G.vertices[j].firstarc = p2;
    }

    return OK;
}

int main() {
    ALGraph G;
    Status result = CreateUDN(G);
    if (result == OK) {
        cout << "有向网创建成功！" << endl;
        cout << "邻接表表示为：" << endl;
        for (int i = 0; i < G.vexnum; ++i) {
            cout << "顶点" << G.vertices[i].data << ": ";
            ArcNode *p = G.vertices[i].firstarc;
            while (p) {
                cout << "(" << G.vertices[i].data << ", " << G.vertices[p->adjvex].data << ", " << p->weight << ") ";
                p = p->next;
            }
            cout << endl;
        }
    } else {
        cout << "创建有向网失败！" << endl;
    }
    return 0;
}

```

![image-20240427163902737](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427163902737.png)









##### 邻接表的优缺点

> 方便找任一顶点的所有`‘邻接点'`
>
> **节约稀疏图的空间**・解决了邻接矩阵的缺点
>
> 需要N个头指针+2E个结点 (每个结点至少2个域)
>
> 方便计算任一顶点的“度”？
>
> + 对无向图：是的
>
> + 对有向图：只能计算算"出度"；需要构造逆邻接表(存指向自己的边）来方便计算入度
>
> 不方便检查任意一对顶点间是否存在边

##### 邻接表 VS邻接矩阵

![image-20240427165945481](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240427165945481.png) 

> 对于任一确定的无向图，邻接矩阵是唯一的，但是邻接表不唯一，由插入的算法决定的(头插？尾插？)；
>
> **邻接矩阵**的空间复杂度为O(n<sup>2</sup>),而**・邻接表・**的空间复杂度为O(n+e)。
>
> 对于稀疏矩阵用邻接表！
>
> **用途：`邻接矩阵`多用于`稠密图`；而`邻接表`多用于`稀疏图`**;





#### 3十字链表表示法

 为什么要用十字链表？

> 因为邻接表：
>
> + 有向图：缺点：求结点的度难->`十字链表`
> + 无向图：每条边都要存储两遍->`邻接多重表`

**十字链表**（OrthogonalList)是**有向图**的另一种链式存储结构我们也可以把它看成是将有向图的`邻接表和逆邻接表结合起来形成的种链表。`

有向图中的**每一条弧**对应**十字链表中的一个弧结点**，同时**有向图**中的每个顶点在十字链表中对应有一个结点，叫做**顶点结点**

[十字链表](https://xu-runbo.gitee.io/xu-runbo/post/1befd574.html?highlight=%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8)

表头结点升级，添加了入度的边firstin

 ![image-20240428132134681](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240428132134681.png) 

**<x , y> x -> y  y是弧头 x是弧尾**

![image-20240428133405701](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240428133405701.png) 

---

![image-20240428134034001](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240428134034001.png) 



 



#### 邻接多重表

无向图：每条边都要存储两遍->`邻接多重表`

![image-20240428154414294](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240428154414294.png) 

> 简单来说就是在**邻接表**的基础上边结点**增加了弧的首尾标志**，这样就**不用存两遍**了，只用指针指向对应的边就行

![image-20240509124749392](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509124749392.png) 

> 减少了结点的数，不需要重复的记录了.
>
> 空间换时间

表头结点：

![image-20240509124905410](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509124905410.png) 

边结点:

![image-20240509125012580](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509125012580.png) 

如果是网：那就边界点再加一个存储权值的位置



## 图的遍历

### 概念

> 从已给的连通图中**某一顶点出发**，沿着一些边**访遍图中所有的顶点**，且使**每个顶点仅被访问一次**，就叫做**图的遍历**，它是图的**基本运算**。

![image-20240509125354881](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509125354881.png)

#### 遍历实质： 

> 找每个顶点的邻接点的过程

#### 图的特点:

> 图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点

#### 如何避免重复访问？

> 解决思路：设置**辅助数组 visited[n］，用来标记每个被访问过的顶点。**
>
> 初始状态visited [i]为0
>
> 顶点i被访问，改 visited [j为1
>
> 防止被多次访问

### 图常用的遍历

> 深度优先搜索DFS(Depth First Search)
>
> 广度优先搜索BFS(Breadth First Search) 

#### 深度优先搜索DFS(Depth First Search)

##### 深度优先搜索的例子

一杆到底

![image-20240509130100327](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509130100327.png) 

方法：

> 在访问图中某一起始顶点 v后，由v出发，访问它的**任一**邻接顶点 W1;
>
> 再从 W1 出发，访问与 W1邻接但还未被访问过的顶点 W2;
>
> 然后再从 W2 出发，进行类似的访问，
>
> 如此进行下去，直至到达**所有的邻接顶点都被访问过的顶点u**为止
>
> 接着，退回一步，**退到前一次刚访问过的顶点**，看是否还有其它没有被访问的邻接顶点。
>
> 如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问;
>
> 如果没有，就再**退回一步进行搜索**。重复上述过程，直到连通图中所有顶点都被访问过为止。

所以：图的深度优先搜索的次序是不唯一的，但是如果存储结构确定了那么访问结果也就确定了。

连通图的遍历：

![image-20240509130640064](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509130640064.png) 

非连通图的遍历：

[连通](#连通)

![image-20240510153221973](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240510153221973.png) 

连通分量访问完后再任选一个开始访问

##### 深度优先搜索遍历算法的实现

**邻接矩阵**表示的无向图深度遍历实现：

> 不断的从起点去访问。

![image-20240509131226823](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240509131226823.png) 

DFS结果：2-->1-->3-->5-->4-->6

建议说一遍：

> 如果存储结构确定后，那么访问结果也就确定了

---

```c++
void DFS(AMGraph &G, int v, bool visited[]) {//图G为邻接矩阵类型
    cout << v;
    visited[v] = true; // 访问第v个顶点
    for (int w = 0; w < G.vexnum; w++) { // 依次检查邻接矩阵v所在的行
        if ((G.arcs[v][w] != 0) && (!visited[w])) {
            DFS(G, w, visited); // w是v的邻接点，如果w未访问，则递归调用DFS
        }
    }
}

```

##### DFS算法效率分析

用`邻接矩阵`来表示图，遍历图中**每一个顶点都要从头扫描该顶点该顶点所在行**，时间复杂度为O(n?)。

用`邻接表`来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问n个头结点的时间，时间复杂度为O(n+e)。

结论:

`稠密图`适于在`邻接矩阵`上进行深度遍历；

`稀疏图`适于在`邻接表`上进行深度遍历

---





#### 广度优先搜索BFS(Breadth First Search) 

##### 广度优先搜索例子

![image-20240510153455052](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240510153455052.png) 

方法：

> 从图的某一结点出发，首先依次访问该结点的所有邻点V1，V2，.，Vi,
>
> 再按这些顶点被访问的先后次序依次**访问与它们相邻接的所有未被访问的顶点**重复此过程，直至所有顶点均被访问为止，

所有的结点一层一层的扩大

连通图：

![image-20240510153735559](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240510153735559.png) 

非连通图呢：

![image-20240510154122452](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240510154122452.png) 

##### 广度优先遍历的实现

邻接表为例：

![image-20240510154911452](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240510154911452.png)

![PixPin05-10_15-58-05](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/PixPin05-10_15-58-05.gif) 

```c
void BFS(Graph &G, int v) { // 按广度优先非递归遍历连通图G
    cout << v; 
    visited[v] = true; // 访问第v个顶点
    InitQueue(Q); // 辅助队列Q初始化，置空
    EnQueue(Q, v); // v进队
    while (!QueueEmpty(Q)) { // 队列非空
        DeQueue(Q, u); // 队头元素出队并置为u
        for (int w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w)) {
            if (!visited[w]) { // w为u的尚未访问的邻接顶点
                cout << w;
                visited[w] = true;
                EnQueue(Q, w); // w进队
            }
        }
    }
}

```

> 被访问后就出队
>
> 然后他的临界点入队.
>
> 之后是该顶点的邻接顶点的邻接定点

##### BFS算法效率分析

如果使用`邻接矩阵`，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行 （n个元素），总的**时间代价为O(n?)。**

用`邻接表`来表示图，虽然有2e个表结点，但只需扫描é个结点即可完成遍历，加上访问 n个头结点的时间，**时间复杂度为O(n+e)**





#### DFS和BFS算法效率比较

空间复杂度相同，都是O(n)(借用了堆栈或队列)

时间复杂度只与存储结构(邻接矩阵或邻接表)有关，而与搜索路径无关。







## 图的应用

### 最小生成树

#### 什么是生成树？

生成树：所有顶点均由边连接在一起，但不存在回路的图。

![image-20240513082851615](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513082851615.png) 

一个图可以有不同的生成树

> 1. 生成树顶点个数与图的顶点个数一致
> 2. 生成树是图的极小连通子图，去掉一条边就不连通了
> 3. 一个n个顶点的连通图的生成树有n-1条边
> 4. 在生成树中再加一条边必然形成回路
> 5. 生成树中任意两个顶点之间的路径是唯一的

含有n个顶点n-1条边的图不一定是生成树



#### 如何得到生成树

利用图的遍历得到生成树

不同的遍历方法得到不同的生成树

无向图的**生成树**：：

![image-20240513083153922](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513083153922.png) 



#### 什么是最小生成树

最小生成树：给定一个无向网络，在该网的所有生成树中，使得**各边权值之和最小**的那棵生成树称为该网的最小生成树，也叫**最小代价生成树**

---

在n个城市间建立通信网，需要的线路[n-1,1(n-1)2]

数学模型: 

> 顶点：城市
>
> 边：线路
>
> 边的权值：线路的经济代价
>
> 通信网：n各城市间的通信网



#### 构造最小生成树

MST的性质：

MST 性质：设 N =（V, E）是一个连通网，U 是顶点集V 的一个非空子集。若边(u,v) 是一条具有最小权值的边，其中u∈U，v∈V-U，则必存在一棵包含边 (u,v)的最小生成树。

![image-20240513084359643](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513084359643.png) 

> 在生成树的构造过程中，图中n个顶点分属两个集合：
>
> 已落在生成树的顶点集：
>
> 尚未落在生成树上的顶点集：
>
> 接下来则应在所有连通U中顶点和V-U中顶点的边中选**取权值最小的边**

![image-20240513085032957](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513085032957.png) 

### 构造最小生成树

#### 普里姆Prim算法

选择点

`选取权值最小的边，然后再从与当前顶点关联的边中选择最小的权值。。。`

![image-20240513085109702](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513085109702.png)  

> 不能形成环

#### 克鲁斯卡尔(Kruskal)算法

选择边

贪心算法：

`包含所有顶点的无边的图->不断加权值最小的边`

直接不断的，找权值最小的。

> 设连通网N=（V,E）令最小生成树初始状态为只有n 个顶点而无边的非连通图T=（V，{})，每个顶点自成一个连通分量
>
> 在E中选取代价最小的边，若该边依附的顶点落在T中不同的连通分量上即(不能形成环)
>
> 则将此边加入到 T中；否则舍去此边，选取条代价最小的边
>
> 依此类推，直至T中所有顶点都在同一连通分量上为止

最小生成树可以不唯一

![image-20240513085703133](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513085703133.png) 

#### 两种算法的比较

![image-20240513085930253](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513085930253.png) 

遍历每个顶点关联的边，n<sup>2</sup>

### 最短路径

交通网络的问题：

> 交通网络用有向网来表示：
>
> 顶点表示地点，
>
> 弧表示两个地点有路连通
>
> 弧上的权值-----表示两地点之间的距离、交通费或途中所花费的时间等

问题抽象：在有向网中 A 点(源点)到达 B 点(终点)的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。

与最小生成树的区别是：不一定包含n个顶点，也不i一定包含n-1条边

![image-20240513090700168](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513090700168.png) 

![image-20240513090721888](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513090721888.png)  

单源最短路径一用Djkstra（迪杰斯特拉）算法

所有顶点间的最短路径一用Floyd（弗洛伊德）算法

或者每次以一个顶点为源点，重复执行 Dijkstra 算法 n 次。





#### Djkstra（迪杰斯特拉）算法

![image-20240513100158709](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513100158709.png) 

![image-20240513101450668](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513101450668.png) 





#### Floyd（弗洛伊德）算法

> 算法思想:
>
> + 逐个顶点试探
> + 从vi到vj的所有可能存在的路径中
> + 选出一条长度最短的路径

初始时设置一个 n阶方阵令其对角线元素为0，若若存在弧<Vi,Vj>，贝则对应元素为权值；否则为

![image-20240513102507256](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513102507256.png) 







### 拓扑排序

有向无环图：无环的有向图，DAG图

![image-20240513102632078](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513102632078.png) 

?		有向无环图常用来描述一个工程或系统的进行过程(通常把计划、施工、生产、程序流程等当成是一个工程)

?		一个工程可以分为若干个子工程，只要完成了这些子工程（活动）就可以导致整个工程的完成。

#### AOV网：

用一个有向图表示一个工程的各子工程及其相互制约的关系，其中以**顶点表示活动**，**弧表示活动之间的优先制约关系**，称这种有向图为`・顶点表示活动的网・`，简称 AOV网(Activity On Vertex network)。



#### AOE网

用一个有向图表示一个工程的各子工程及其相互制约的关系，以**弧表示活动**，以**顶点表示活动的开始或结束事件**，称这种有向图为`・边表示活动的网・`，简称为AOE网(Activity On Edge)

#### 课程排序问题

![image-20240513103203341](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513103203341.png) 

> 若从i到j有一条有向路径，则i是j的前驱;j是i的后继
>
> 若<i,j>是网中有向边，则i是j的直接前驱；j是i的直接后继
>
> AOV网中**不允许有回路**，因为如果有回路存在，则表明某项活动以自己为先决条件，显然这是荒谬的。 

#### 什么是拓扑排序

在 AOV网没有回路的前提下，我们将全部活动排列成一个线性序列，使得若 AOV 网中有弧<i，j>存在，则在这个序列中，i一定排在 j的前面，具有这种性质的线性序列称为拓扑有序序列，相应的拓扑有序排序的算法称为拓扑排序。

#### 拓扑排序的方法

在有向图中选一个没有前驱的顶点且输出之

从图中删除该顶点和所有以它为尾的弧

重复上述两步，直至全部顶点均已输出;

或者当图中不存在无前驱的顶点为止

![image-20240513104836000](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513104836000.png)

#### 检测 AOV 网中是否存在环方法

对有向图构造其顶点的拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则该 AOV 网必定不存在环。

### 关键路径

把工程计划表示为**边表示活动的网络**，即AOE网，用**顶点表示事件**，**弧表示活动弧的权表示活动持续时间**

> 准备一个小型家庭宴会，晚6点宴会开始，最迟几点开始准备？压缩哪项活动时间可以使总时间减少？

![image-20240513133844093](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513133844093.png) 

---

#### 源点和汇点

![image-20240513135702213](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513135702213.png) 



#### 关键路径

> 对于AOE网，我们关心两个问题
>
> 完成整项工程至少需要多少时间?
>
> 哪些活动是影响工程进度的关键

什么是关键路径:

关键路径一一路径长度最长的路径,从源点到汇点

路径长度一一路径上各活动持续时间之和



#### 确定关键路径

![image-20240513140409586](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513140409586.png) 

**关键活动**――关键路径上的活动，即`I(i)== e(i)`（即` I(i)－e(i)==O`）的活动。

`I(i) -e(i)`表示完成活动ai的**时间余量**例：I(3) -e(3) = 90

#### 如何找关键活动

==如何找 I(i) == e(i) 的关键活动?==

设`活动 ai` 用弧`<j, k>`表示，其持续时间记为：W<sub>j,k</sub>

则有：

---

`(1)e(i) = ve(j) `	

(2)I(i) = vl(k) - W<sub>j,k</sub>

![image-20240513140945349](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513140945349.png) 

---

==如何求 ve(j)和 vl(j) ?==

(1)从 ve(1） = 0 开始向前递推

`ve(j) = Max{ve(i) + Wi,j</sub>}, < i, j >∈ T, 2 ≤ j ≤ n`

其中 T 是所有以 j为头的弧的集合。

(2)从 vl(n) = ve(n) 开始向后递推

`vl(i) = Min(vl(j) - Wi,j} , < i, j >∈ S, 1 ≤ i ≤ n - 1`

其中 S 是所有以 i为尾的弧的集合

---

> 不是并列,是要所有条件完成,才能执行,所以最大是最早
>
> 明白了，最早也要等时间最长的完成才能开始下一步
>
> 交作业截止时间 ― 写作业所需时间 = 最晚开始抄作业时间  =  临时抱佛脚

#### 求关键路径的步骤

1. 求 ve(i)、vl(j)
2.  求e(i)、I(i)
3.  计算l(i) - e(i)

`ve(j) = Max{ve(i) + Wi,j</sub>}, < i, j >∈ T, 2 ≤ j ≤ n`

`vl(i) = Min(vl(j) - Wi,j} , < i, j >∈ S, 1 ≤ i ≤ n - 1`

`(1)e(i) = ve(j) `	

(2)I(i) = vl(k) - W<sub>j,k</sub>



---

> **关键活动**――关键路径上的活动，即`I(i)== e(i)`（即` I(i)－e(i)==O`）的活动。

![image-20240513145138711](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513145138711.png) 

#### 关键路径的讨论

 ![image-20240513145349297](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC6%E5%91%A8/image-20240513145349297.png) 

1.若网中有几条关键路径则需加快同时在几条关键路径上的关键活动

2、如果一个活动处于所有的关键路径上，那么提高这个活动的速度，就能缩短整个工程的完成时间。如：a1、a4。

3、处于所有的关键路径上的活动完成时间不能缩短太多否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。如：a1由6天变成3天，京就会改变关键路径

