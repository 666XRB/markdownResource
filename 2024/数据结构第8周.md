# 排序

## 回顾

![image-20240612192317807](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612192317807.png) 

## 排序

### 什么是排序

排序：将一组杂乱无章的数据**按一定规律顺次排列起来**。

即，将无序序列排成一个有序序列一(由小到大或由大到小）的运算。

如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。

---

应用非常广泛

+ 软件中直接使用
+ 间接使用：查找。。。最小生成树。。。

---

### 排序的分类

![image-20240612192717329](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612192717329.png)

#### 按存储介质分

+ 内部排序数据量不大、数据在内存无需内外存交换数据

+ 外部排序：数据童较数据在外存(文件排序)

---

#### 按照比较器个数分类

+ 串行排序：单处理机（同一时刻比较一对元素）
+ 并行排序：口多处理机（同一时刻比较多对元素

---

#### 按照主要操作分

+ 比较排序：用比较的方法插入排序,交换排序、选择排序、归并排序
+ 基数排序：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。

---

#### 按照辅助空间分

+ 原地排序：辅助空间用量为0（1）的排序方法（所占的辅助存储空间与参加排序的数据量大小无关）
+ 非原地排序：辅助空间用量超过0（1）的排序方法

---

#### 按照稳定性排序

+ 稳定排序：能够使任何数值相等的元素，排序以后相对次序不变
+ 非稳定性排序：不是稳定排序的方法。

![image-20240612193313105](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612193313105.png)

> 排序的稳定性只对结构类型数据排序有意义

![image-20240612193508950](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612193508950.png)



#### 按照自然性分

自然排序：输入数据越有序排序的速度越快的排序方法。

非自然排序：不是自然排序的方法



----

#### 学习内容

按数据存储介质：内部排序和外部排序

按比较器个数：串行排序和并行排序

按主要操作:比较排序和基数排序

---

`按排序依据原则`

> 插入排序：直接插入排序、折半插入排序、希尔排序
>
> 交换排序：冒泡排序、快速排序
>
> 选择排序：简单选择排序、堆排序
>
> 归并排序：2-路归并排序
>
> 基数排序

`按排序所需工作量`

简单的排序方法：T(n)=O(n^2)

基数排序:T(n)=O(d.n)

先进的排序方法：T(n)=O(nlogn)



### 顺表为例

```c
#define MAXSIZE 20 // 设记录不超过20个

typedef int KeyType; // 设关键字为整型量(int型)

typedef struct { // 定义每个记录(数据元素)的结构
    KeyType key; // 关键字
    InfoType otherinfo; // 其它数据项
} RedType; // 记录类型

typedef struct { // 定义顺序表的结构
    RedType r[MAXSIZE + 1]; // 存储顺序表的数组，r[0]一般作哨兵或缓冲区
    int length; // 顺序表的长度
} SqList; // 顺序表类型

```



## 插入排序

### 基本思想

![image-20240612194236907](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612194236907.png) 

> 每步将一个**待排序的对象**，按其**关键码大小**，插入到**前面已经排好序的一组对象的适当位置上**，直到对象全部插入为止。

==即边插入边排序，保证子序列中随时都是排好序的==

### 基本操作

有序插入

> 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。
>
> 起初，a[0]是长度为的子序列。然后逐一将a[1]至a[n-1]插入到有序子序列中。

插入位置

![image-20240612194422285](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612194422285.png) 

### 插入排序分类

![image-20240612195120431](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612195120431.png) 

#### 直接插入排序

##### 算法思想

> 插入排序是一种简单直观的排序算法，像整理一手扑克牌一样。

1. **从第二张牌开始**：
    - 假设第一张牌已经在正确的位置上。
    - 从第二张牌开始，每次取一张新的牌，将它插入到已经排好序的牌中。
2. **寻找插入位置**：
    - 拿到新牌后，从已经排好序的牌的最右边开始，向左逐张比较。
    - 如果新牌比当前比较的牌小，就将当前的牌右移一位，为新牌腾出位置。
3. **插入新牌**：
    - 找到合适的位置后，把新牌插入到这个位置。
4. **重复上述过程**：
    - 重复上述过程，直到所有牌都插入到正确的位置为止。

---

举个例子

假设有一个待排序的数组：[5, 3, 8, 6, 2]

1. **初始状态**：
    - 第一张牌5已经在正确位置上。

2. **处理第二张牌3**：
    - 比较3和5，发现3比5小，把5向右移动一位。
    - 将3插入到第一位。
    - 结果：[3, 5, 8, 6, 2]

3. **处理第三张牌8**：
    - 比较8和5，发现8比5大，直接放在后面。
    - 结果：[3, 5, 8, 6, 2]

4. **处理第四张牌6**：
    - 比较6和8，发现6比8小，把8向右移动一位。
    - 再比较6和5，发现6比5大，插入到8前面。
    - 结果：[3, 5, 6, 8, 2]

5. **处理第五张牌2**：
    - 比较2和8，发现2比8小，把8向右移动一位。
    - 再比较2和6，发现2比6小，把6向右移动一位。
    - 再比较2和5，发现2比5小，把5向右移动一位。
    - 再比较2和3，发现2比3小，把3向右移动一位。
    - 将2插入到第一位。
    - 结果：[2, 3, 5, 6, 8]

经过以上步骤，数组就变成了有序的。

---

总结

插入排序的关键在于：
- 将**未排序的元素逐个插入**到**已排序的部分**中。
- 通过**向右移动已排序的元素，为新元素找到合适的位置**。

插入排序适合于**数据量较小或者部分有序的数组**，因为它在这些情况下效率较高。

##### 算法分析

> 直接插入排序是一种简单的排序算法，其基本思想是**每一步将一个待排序的记录插入到前面已经排好序的子序列中**，直到所有记录插入完毕

![image-20240612195019830](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612195019830.png) 

![image-20240612194956926](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612194956926.png) 

![image-20240612195048615](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612195048615.png)

```c
#include <stdio.h>

#define MAXSIZE 20 // 设记录不超过20个

typedef int KeyType; // 设关键字为整型量(int型)

typedef struct { // 定义每个记录(数据元素)的结构
    KeyType key; // 关键字
    // 如果有其它数据项，定义在这里
} RedType; // 记录类型

typedef struct { // 定义顺序表的结构
    RedType r[MAXSIZE + 1]; // 存储顺序表的数组，r[0]一般作哨兵或缓冲区
    int length; // 顺序表的长度
} SqList; // 顺序表类型



void PrintList(SqList L) {
    for (int i = 1; i <= L.length; i++) {
        printf("%d ", L.r[i].key);
    }
    printf("\n");
}

int main() {
    SqList L = {
        .r = {{0}, {5}, {3}, {8}, {6}, {2}, {7}, {4}, {1}, {0}},
        .length = 9
    };

    printf("排序前:\n");
    PrintList(L);

    InsertSort(&L);

    printf("排序后:\n");
    PrintList(L);

    return 0;
}

```

```c
// 直接插入排序算法
void InsertSort(SqList *L) {
    int i, j;
    for (i = 2; i <= L->length; i++) { // 从第二个元素开始插入
        if (L->r[i].key < L->r[i - 1].key) { // 需要插入的元素比前一个元素小
            L->r[0] = L->r[i]; // 设置哨兵
            for (j = i - 1; L->r[0].key < L->r[j].key; j--) { // 查找插入位置
                L->r[j + 1] = L->r[j]; // 元素后移
            }
            L->r[j + 1] = L->r[0]; // 插入到正确位置
        }
    }
}
```

![image-20240612201916837](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612201916837.png) 

---

##### 改进为哨兵

![image-20240612195840219](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612195840219.png) 

```c
// 直接插入排序算法
void InsertSort(SqList *L) {
    int i, j;
    for (i = 2; i <= L->length; i++) { // 从第二个元素开始插入
        if (L->r[i].key < L->r[i - 1].key) { // 需要插入的元素比前一个元素小
            L->r[0] = L->r[i]; // 设置哨兵
            for (j = i - 1; L->r[0].key < L->r[j].key; j--) { // 查找插入位置
                L->r[j + 1] = L->r[j]; // 元素后移
            }
            L->r[j + 1] = L->r[0]; // 插入到正确位置
        }
    }
}
```





##### 性能分析

实现排序的基本操作有两个：

(1)"比较"序列中两个关键字的大小;

(2)"移动"记录。

 最好的情况（关键字在记录序列中顺序有序）

![image-20240612201423561](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612201423561.png) 

![image-20240612201551967](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612201551967.png) 

![image-20240612201557410](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612201557410.png) 

##### 总结

![image-20240612201625732](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240612201625732.png) 





#### 折半插入排序

> 区别就是
>
> 前面这一段既然已经排好序了
>
> 所以可以折半查找插入的位置！
>
> 每次可以排除一半的范围

![image-20240613210030231](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613210030231.png) 



##### 算法思想

> 折半插入排序（是一种改进的插入排序算法。
>
> 它通过**使用二分查找来确定插入位置，减少了比较次数**。

---

1. **假设前面的元素是有序的**：
    - 假设数组的前部分（从第一个元素开始）已经是有序的。

2. **从第二个元素开始**：
    - 从第二个元素开始，每次取一个新元素，准备将其插入到前面的有序部分。

3. **使用二分查找确定插入位置**：
    - 对于每个新元素，使用二分查找（即折半查找）在前面的有序部分找到适当的插入位置。
    - 二分查找通过不断将查找范围折半，快速确定新元素应插入的位置。

4. **将元素插入到适当位置**：
    - 找到插入位置后，将比新元素大的所有元素向右移动一个位置，为新元素腾出位置。
    - 将新元素插入到正确的位置上。

5. **重复上述过程**：
    - 重复上述过程，直到所有元素都插入到正确的位置，数组变得有序。

---

例子

假设有一个待排序的数组：[5, 3, 8, 6, 2]

1. **初始状态**：
    - 第一个元素5已经在正确位置上。

2. **处理第二个元素3**：
    - 使用二分查找确定3应该插入的位置。
    - 由于前面只有一个元素，3比5小，所以3应插入到第一个位置。
    - 将5向右移动一位，插入3。
    - 结果：[3, 5, 8, 6, 2]

3. **处理第三个元素8**：
    - 使用二分查找确定8应该插入的位置。
    - 8比5大，所以8插入到5后面。
    - 结果：[3, 5, 8, 6, 2]

4. **处理第四个元素6**：
    - 使用二分查找确定6应该插入的位置。
    - 6比5大但比8小，所以6插入到5和8之间。
    - 将8向右移动一位，插入6。
    - 结果：[3, 5, 6, 8, 2]

5. **处理第五个元素2**：
    - 使用二分查找确定2应该插入的位置。
    - 2比3小，所以2插入到最前面。
    - 将3、5、6、8向右移动一位，插入2。
    - 结果：[2, 3, 5, 6, 8]

经过以上步骤，数组就变成了有序的。

---

总结

折半插入排序的关键在于：
- 对于每个新元素，使用二分查找确定插入位置，从而减少比较次数。
- 通过向右移动元素，为新元素找到合适的位置。

折半插入排序比普通插入排序效率更高，因为它减少了比较的次数，但移动元素的次数并没有减少。对于数据量较小或部分有序的数组，折半插入排序仍然是一种有效的排序算法。

##### 算法分析

```cpp
#include <stdio.h>
#include <iostream>
// 定义顺序表的最大长度
#define MAXSIZE 100

// 定义元素类型
typedef struct {
    int key;
} ElemType;

// 定义顺序表类型
typedef struct {
    ElemType r[MAXSIZE + 1]; // 多一个哨兵位置
    int length;
} SqList;

// 折半插入排序算法
void BInsertSort(SqList &L) {
    int i, j, low, high, mid;
    ElemType temp;

    for (i = 2; i <= L.length; ++i) {
        L.r[0] = L.r[i]; // 当前插入元素存到“哨兵”位置
        low = 1;
        high = i - 1;

        // 采用二分查找法查找插入位置
        while (low <= high) {
            mid = (low + high) / 2;
            if (L.r[0].key < L.r[mid].key) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        // 循环结束，high+1则为插入位置
        for (j = i - 1; j >= high + 1; --j) {
            L.r[j + 1] = L.r[j]; // 移动元素
        }

        L.r[high + 1] = L.r[0]; // 插入到正确位置
    }
}

// 打印顺序表函数
void printList(SqList L) {
    for (int i = 1; i <= L.length; i++) {
        printf("%d ", L.r[i].key);
    }
    printf("\n");
}

// 主函数：测试代码
int main() {
    // 定义并初始化顺序表
    SqList L = {{{0}, {3}, {1}, {5}, {7}, {2}, {4}, {9}, {6}}, 8};
    
    printf("排序前数组: \n");
    printList(L);

    // 调用折半插入排序算法
    BInsertSort(L);

    printf("排序后数组: \n");
    printList(L);

    return 0;
}

```

![image-20240613210449119](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613210449119.png)

> 折半查找比顺序查找快所以折半插入排序就平均性能来说比直按拍入排序要快;
>
> 它所需要的关键码比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数。在插入第i个对象时，需要经过［log2i **]**+1次关键码比较才能确定它应插入的位置;
>
> ---
>
> 当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差;
>
> 在对象的初始排列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少，
>
> ---
>
> 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的例始排列・
>
> + 减少了比较次数，但没有减少移动次数
>
>   > 时间复杂度为0(n^2)
>   >
>   > 空间复杂度为0(1)
>   >
>   > 是一种稳定的排序方法
>
> + **平均性能优于直接插入排序**





#### 希尔排序

![image-20240613210948406](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613210948406.png) 

先将整个待排记录序列分割成**若干子序列**，分别进**行直接插入排序**待整个序列中的记录**"基本有序”**时，再对全体记录进行一次直接插入排序。

> + 缩小增量
> + 多遍插入排序

##### 算法思想

> 希尔排序是一种基于插入排序的排序算法。
>
> 通过**逐步减少元素之间的间隔，使得数组中任意间隔为某个值的子序列都是有序的**，最后变成一个普通的插入排序。

![image-20240613213936771](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613213936771.png) 

---

1. **初始间隔选择**：
   
    - **将数组分成若干个子序列**，**子序列中元素的间隔为某个固定值**。

      这个值通常称为“增量”或“步长”。希尔排序从较大的增量开始，**逐步减少增量，直到增量为1**。
    
    - 初始的增量通常取数组长度的一半（或稍小于一半），然后**逐步减小**（例如，每次减半）。
    
2. **对子序列进行插入排序**：
    - 对于每个增量，将数组分成若干个子序列。`对每个子序列分别进行插入排序`。
    - 由于每个子序列的元素之间间隔较大，**插入排序可以快速地移动元素，使得较大元素迅速向右移动，较小元素迅速向左移动**。

3. **减小增量并重复排序**：
    - 每次完成一个增量的排序后，减小增量，继续对子序列进行插入排序。
    - 最终，当**增量减小到1时，数组已经是部分有序的**，再进行一次标准的插入排序即可完成整个排序过程。

通过以上步骤，希尔排序在排序过程中先让数组中远距离的元素先逐渐有序，然后逐步减少间隔，让整个数组趋向有序，最后通过一次插入排序完成排序。

---

例子



##### 特点

> 一次移动，移动位置较大跳跃式地接近排序后的最终位置
>
> 最后一次只需要少量移动增量序列必须是递减的
>
> 最后一个必须是1
>
> 增量序列应该是互质的

---

例子

![image-20240613211545127](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613211545127.png) 



##### 算法分析

```cpp
#include <stdio.h>

#define MAXSIZE 100

// 定义顺序表类型
typedef struct {
    int r[MAXSIZE + 1]; // r[0] 作为暂存单元或哨兵
    int length;
} SqList;

// 一趟增量为dk的插入排序
void ShellInsert(SqList &L, int dk) {
    int i, j;
    for (i = dk + 1; i <= L.length; ++i) {
        if (L.r[i] < L.r[i - dk]) {
            L.r[0] = L.r[i]; // 暂存待插入元素
            for (j = i - dk; j > 0 && L.r[0] < L.r[j]; j -= dk) {
                L.r[j + dk] = L.r[j];
            }
            L.r[j + dk] = L.r[0];
        }
    }
}

// 按增量序列dlta[0..t-1]对顺序表L作希尔排序
void ShellSort(SqList &L, int dlta[], int t) {
    for (int k = 0; k < t; ++k) {
        ShellInsert(L, dlta[k]); // 一趟增量为dlta[k]的插入排序
    }
}

// 打印顺序表函数
void printList(SqList L) {
    for (int i = 1; i <= L.length; i++) {
        printf("%d ", L.r[i]);
    }
    printf("\n");
}

// 主函数：测试代码
int main() {
    // 定义并初始化顺序表
    SqList L = {{0, 22, 5, 11, 17, 8, 14, 3, 9, 6}, 9};
    // 定义增量序列
    int dlta[] = {5, 3, 1};
    int t = sizeof(dlta) / sizeof(dlta[0]);

    printf("排序前数组: \n");
    printList(L);

    // 调用希尔排序算法
    ShellSort(L, dlta, t);

    printf("排序后数组: \n");
    printList(L);

    return 0;
}

```

![image-20240613213053842](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613213053842.png) 

---

>  ![image-20240613215355989](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613215355989.png) 



![image-20240613215507512](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240613215507512.png) 

> 时间复杂度是n和d的函数O(n1.25)~O (1.6n1.25)经验公式空间复杂度为0(是一种不稳定的排序方法

增量序列如何选？

目前尚未解决！

但是最后一个增量必定为1

不适合在链式结构上实现。



#### 总结

| 排序方法     | 最好情况    | 最坏情况 | 平均情况 | 辅助存储 | 稳定性 |
| ------------ | ----------- | -------- | -------- | -------- | ------ |
| 直接插入排序 | O(n)        | O(n?)    | O(n?)    | O(1)     | 稳定   |
| 希尔排序     | O(n log? n) | O(n?)    | O(n^1.3) | O(1)     | 不稳定 |







## 交换排序

### 基本思想

> 交换排序（Exchange Sort）是通过**比较并交换**数组中的元素来达到排序的目的。
>
> 交换排序的核心在于**不断地交换两个元素的位置**，直到整个数组按照要求（通常是从小到大或从大到小）排列。
>
> 交换排序的主要方法包括冒泡排序（Bubble Sort）和快速排序（Quick Sort）。

![image-20240618184949068](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240618184949068.png) 

![image-20240618185257107](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240618185257107.png) 

> n个元素，需要比较n-1趟，最后一个不用比
>
> 第一趟比较n-1次 
>
> 随后是n-2,n-3.......1
>
> 第m趟要比较n-m次！！！



### 冒泡排序

> 假设有一个包含 n 个元素的数组 A：
>
> 1. 从第一个元素开始，比较相邻的两个元素：
>    - 如果 A[i]>A[i+1]，交换 A[i]和 A[i+1]
>    - 否则，不交换。
> 2. 对数组中的每一对相邻元素重复上述过程，这样最大的元素会被移动到数组的末尾。
> 3. 忽略已排序的最后一个元素，对剩下的未排序部分重复步骤1和步骤2。
> 4. 不断缩小未排序部分的范围，直到整个数组有序。

```c++
#include <iostream>

struct RedType {
    int key; // 可以根据需要添加其他成员
};

struct SqList {
    RedType *r; // 动态数组指针
    int length; // 数组长度
};

void bubble_sort(SqList &L) {
    int m, j;
    RedType x; // 交换时临时存储
    for (m = 1; m < L.length; ++m) { // 总共需进行 length-1 趟排序
        for (j = 0; j < L.length - m; ++j) { // 每趟需要比较的范围逐渐减小
            if (L.r[j].key > L.r[j + 1].key) { // 如果前一个元素大于后一个元素
                x = L.r[j]; // 交换它们
                L.r[j] = L.r[j + 1];
                L.r[j + 1] = x;
            }
        }
    }
}

int main() {
    int n = 5; // 假设排序的元素个数为5
    SqList L;
    L.length = n;
    L.r = new RedType[n];

    // 初始化测试数据
    L.r[0].key = 5;
    L.r[1].key = 3;
    L.r[2].key = 8;
    L.r[3].key = 6;
    L.r[4].key = 2;

    // 输出排序前的数组
    std::cout << "Before sorting:" << std::endl;
    for (int i = 0; i < L.length; ++i) {
        std::cout << L.r[i].key << " ";
    }
    std::cout << std::endl;

    // 进行冒泡排序
    bubble_sort(L);

    // 输出排序后的数组
    std::cout << "After sorting:" << std::endl;
    for (int i = 0; i < L.length; ++i) {
        std::cout << L.r[i].key << " ";
    }
    std::cout << std::endl;

    // 释放动态分配的内存
    delete[] L.r;

    return 0;
}

```

![image-20240618185941556](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240618185941556.png) 





#### 冒泡排序plus

> **提前终止冒泡排序**：在每趟排序中设置一个标志位（swapped），如果在某一趟排序中没有发生交换，说明数组已经有序，可以提前终止排序过程，避免不必要的比较。

```c++
void bubble_sort(SqList &L) {
    int m, j;
    RedType x; // 交换时临时存储
    bool swapped;
    for (m = 1; m < L.length; ++m) { // 总共需进行 length-1 趟排序
        swapped = false;
        for (j = 0; j < L.length - m; ++j) { // 每趟需要比较的范围逐渐减小
            if (L.r[j].key > L.r[j + 1].key) { // 如果前一个元素大于后一个元素
                x = L.r[j]; // 交换它们
                L.r[j] = L.r[j + 1];
                L.r[j + 1] = x;
                swapped = true;
            }
        }
        if (!swapped) break; // 如果没有发生交换，提前终止排序
    }
}

```





#### 时间复杂度分析

交换一次就要 执行三次赋值

![image-20240618190923300](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240618190923300.png) 

1. **最坏情况**：当输入数组是逆序时，每一趟排序都会进行最大次数的比较和交换，时间复杂度为O(n?)。
2. **最佳情况**：当输入数组已经有序时，只需要进行一次遍历即可完成排序，但仍需要O(n)的时间复杂度来检查数组是否有序。
3. **平均情况**：无论输入数组的初始状态如何，冒泡排序在平均情况下的时间复杂度也是O(n?)。

> 冒泡排序最好时间复杂度是O(n）
>
> 冒泡排序最坏时间复杂度为O（n2）
>
> 冒泡排序平均时间复杂度为O（n2）
>
> 冒泡排序算法中增加一个辅助空间temp辅助空间为S(n)=O(1)
>
> 冒泡排序是稳定的







### 快速排序

#### 基本思想

递归思想

> 基本思想：通过一趟排序，将待排序记录**分割成独立的两部分**，其分割后第一部分记录的关键字均比另一部分记录的关键字小，则可**分别对这两部分记录进行排序**，**以达到整个序列有序**。
>
> ---
>
> 具体实现  :  **选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边。**
>
> ---
>
> (枢轴)）中间数：：**可以是第一个数、最后一个数、最中间一个数、任选一个数等。**

![image-20240618191654963](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240618191654963.png) 

> 假设有一个包含 n 个元素的数组 A：
>
> 1. **选择基准**：选择数组 A 中的一个元素作为基准（pivot）。
>
> 2. 分割数组
>
>    ：重新排列数组，使得**基准左边的元素都小于基准**，**基准右边的元素都大于或等于基准**。具体做法如下：
>
>    - 从**数组的两端交替向中间扫描**，找到一个**左边大于基准和一个右边小于基准的元素**，交换它们的位置。
>
> 3. **递归排序**：对**基准左边的子数组**和**基准右边的子数组**分别**递归地进行快速排序**。
>
> 4. **结束条件**：当子数组的大小为0或1时，递归结束。



#### 快速排序演示

![image-20240618191906898](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240618191906898.png) 



![PixPin06-20_08-48-59](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/PixPin06-20_08-48-59.gif)

最终状态：

![image-20240619171251142](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240619171251142.png) 

> 如果low为null，heigh向中心移动，如果heigh的元素比哨兵小那么就和null互换。
>
> 如果heigh为null，low向中心移动，如果low的元素比哨兵大，那么就和nul互换
>
> 直到low和heigh都指向null，这个时候让哨兵和null互换
>
> ---
>
> 结果
>
> 划分为了两个子表，左边的是`原来的low――现在的low-1`
>
> 右边的是`现在的heigh+1――原来的heigh`

继续划分

![image-20240620085404390](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620085404390.png) 





#### 算法实现

每一趟的子表的形成是采用从两头向中间交替式逼近法;

由于每趟中对各子表的操作都相似，可采用递归算法

```c++
#include <iostream>
#include <vector>

// 定义顺序表结构
struct SqList {
    std::vector<int> r; // 用向量存储元素
};

// 分割函数，将顺序表分割，并返回枢轴位置
int Partition(SqList &L, int low, int high) {
    L.r[0] = L.r[low]; // 使用哨兵，存储枢轴
    int pivotkey = L.r[low]; // 枢轴关键字
    while (low < high) {
        while (low < high && L.r[high] >= pivotkey) --high;
        L.r[low] = L.r[high]; // 将比枢轴小的元素移到低端
        while (low < high && L.r[low] <= pivotkey) ++low;
        L.r[high] = L.r[low]; // 将比枢轴大的元素移到高端
    }
    L.r[low] = L.r[0]; // 枢轴元素归位
    return low; // 返回枢轴位置
}

// 快速排序函数
void QSort(SqList &L, int low, int high) {
    if (low < high) { // 子表长度大于1
        int pivotloc = Partition(L, low, high); // 分割
        QSort(L, low, pivotloc - 1); // 递归排序低子表
        QSort(L, pivotloc + 1, high); // 递归排序高子表
    }
}

int main() {
    // 示例使用
    SqList L = { {34, 7, 23, 32, 5, 62} }; // 初始化顺序表

        // 打印排序后的顺序表
    for (int i : L.r) {
        std::cout << i << " ";
    }
    QSort(L, 0, L.r.size() - 1); // 对顺序表进行快速排序

    std::cout<<std::endl;
    // 打印排序后的顺序表
    for (int i : L.r) {
        std::cout << i << " ";
    }

    return 0;
}

```

> 1. **选取枢轴**: 通常选取第一个元素作为枢轴，并把它临时存储在变量 `pivot` 中。这个元素的原位置 `L.r[low]` 将被用于移动其他元素，因此不再保留原值。
> 2. **从右向左扫描**:
>    - 找到第一个小于枢轴的元素，并将其移动到左边的位置 `L.r[low]`。
>    - 低指针 `low` 向右移动一步，腾出一个位置。
> 3. **从左向右扫描**:
>    - 找到第一个大于枢轴的元素，并将其移动到右边的位置 `L.r[high]`。
>    - 高指针 `high` 向左移动一步，腾出一个位置。
> 4. **重复上述步骤**: 交替进行，直到 `low` 和 `high` 相遇。
> 5. **将枢轴放回原位置**: 当 `low` 和 `high` 相遇时，将枢轴元素放回此位置。
>
> 这种方法的核心是将元素向左或向右移动，并在最终将枢轴放回到合适的位置。它避免了多次交换操作的开销，因为每次扫描只进行一次赋值操作。





#### 算法分析

快速排序（Quicksort）是一种非常高效的排序算法，其时间复杂度和空间复杂度的分析如下：





##### 时间复杂度

快速排序的时间复杂度依赖于枢轴选择的策略和输入数据的分布情况。以下是快速排序的时间复杂度分析：

最佳情况

- **时间复杂度**: \(O(n log n)\)
- **情况描述**: 每次分割都能将数组均匀地分成两半。
- **分析**: 
  - 每次分割操作需要 \(O(n)\) 的时间。
  - `数组可以被均匀地分割 \( log n \) 次。`
  - 总时间复杂度为 \(O(n) X O(log n) = O(n log n)\)。

---

最坏情况

- **时间复杂度**: \(O(n^2)\)
- **情况描述**: 每次分割都选择到最小或最大的元素作为枢轴，导致每次分割都只减少一个元素。
- **分析**: 
  - 每次分割操作需要 \(O(n)\) 的时间。
  - `需要进行 \(n\) 次分割。`
  - 总时间复杂度为 \(O(n) X O(n) = O(n^2)\)。
- **典型输入**: 已排序或逆序的数组。

---

平均情况

- **时间复杂度**: \(O(n log n)\)
- **情况描述**: 平均情况下，枢轴能够将数组大致均匀地分成两部分。
- **分析**: 
  - 平均情况下，快速排序的行为接近于最佳情况。
  - 每次分割操作的平均时间为 \(O(n)\)。
  - 分割次数为 \( log n \)。
  - 总时间复杂度为 \(O(n) X O(\log n) = O(n log n)\)。

##### 空间复杂度

快速排序的空间复杂度分析如下：

递归调用的栈空间

- **空间复杂度**: \(O(log n)\)（最佳情况和平均情况）、\(O(n)\)（最坏情况）
- **情况描述**: 空间复杂度主要由递归调用的栈空间决定。
- **分析**: 
  - 在最佳和平均情况下，递归深度为 \(O(log n)\)。
  - 在最坏情况下，递归深度为 \(O(n)\)。

稳定性

快速排序是一种不稳定的排序算法，这意味着**相同值的元素在排序后其相对位置可能会发生变化。**

![image-20240620092440946](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620092440946.png) 

---

##### 总结

+ **划分元素的选取**是影响时间性能的关键
+ 输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序**不是自然排序方法**。
+ 改变划分元素的选取方法，至多只能改变算法平均情况的下的世界性能无法改变最坏情况下的时间性能。即最坏情况下，快速排序的时间复杂性总是O(n^2)

---

越乱越好！

- **最佳时间复杂度**: \(O(nlog n)\)
- **最坏时间复杂度**: \(O(n^2)\)
- **平均时间复杂度**: \(O(n log n)\)
- **空间复杂度**: \(O(log n)\)（最佳和平均情况）、\(O(n)\)（最坏情况）
- **稳定性**: 不稳定

尽管最坏情况下的时间复杂度为 \(O(n^2)\)，但在实际应用中，通过选择合适的枢轴（例如三数取中法、随机选择枢轴）和优化算法，快速排序的性能通常非常接近于 \(O(n \log n)\)，因此它被广泛应用于各种场合。





##### 思考

![image-20240620092542368](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620092542368.png) 





#### 总结

| 排序方法 | 最好情况   | 最坏情况 | 平均情况   | 辅助存储 | 稳定性 |
| -------- | ---------- | -------- | ---------- | -------- | ------ |
| 冒泡排序 | O(n)       | O(n?)    | O(n?)      | O(1)     | 稳定   |
| 快速排序 | O(n log n) | O(n?)    | O(n log n) | O(log n) | 不稳定 |







## 选择排序

### 基本思想

> 基本思想：在待排序的数据中选出最大（小）的元素放在其最终的位置
>
> 基本操作:
>
> 1．首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换
>
> 2.再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换
>
> 3．重复上述操作，共进行n-1趟排序后，排序结束

### 简单选择排序

#### 例子

![image-20240620183155421](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620183155421.png) 





#### 算法实现

```c++
#include <iostream>
using namespace std;

struct SqList {
    int* r; // 数组指针
    int length; // 数组长度
};

void SelectSort(SqList &L) {
    int i, j, k;
    for (i = 0; i < L.length - 1; ++i) {
        k = i;
        for (j = i + 1; j < L.length; ++j) {
            if (L.r[j] < L.r[k]) {
                k = j; // 记录最小值位置
            }
        }
        if (k != i) {
            swap(L.r[i], L.r[k]); // 交换
        }
    }
}

int main() {
    int arr[] = {64, 25, 12, 22, 11};
    SqList L = {arr, 5};

    for (int i = 0; i < L.length; i++) {
        cout << L.r[i] << " ";
    }
    cout<<endl;
    SelectSort(L);
    
    for (int i = 0; i < L.length; i++) {
        cout << L.r[i] << " ";
    }
    return 0;
}

```

![image-20240620183507944](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620183507944.png) 





#### 算法分析

> 记录移动次数
>
> 最好情况：0
>
> 最坏情况：3(n-1)
>
> 比较次数：无论待排序列处于什么状态，选择排序所需进行的"比较”次数都相同
>
> `1+2+....n-1=n(n-1)/2`
>
> n^2;

简单选择排序是不稳定排序

但是可以改进为稳定的

![image-20240620184251658](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620184251658.png) 



时间复杂度

1. **辅助空间**：
   - 选择排序是就地排序算法，即它在原数组上进行排序，不需要额外的辅助数组。
2. **辅助变量**：
   - 只使用了常数个额外变量（例如 `i`、`j`、`k` 和用于交换的临时变量）。

因此，选择排序的空间复杂度为 O(1)。





### 堆排序

#### 堆的定义

完全二叉树:

> **除了最后一层之外，每一层的节点都是满的。**
>
> **最后一层的节点必须从左到右连续排列，没有空缺。**

从堆的定义可以看出，堆实质是满足如下性质的**完全二叉树**

 二叉树中任一非叶子结点均小于（大于）它的孩子结点 

![image-20240620184936220](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620184936220.png) 

大根堆的根就是最大值

小根堆的根就是最小值 

#### 判断是否是堆

![image-20240620185245076](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620185245076.png) 

![image-20240620185343029](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620185343029.png) 

#### 堆排序

> 若在输出**堆顶的最小值（最大值）**后，使得剩余n-1个元素的序列重又建成一个堆
>
> 则得到n个元素的次小值（次大值）...如此反复，便能得到一个有序序列，这个过程称之为堆排序。

问题关键

如何由一个无序序列建成一个堆？

如何在输出堆顶元素后，调整剩余元素为一个新的堆?





#### 堆的调整

小根堆:

> 1．输出堆顶元素之后，以堆中最后一个元素替代之；
>
> 2 . 然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换;
>
> 3．重复上述操作，**直至叶子结点**，将得到新的堆，称这个从堆顶至叶子的调整过程为“筛选”

大根堆：类比

输出根：若对一个无序序列建堆，然后输出根；重复该过程就可以由一个无需序列输出有序序列。

---

![PixPin06-20_21-24-58](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/PixPin06-20_21-24-58.gif)

```c++
void HeapAdjust(int R[], int s, int m) {
    int rc = R[s];  // 用 rc 暂存 R[s] 的值
    for (int j = 2 * s; j <= m; j *= 2) {  // 沿 key 较大的子节点向下筛选
        if (j < m && R[j] < R[j + 1]) {
            ++j;  // 如果右子节点存在且大于左子节点，则 j 指向右子节点
        }
        if (rc >= R[j]) {
            break;  // 如果 rc 大于等于最大的子节点，筛选结束
        }
        R[s] = R[j];  // 否则，将子节点上移
        s = j;  // 继续向下筛选
    }
    R[s] = rc;  // 将 rc 放到最终位置
}

```

Just 了解一下。

可以看出:对一个无序序列反复“筛选”就可以得到一个堆;

即：从一个无序序列建堆的过程就是一个反复“筛选”的过程。



#### 堆的建立

> **单节点的二叉树是堆**：
>
> - 对于只有一个节点的二叉树，它没有子节点，所以它天然满足堆的性质。
>
> **完全二叉树中所有以叶子结点为根的子树是堆**：
>
> - 在完全二叉树中，所有叶子结点没有子节点，所以它们本身就是堆。
>
> **从第 `n/2` 个节点开始调整**：
>
> - 完全二叉树中，所有非叶子节点的索引在 `1` 到 `n/2` 之间。
> - 从最后一个非叶子节点（即 `n/2` 节点）开始，依次向前调整每个节点，使其满足堆的性质。

---

例：有关键字为49，38，65，97，76，13，27，49的一组记录，将其按关键字调整为一个小根堆。

![image-20240620214111648](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620214111648.png) 

![image-20240620213854996](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620213854996.png) 

> 若对一个无序序列建堆，然后输出根重复该过程就可以由一个无需序列输出有序序列。
>
> 实质上，堆排序就是利用完全二叉树中父结点与孩子结点文间的内在关系来排序的。

```c++
#include <iostream>
#include <vector>

using namespace std;

// 交换两个元素的值
void Swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

// 调整为小根堆
void HeapAdjust(vector<int> &R, int s, int m, vector<vector<int>> &result) {
    int rc = R[s];  // 用 rc 暂存 R[s] 的值
    for (int j = 2 * s; j <= m; j *= 2) {  // 沿 key 较小的子节点向下筛选
        if (j < m && R[j] > R[j + 1]) {
            ++j;  // 如果右子节点存在且小于左子节点，则 j 指向右子节点
        }
        if (rc <= R[j]) {
            break;  // 如果 rc 小于等于最小的子节点，筛选结束
        }
        R[s] = R[j];  // 否则，将子节点上移
        s = j;  // 继续向下筛选
    }
    R[s] = rc;  // 将 rc 放到最终位置
    
    // 将当前状态存入结果中
    result.push_back(R);
}

// 建立小根堆
void BuildMinHeap(vector<int> &R, int n, vector<vector<int>> &result) {
    for (int i = n / 2; i >= 1; --i) {
        HeapAdjust(R, i, n, result);
    }
}

// 打印数组
void PrintArray(const vector<int> &R) {
    for (size_t i = 1; i < R.size(); ++i) {
        cout << R[i] << " ";
    }
    cout << endl;
}

int main() {
    vector<int> R = {-1, 49, 38, 65, 97, 76, 13, 27, 49}; // 使用从索引1开始的数组
    int n = R.size() - 1; // 数组的大小减去1，因为第一个元素是占位符
    
    vector<vector<int>> result;
    result.push_back(R); // 存入初始状态
    
    BuildMinHeap(R, n, result);
    
    // 输出每次交换完后的数组状态
    for (size_t i = 1; i < result.size(); ++i) {
        PrintArray(result[i]);
    }
    
    return 0;
}

```

![image-20240620215144784](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620215144784.png) 

#### 堆排序算法

```c++
void HeapSort(int R[], int n) {
    // 建初始堆
    for (int i = n / 2; i >= 1; i--) {
        HeapAdjust(R, i, n);//初始堆
    }
    
    // 进行n - 1趟排序
    for (int i = n; i > 1; i--) {
        Swap(R[1], R[i]); // 根与最后一个元素交换
        HeapAdjust(R, 1, i - 1); // 对R[1]到R[i - 1]重新建堆
    }
}
```

#### 复杂度分析

> **时间复杂度**：
>
> - **最坏情况下**：O(n log n)
> - **最好情况下**：O(n log n)
> - **平均情况下**：O(n log n)
>
> 堆排序的时间复杂度主要耗费在两个方面：
>
> - **建立初始堆**：从最后一个非叶子节点开始，向前依次调整，建立初始堆的时间复杂度是 O(n)。
> - **调整堆**：每次交换堆顶元素后，需要对剩余的元素重新进行堆调整，时间复杂度是 O(log n)。总共需要进行 n-1 次交换和堆调整操作。
>
> **空间复杂度**：
>
> - 堆排序仅需一个大小与待排序序列相等的辅助存储空间，即 O(1) 的额外空间复杂度。
>
> **稳定性**：
>
> - 堆排序是一种**不稳定**的排序方法。即存在相同关键字的记录在排序过程中可能会改变相对位置。
>
> **适用性**：
>
> - 对于待排序记录较少的情况，堆排序的建堆过程和大量的元素移动可能会显得比较耗时，不如其他简单的排序方法（如插入排序或冒泡排序）高效。
> - 但对于大规模数据的排序，堆排序因为其 O(n log n) 的时间复杂度和较小的空间复杂度，在效率上表现优异。





## 归并排序

基本思想：将两个或两个以上的有序子序列严归并为一个有序序列。

归并排序（Merge Sort）是一种经典的排序算法，其基本思想是将两个或多个有序子序列合并成一个有序序列。在内部排序中，通常采用的是2路归并排序，即将两个相邻的有序子序列归并为一个有序序列。

### 基本思想

1. **分治策略**：
   - 将**原始序列划分为若干个子序列**，**直到每个子序列只有一个元素为止**，认为每个单独的元素是有序的。
   - 将相邻的子序列**两两归并**，形成较大的有序子序列，**直到最终整个序列有序为止。**
2. **归并过程**：
   - 归并操作是**将两个有序序列合并成一个有序序列的过程**。
   - 比较两个子序列的首元素，将较小（或较大）的元素放入新序列中，然后继续比较下一个元素，直到其中一个子序列为空，将另一个子序列剩余的元素直接放入新序列的末尾。



### 例子

![image-20240620215758121](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620215758121.png) 

倒过来像一棵二叉树，也就是树的高度

整个归并排序仅需[log2n]趟

---

关键问题：如何将两个有序序列合成一个有序序列?



```c++
#include <iostream>
#include <vector>

using namespace std;

// 合并两个已排序的子数组 R[low..mid] 和 R[mid+1..high]
void Merge(vector<int>& R, int low, int mid, int high) {
    int n1 = mid - low + 1;     // 左子数组的大小
    int n2 = high - mid;        // 右子数组的大小
    
    // 创建临时数组 L 和 R2
    vector<int> L(n1);
    vector<int> R2(n2);
    
    // 将数据复制到临时数组 L 和 R2 中
    for (int i = 0; i < n1; i++)
        L[i] = R[low + i];
    for (int j = 0; j < n2; j++)
        R2[j] = R[mid + 1 + j];
    
    // 合并临时数组 L 和 R2 到 R[low..high]
    int i = 0;  // 初始化左子数组的索引
    int j = 0;  // 初始化右子数组的索引
    int k = low;  // 初始化合并后数组的索引
    
    while (i < n1 && j < n2) {
        if (L[i] <= R2[j]) {
            R[k] = L[i];
            i++;
        } else {
            R[k] = R2[j];
            j++;
        }
        k++;
    }
    
    // 复制剩余的元素，如果有的话
    while (i < n1) {
        R[k] = L[i];
        i++;
        k++;
    }
    
    while (j < n2) {
        R[k] = R2[j];
        j++;
        k++;
    }
}

int main() {
    vector<int> R = {3, 9, 10, 27, 38, 43, 82}; // 示例已排序数组
    int low = 0;
    int high = R.size() - 1;
    int mid = (low + high) / 2; // 示例中间索引
    
    // 合并两个已排序的子数组 R[low..mid] 和 R[mid+1..high]
    Merge(R, low, mid, high);
    
    // 打印合并后的数组
    for (int num : R) {
        cout << num << " ";
    }
    cout << endl;
    
    return 0;
}

```





### 算法分析

归并排序（Merge Sort）是一种经典的分治排序算法，它具有以下特点：

---

时间复杂度：

归并排序的时间复杂度为 O(n log n)。这是由于每次将序列分成两半，然后分别对这两半进行递归排序，并最终将两个有序子序列合并成一个有序序列的操作。

---

空间复杂度：

归并排序的空间复杂度为 O(n)。在合并过程中，需要额外的空间来存储临时数组，用于存放合并过程中产生的有序子序列。这个临时数组的大小与待排序数组的大小相同，所以空间复杂度为 O(n)。

---

稳定性：

归并排序是一种稳定的排序算法。稳定性指的是如果两个元素值相等时，排序前后它们的相对位置不变。在归并排序中，当两个元素值相等时，我们先把左边的子序列中的元素放入结果数组中，保证了稳定性。







## 基数排序

### 基本思想

基数排序的基本思想是将待排序的整数按照位数（个位、十位、百位等）上的数字进行排序。它的实现通常分为两个步骤：

1. **分配（Distribution）**：
   - 根据当前位上的数字，将待排序的元素分配到对应的桶（箱子）中。
2. **收集（Collection）**：
   - 按照桶的顺序将元素收集起来，形成新的待排序数组。



### 例子



![image-20240620221025509](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620221025509.png) 

 ![image-20240620221120956](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620221120956.png)

![image-20240620221134953](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC8%E5%91%A8/image-20240620221134953.png) 





### 算法分析

### 时间复杂度

基数排序的时间复杂度可以分析为 O(k?(n+m))，其中：

- n 是待排序元素的个数。
- k 是关键字的位数，或者说是数字的最大位数。
- m 是关键字的取值范围，也就是桶的个数。

**解释时间复杂度的分析**：

1. **分配到桶中的复杂度**：
   - 将  个元素按照当前位的数字分配到 m 个桶中，需要 O(n+m) 的时间复杂度。
2. **收集回数组中的复杂度**：
   - 从 m 个桶中依次收集元素到数组中，需要 O(n+m) 的时间复杂度。
3. **位数的循环次数**：
   - 基数排序通常需要对关键字的每一位进行排序，因此需要循环 k 次（k 是关键字的位数）。

综上所述，基数排序的时间复杂度为 O(k?(n+m))，其中 k 可以看作是一个常数因子，通常 kkk 不大于整数的位数，因此可以认为基数排序的时间复杂度是 O(n+m) 级别的。

---

空间复杂度

基数排序的空间复杂度为 O(n+m)

- 需要一个大小为 n 的辅助数组来存放每一轮排序后的结果。
- 需要大小为 m 的桶数组来存放分配到每个桶中的元素。

因此，总体空间复杂度为 O(n+m)

---

稳定性

基数排序是一种稳定的排序算法。

- 在分配到桶中时，保证了相同关键字的元素按照原来的顺序进入到桶中。
- 在收集时，按照桶的顺序依次将元素取出，保证了相同关键字的元素保持了原来的相对顺序。

综上所述，基数排序在时间复杂度为 O(k?(n+m))，空间复杂度为 O(n+m)，并且是稳定的排序算法。它适用于关键字位数不多，但关键字取值范围较大的情况下，效率较高。







## 综合比较

| 排序方法     | 时间复杂度     | 最好情况       | 最坏情况       | 平均情况       | 空间复杂度 | 辅助存储 | 稳定性 |
| ------------ | -------------- | -------------- | -------------- | -------------- | ---------- | -------- | ------ |
| 直接插入排序 | O(n^2)         | O(n)           | O(n^2)         | O(n^2)         | O(1)       | 无       | 稳定   |
| 希尔排序     | O(n log n)     | 取决于增量序列 | 取决于增量序列 | 取决于增量序列 | O(1)       | 无       | 不稳定 |
| 冒泡排序     | O(n^2)         | O(n)           | O(n^2)         | O(n^2)         | O(1)       | 无       | 稳定   |
| 快速排序     | O(n log n)     | O(n log n)     | O(n^2)         | O(n log n)     | O(log n)   | 递归栈   | 不稳定 |
| 直接选择排序 | O(n^2)         | O(n^2)         | O(n^2)         | O(n^2)         | O(1)       | 无       | 不稳定 |
| 堆排序       | O(n log n)     | O(n log n)     | O(n log n)     | O(n log n)     | O(1)       | 无       | 不稳定 |
| 归并排序     | O(n log n)     | O(n log n)     | O(n log n)     | O(n log n)     | O(n)       | 临时数组 | 稳定   |
| 基数排序     | O(k * (n + m)) | O(k * (n + m)) | O(k * (n + m)) | O(k * (n + m)) | O(n + m)   | 桶       | 稳定   |





当讨论排序算法时，特别是对于涉及时间复杂度、空间复杂度和稳定性的描述时，可以采用如下笔记方法来记忆和理解：

### 时间性能
1. **O(nlogn) 的排序方法**：
   - 快速排序 (最好)
   - 堆排序
   - 归并排序

2. **O(n^2) 的排序方法**：
   - 直接插入排序 (最好，特别是对关键字近似有序的序列)
   - 冒泡排序
   - 简单选择排序

3. **O(n) 的排序方法**：
   - 基数排序

4. **最好、最坏情况下的时间性能**：
   - 对于快速排序，最好情况为O(nlogn)，最坏情况为O(n^2)，特别是在输入序列有序时会达到最坏情况。
   - 简单选择排序和冒泡排序在待排记录序列按关键字顺序有序时能达到O(n)时间复杂度。

### 空间性能
1. **空间复杂度为 O(1) 的排序方法**：
   - 直接插入排序
   - 冒泡排序
   - 简单选择排序
   - 堆排序

2. **空间复杂度为 O(logn) 的排序方法**：
   - 快速排序 (栈所需的辅助空间)

3. **空间复杂度为 O(n) 的排序方法**：
   - 归并排序 (所需辅助空间最多)

4. **链式基数排序的空间复杂度**：
   - 需要队列首尾指针，空间复杂度为 O(rd)，其中 r 为基数，d 为关键字位数。

### 稳定性
1. **稳定的排序方法**：
   - 对于相等的关键字，排序前后它们的相对位置不变。
   - LSD 方法排序多关键字的记录序列时，需要稳定的排序方法。

2. **不稳定的排序方法**：
   - 快速排序
   - 堆排序

### 总结
- **O(nlogn)** 的排序方法：快速排序、堆排序、归并排序。
- **O(n^2)** 的排序方法：直接插入排序、冒泡排序、简单选择排序。
- **O(n)** 的排序方法：基数排序。
- **空间复杂度 O(1)** 的排序方法：直接插入排序、冒泡排序、简单选择排序、堆排序。
- **空间复杂度 O(logn)** 的排序方法：快速排序。
- **空间复杂度 O(n)** 的排序方法：归并排序。
- **稳定的排序方法**：直接插入排序、冒泡排序、简单选择排序。
- **不稳定的排序方法**：快速排序、堆排序。

这些笔记可以帮助你系统地理解和记忆排序算法的特性和性能表现。