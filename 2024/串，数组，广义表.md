# 串，数组和广义表

## 回顾

![image-20240415104823641](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415104823641.png)  

> 串是内容只允许为字符集 的线性表
>
> 栈和队列的操作是受限制的线性表



## 串

### 串的定义

> 串（String）是由字符组成的有限序列。字符可以包括字母、数字、符号或者其他任意字符

![image-20240415104924127](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415104924127.png) 

### 串的术语

![image-20240415105109537](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105109537.png) 

![image-20240415105134344](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105134344.png) 



### 案例引入

串的应用非常广泛，计算机上的非数值处理的对象大部分是字符串数据，例如：文字编辑、符号处理、各种信息处理系统等等

#### 病毒感染检测

![image-20240415105219192](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105219192.png) 

![image-20240415105255213](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105255213.png) 

### 串的类型定义，存储结构及运算

#### 串的类型定义

![image-20240415105400402](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105400402.png) 

![image-20240415105410944](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105410944.png) 

#### 串的存储结构

![image-20240415105459831](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105459831.png) 

##### 串的顺序存储结构

> 顺序存储结构是一种数据结构的表示方式，其中元素在内存中是按照逻辑顺序依次存储的，而且物理存储关系等于逻辑存储关系。换句话说，数据元素在内存中的实际存储顺序与它们在逻辑上的顺序是一致的。

```c
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN+1];//存储串的一维数组
	int length;//串的当前长度长度
}SString;
```

> - `MAXLEN` 是一个预处理指令，定义了串的最大长度为 255，这是一个常量，可以根据需要进行调整。
> - `typedef` 用于定义 `SString` 作为 `struct` 的别名，这样可以在代码中直接使用 `SString` 来声明变量，而不必每次都写出 `struct`。
>   - `ch[MAXLEN+1]` 是一个字符数组，用于存储串的内容，长度为 `MAXLEN+1`。`+1` 是为了给字符串结尾添加一个空字符（`\0`），以便在 C 语言中正确处理字符串函数。

##### 串的链式存储结构

> 链式存储的存储密度底，操作方便

```c
typedef struct LNode {
    char data;          // 存储的字符数据
    struct LNode *next; // 指向下一个节点的指针
} LNode, *LString;

```

克服存储密度低->一个节点存储多个字符！

![image-20240415105947240](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415105947240.png) 

#####  块链结构

```c
#define CHUNKSIZE 80 // 块的大小可由用户定义

typedef struct Chunk {
    char ch[CHUNKSIZE]; // 存储字符数据的数组
    struct Chunk *next; // 指向下一个块的指针
} Chunk;

typedef struct {
    Chunk *head; // 串的头指针
    Chunk *tail; // 串的尾指针
    int curlen;  // 串的当前长度
} LString; // 字符串的块链结构

```

### 串的模式匹配算法

> 确认主串中所含**字串(模式串)****第一次出现的位置**（定位）

![image-20240415110436418](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415110436418.png) 

####  BF算法

1. **从主串的第一个字符开始匹配**：将**主串的指针从第一个字符开始**，将模式串的指针也从第一个字符开始，逐个比较它们的字符。

2. **逐个字符比较**：比较主串和模式串对应位置的字符

   如果相同，则继续比较下一个字符；

   如果不同，则主串的指针向后移动一位，重新从主串的下一个字符开始和模式串的第一个字符比较。

3. **重复步骤2**：重复以上步骤，直到找到完全匹配的子串或者主串的指针已经移动到末尾。

4. **匹配成功或失败**：如果在主串中找到了与模式串匹配的子串，则匹配成功，返回匹配的起始位置；如果主串的指针移动到末尾仍未找到匹配的子串，则匹配失败。

##### 暴力匹配算法的复杂度：

- **最坏情况下的时间复杂度**：当主串和模式串都很长，并且没有任何字符匹配时，需要比较所有可能的子串，时间复杂度为 O(m*n)，其中 m 是主串的长度，n 是模式串的长度。

当主串和模式串的长度较小或者模式串的长度固定时，简单而有效

![image-20240415110916250](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415110916250.png)

![image-20240415110938845](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415110938845.png)

![image-20240415111010028](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415111010028.png)  

![image-20240415110824287](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415110824287.png) 

##### 算法设计思想

![image-20240415111039730](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415111039730.png) 

##### 算法实现

![image-20240415111542718](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415111542718.png) 

```c
#include <stdio.h>
#include <string.h>

#define MAXLEN 255

typedef struct {
    char ch[MAXLEN + 1]; // 存储串的一维数组
    int length;          // 串的当前长度
} SString;               // 串的顺序存储结构

int Index_BF(SString S, SString T) {
    int i = 1, j = 1;
    while (i <= S.length && j <= T.length) {
        if (S.ch[i] == T.ch[j]) {
            ++i;
            ++j;
        } else {
            i = i - j + 2;
            j = 1;
        }
    }
    if (j > T.length) {
        return i - T.length; // 返回匹配的第一个字符的下标
    } else {
        return 0; // 模式匹配不成功
    }
}

int main() {
    SString mainStr = {"ababcabcababcabcabc", 18}; // 主串
    SString pattern = {"abcabcabc", 9};            // 模式串

    int pos = Index_BF(mainStr, pattern);

    if (pos != 0) {
        printf("Pattern found at position: %d\n", pos);
    } else {
        printf("Pattern not found.\n");
    }

    return 0;
}

```

##### 时间复杂度分析

最好的i情况执行m次也就是模式串的长度

最坏的情况是(n-m)*m+m也就是最后abcdef,def这种要比对abc分别作为起点和模式串比对m次

最后再加上d为起点比对成功的三次也就是(n-m)*m+m

![image-20240415111759626](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415111759626.png) 





#### KMP算法

##### 和BF算法的区别

![image-20240415215101919](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415215101919.png) 

都是用于字符串匹配的经典算法

1. **时间复杂度**：
   - BF算法的时间复杂度是O(m*n)，其中m是模式串的长度，n是文本串的长度。因为BF算法在每一步都需要完全匹配，所以它的性能受到了文本串和模式串长度的影响。
   - KMP算法的时间复杂度是O(m+n)，其中m是模式串的长度，n是文本串的长度。KMP算法通过利用模式串自身的特性，在匹配失败时跳过一些已经比较过的字符，从而减少了比较的次数。

2. **匹配失败时的处理方式**：
   - BF算法在匹配失败时，会将模式串向右移动一位，继续尝试下一个位置。
   - KMP算法在匹配失败时，根据已经匹配过的部分信息，调整模式串的位置，使得模式串向右移动的距离更大，从而减少比较的次数。

3. **主要思想**：
   - BF算法是一种暴力搜索的思想，每次匹配失败时，都会尝试所有可能的情况。
   - KMP算法利用了模式串自身的信息，通过构建一个部分匹配表（也称为next数组），在匹配失败时能够利用已经比较过的信息来尽可能地减少比较次数。

4. **空间复杂度**：
   - BF算法通常不需要额外的空间，只需要存储文本串和模式串。
   - KMP算法需要额外的空间来存储部分匹配表，其空间复杂度为O(m)，其中m是模式串的长度。

![image-20240415215221957](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415215221957.png) 



##### next[j]函数

![image-20240415215241199](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415215241199.png)

![image-20240415215635859](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415215635859.png)  

![image-20240415215432364](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415215432364.png)

##### 算法实现 

![image-20240415220455867](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415220455867.png) 

![image-20240415220448922](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415220448922.png) 

```c
int Index_KMP(SString S, SString T, int pos) {
    int i = pos, j = 1;
    int next[T.length + 1];  // 存储模式串T的next数组
    get_next(T, next);  // 计算模式串T的next数组
    
    while (i <= S.length && j <= T.length) {
        if (j == 0 || S.ch[i] == T.ch[j]) {
            i++;
            j++;
        } else {
            j = next[j];  // j后退
        }
    }
    
    if (j > T.length)
        return i - T.length;  // 匹配成功，返回匹配的起始位置
    else
        return 0;  // 返回不匹配标志
}

```

```c
void get_next(SString T, int next[]) {
    int i = 1;
    next[1] = 0;
    int j = 0;
    while (i < T.length) {
        if (j == 0 || T.ch[i] == T.ch[j]) {
            ++i;
            ++j;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}

```

##### next函数的改进

![image-20240415220833834](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415220833834.png)   

判断前面的字符和现在的j位置一样，就没必要回溯了

直接i前进一步，j回到1

##### nextval[j]

> 是用next[j]的值去找对应的字符进行比较
>
> 那么nextval的值就是：相同就取前面的(next[j]的值)，否则就取后面的(next[j]的值 )

![image-20240415221030731](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415221030731.png) 

```c
void get_nextval(SString T, int nextval[]) {
    int i = 1;
    nextval[1] = 0;
    int j = 0;
    while (i < T.length) {
        if (j == 0 || T.ch[i] == T.ch[j]) {
            ++i;
            ++j;
            if (T.ch[i] != T.ch[j])
                nextval[i] = j;
            else
                nextval[i] = nextval[j];
        } else {
            j = nextval[j];
        }
    }
}

```

![image-20240415221341446](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240415221341446.png) 

> 会计算next[j]和nextval[j]的值就ok了！





## 数组

### 数组的定义

数组是一种用来存储相同类型的元素的数据结构。它们是一系列连续的内存位置，每个位置都有一个唯一的索引。数组可以是一维的，也可以是多维的。

线性结构。定长的线性表

声明格式：数据类型 变量名称[数组长度]

```c
int a[5];={1,2,3,4,5};
```

 

#### 二维数组的定义![image-20240416132319625](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416132319625.png) 

声明格式:数据类型 变量名称[行数]\[列数]

```c
int a[3][2];
```

![image-20240416132615088](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416132615088.png) 

#### 多维数组

![image-20240416132647624](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416132647624.png) 

### 数组的抽象数据类型定义

![image-20240416132736063](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416132736063.png) 

例子：

![image-20240416133012469](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416133012469.png) 

### 基本操作

![image-20240416133047465](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416133047465.png) 

### 数组的顺序存储

数组特点：结构固定，数组和维界不变

#### 基本操作：

![image-20240416133116838](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416133116838.png) 

所以一般采用顺序存储结构来表示数组

数组虽然可以是多维的，但是存储数据元素的内存单元地址是一维 的

#### 一维数组的内存地址

![image-20240416133420750](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416133420750.png) 

#### 二维数组的内存地址![image-20240416133536770](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416133536770.png) 

![image-20240416133809399](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416133809399.png) 

##### 以行序为主序

![image-20240416134110049](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134110049.png) 

![image-20240416134042926](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134042926.png)  

##### 以列序为主序

![image-20240416134135828](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134135828.png) 

a[0,0] a[0,1] a[0,2]  

a[1,0] a[1,1] a[1,2]

a[2,0] a[2,1] a[2,2] 

![image-20240416134440416](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134440416.png)  

所以对应的LOC(i,j)=(n\*j+i\*)L + LOC(0,0)



#### 三维数组的内存地址

![image-20240416134641799](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134641799.png) 

![image-20240416134754048](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134754048.png) 

n维

![image-20240416134824721](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416134824721.png) 

#### 例子

![image-20240416135105783](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416135105783.png) 

#### 特殊矩阵的压缩存储

![image-20240416213804295](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416213804295.png) 

![image-20240416213956263](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416213956263.png) 

##### 对称矩阵

![image-20240416214109868](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416214109868.png)   

**下标K如何求取？**

![image-20240416214536766](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416214536766.png) 





##### 三角矩阵

![image-20240416220758845](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416220758845.png) 

##### 对角矩阵

![image-20240416220852269](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416220852269.png) 

如何压缩存储？0就不存了！

![image-20240416221116673](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416221116673.png) 

##### 稀疏矩阵

> 超过95%的元素就是0

![image-20240416221338820](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416221338820.png) 

###### 顺序存储结构

![image-20240416221449698](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416221449698.png) 

也可以相互转换

![image-20240416221525481](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416221525481.png) 

> 缺点：不能随机存取，只能从头找

###### 十字链表

克服了缺点

![image-20240416221736483](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416221736483.png)  

![image-20240416221949658](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416221949658.png) 

![image-20240416222028788](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416222028788.png) 





## 广义表

### 广义表的定义

![image-20240416222644477](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416222644477.png)  

> 广义表（Generalized List）和线性表（List）是两种不同的数据结构，它们之间有几个关键区别：
>
> 1. **数据结构定义**：
>    - 线性表是一种基本的数据结构，它由一系列元素组成，这些元素按照顺序排列，每个元素都有一个前驱元素和一个后继元素，除了第一个元素没有前驱元素，最后一个元素没有后继元素。
>    - 广义表是线性表的扩展，它可以包含元素（通常是原子元素，如整数、字符等）以及子表（也称为子广义表），这些子表可以是任意深度的嵌套结构，从而形成了一个更加灵活的数据表示形式。
>
> 2. **元素类型**：
>    - 线性表中的**元素类型通常是相同**的，即所有元素都是同一种类型。
>    - 广义表中的元素类型可以是原子类型（如整数、字符等）或**子表**，因此广义表的元素类型更加灵活。
>
> 3. **结构特点**：
>    - 线性表的结构相对简单，元素之间是一对一的关系，即每个元素只有一个直接后继。
>    - 广义表的结构更加复杂，它可以包含原子元素和子表，子表内部又可以包含原子元素和更深层次的子表，因此广义表的结构可以是多层次的嵌套。
>
> 4. **操作支持**：
>    - 线性表通常支持一些基本的操作，如插入、删除、查找等。
>    - 广义表除了支持线性表的基本操作外，还需要支持对子表的操作，如访问子表、在子表中进行插入、删除等。
>

![image-20240416222319296](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416222319296.png) 

### 例子

![image-20240416223011202](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416223011202.png)

### 广义表的性质

1. **原子元素与子表的组合**：广义表中的元素可以是原子元素（如整数、字符等）或者子表。这种灵活性使得广义表能够表示各种复杂的数据结构，例如树、图等。

2. **递归定义**：广义表的定义是递归的，因为**子表本身也可以是广义表**。这使得广义表的结构可以是无限层次的嵌套，从而能够表示任意复杂度的数据结构。

3. **元素之间无固定关系**：与线性表不同，**广义表中的元素之间没有固定的顺序关系**。每个元素都可以是原子元素或者子表，它们之间的排列顺序并不影响广义表的含义。

4. **多样的操作**：广义表支持一系列操作，包括创建、访问、修改、遍历等。由于广义表的结构灵活多样，对广义表的操作也需要考虑到可能存在的多层嵌套关系。

5. **嵌套层次**：广义表的嵌套层次可以是任意的，这意味着可以通过嵌套的方式来表示更加复杂的数据结构

![image-20240416223338560](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416223338560.png)  

![image-20240416223413601](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416223413601.png) 





### 广义表和线性表的区别

![image-20240416223514341](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416223514341.png) 



### 广义表的基本运算

![image-20240416223719219](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416223719219.png) 

### 案例分析与实现

#### 病毒感染检测

![image-20240416224030453](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416224030453.png) 

![image-20240416224108420](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416224108420.png) 

![image-20240416224158461](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC4%E5%91%A8/image-20240416224158461.png) 