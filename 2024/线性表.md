# 线性表

## 知识回顾



数据结构要研究的问题

![image-20240217085739265](数据结构第2周/image-20240217085739265.png)

**逻辑结构（Logical Structure）**：

- 逻辑结构是指**数据对象中数据元素之间的相互关系**。它包括线性结构、树形结构和图状结构三种基本逻辑结构。
  - **线性结构**：元素之间存在**一对一**的关系，如线性表、栈、队列等。
  - **树形结构**：元素之间存在**一对多**的关系，如树结构。
  - **图状结构**：元素之间存在**多对多**的关系，如图结构。  

 



## 第二章----线性表

### ==线性表的定义和特点==

线性表是一种常见的数据结构，它是由**零个或多个数据元素组成的有限序列**。线性表中的数据元素之间**存在一种顺序关系**，**每个元素都有且仅有一个直接前驱和一个直接后继**，除了**第一个元素没有直接前驱**，**最后一个元素没有直接后继**。

线性表的主要特点包括：

1. **有序性**：线性表中的元素是有序排列的，每个元素都有确定的位置。

2. **单一性**：线性表中的元素只能有一个直接前驱和一个直接后继。

3. **有限性**：线性表中的元素数量是有限的，不会无限增长。

4. **元素类型的统一性**：线性表中的元素类型可以是相同的，也可以是不同的，但通常情况下，同一个线性表中的元素类型是相同的。

5. **可变性**：线性表的长度是可以变化的，可以动态地增加或删除元素。

6. **抽象性**：线性表是一种抽象的数据结构，其具体实现可以有多种方式，如数组、链表等。

线性表是数据结构中最简单、最基本的一种，广泛应用于计算机科学和工程领域的各个方面。

![image-20240217090817323](数据结构第2周/image-20240217090817323.png)![image-20240217090936714](数据结构第2周/image-20240217090936714.png) ![image-20240217091346960](数据结构第2周/image-20240217091346960.png) 



### 案例引入

> 实现医院多显示的运算：实现两个多项式加，减，乘运算
>
>  ![image-20240217091635112](数据结构第2周/image-20240217091635112.png) 
>
> ![image-20240217091649293](数据结构第2周/image-20240217091649293.png) 

![image-20240217091743023](数据结构第2周/image-20240217091743023.png)



#### 稀疏多项式 

---

如果并不是每一项都有呢？也就是稀疏多项式就会非常的浪费空间

我们直接去存储就好了，下标不再对应指数了/

![image-20240217092056595](数据结构第2周/image-20240217092056595.png)

![image-20240217092222036](数据结构第2周/image-20240217092222036.png)  

![image-20240217095310342](数据结构第2周/image-20240217095310342.png)   



#### 问题引入

---

遍历完成后c的数组大小应该为多少？？？

最少为[0,7]

数据c多大合适呢？？？

所以发现数组的大小是动态的

用7的话可能会浪费空间，亦或者是不够存储

![image-20240217100335679](数据结构第2周/image-20240217100335679.png) 

引入**链式存储**

 ![image-20240217101139407](数据结构第2周/image-20240217101139407.png) 

---

算法实现？

####   链式存储

```c++

#include <iostream>
using namespace std;

// 定义多项式的节点结构
struct Node {
    int coef;
    int exp;
    Node* next;
    Node(int c, int e) : coef(c), exp(e), next(nullptr) {}
};
//int coef：表示多项式中该项的系数。
//int exp：表示多项式中该项的指数。
//Node* next：是一个指向下一个节点的指针，用于构建链表结构
class Polynomial {
private:
    Node* head;

public:
    Polynomial() : head(nullptr) {}

    // 插入新节点，按指数降序排列
    // 插入新节点，按指数升序排列
    // 插入新节点，按指数升序排列
    void insert(int coef, int exp) {
        Node* newNode = new Node(coef, exp);
        if (!head || exp < head->exp) {
            newNode->next = head;
            head = newNode;
        }
        else if (exp == head->exp) {
            head->coef += coef; // 合并相同指数项的系数
            delete newNode; // 删除不再需要的新节点
        }
        else {
            Node* current = head;
            while (current->next && current->next->exp <= exp) {
                if (current->next->exp == exp) {
                    current->next->coef += coef; // 合并相同指数项的系数
                    delete newNode; // 删除不再需要的新节点
                    return;
                }
                current = current->next;
            }
            newNode->next = current->next;
            current->next = newNode;
        }
    }



    // 多项式相加
    Polynomial add(const Polynomial& poly) {
        Polynomial result;
        Node* p1 = head;
        Node* p2 = poly.head;

        while (p1 && p2) {
            if (p1->exp > p2->exp) {
                result.insert(p1->coef, p1->exp);
                p1 = p1->next;
            }
            else if (p1->exp < p2->exp) {
                result.insert(p2->coef, p2->exp);
                p2 = p2->next;
            }
            else {
                int sum = p1->coef + p2->coef;
                if (sum != 0) {
                    result.insert(sum, p1->exp);
                }
                p1 = p1->next;
                p2 = p2->next;
            }
        }

        while (p1) {
            result.insert(p1->coef, p1->exp);
            p1 = p1->next;
        }

        while (p2) {
            result.insert(p2->coef, p2->exp);
            p2 = p2->next;
        }

        return result;
    }

    // 显示多项式
    void display() {
        Node* current = head;
        bool firstTerm = true;
        while (current) {
            if (current->coef != 0) {
                if (!firstTerm) {
                    cout << " + ";
                }
                cout << current->coef;
                if (current->exp != 0) {
                    cout << "x";
                    if (current->exp != 1) {
                        cout << "^" << current->exp;
                    }
                }
                firstTerm = false;
            }
            current = current->next;
        }
        cout << endl;
    }
};

int main() {
    Polynomial poly1;
    poly1.insert(7, 0);
    poly1.insert(3, 1);
    poly1.insert(9, 8);
    poly1.insert(5, 17);

    Polynomial poly2;
    poly2.insert(8, 1);
    poly2.insert(22, 7);
    poly2.insert(-9, 8);

    cout << "First polynomial: ";
    poly1.display();
    cout << "Second polynomial: ";
    poly2.display();

    Polynomial result = poly1.add(poly2);
    cout << "Sum of polynomials: ";
    result.display();

    return 0;
}

```







---

> 这个 `Polynomial` 类实现了一个多项式，并提供了插入、相加和显示多项式的功能。让我们逐个解释类中的各个部分：
>
> 1. **私有成员变量 `head`**：
>    - `head` 是一个**指向多项式链表头部的指针**。链表的每个节点表示多项式的一个项。
>
> 2. **公有成员函数 `Polynomial()` 构造函数**：
>    - 这是一个默认构造函数，用于创建一个空的多项式链表。它将链表的头指针 `head` 初始化为 `nullptr`，表示链表为空。
>
> 3. **公有成员函数 `insert(int coef, int exp)`**：
>    - 这个函数用于插入新节点到多项式链表中。节点包含了系数 `coef` 和指数 `exp`。
>    - 插入新节点时，首先检查链表是否为空，或者新节点的指数小于链表头节点的指数，如果是则将新节点作为头节点。
>    - 如果新节点的指数等于链表头节点的指数，则合并相同指数的项的系数，然后删除新节点。
>    - 否则，遍历链表，找到合适的位置将新节点插入到链表中，并确保链表按照指数升序排列。
>
> 4. **公有成员函数 `add(const Polynomial& poly)`**：
>    - 这个函数用于将两个多项式相加，并返回一个新的多项式作为结果。
>    - 它遍历两个多项式链表，依次对相同指数的项进行系数相加，并将结果插入到新的多项式链表中。
>    - 最后，将剩余的节点插入到结果多项式中。
>
> 5. **公有成员函数 `display()`**：
>    - 这个函数用于显示多项式的内容。
>    - 它遍历多项式链表，并按照标准形式输出每一项的系数和指数，同时忽略系数为零的项和指数为零的幂次。
>
> 这个 `Polynomial` 类提供了一种方便的方式来表示和操作多项式，并且能够按照指数升序排列插入新节点，同时合并相同指数的项。

#### 图书信息管理系统

![image-20240217104234260](数据结构第2周/image-20240217104234260.png)

![image-20240217104425925](数据结构第2周/image-20240217104425925.png)

学生信息管理，商品，员工。。。。。都可以用法同样的办法

#### ==图书顺序表==

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Book {
    int id;         // 图书编号
    string title;   // 书名
    double price;   // 价格
};

class BookList {
private:
    vector<Book> books; // 图书顺序表（数组）

public:
    // 添加图书
    void addBook(int id, const string& title, double price) {
        books.push_back({id, title, price});
    }

    // 删除图书
    void deleteBook(int id) {
        auto it = find_if(books.begin(), books.end(), [id](const Book& b) { return b.id == id; });
        if (it != books.end()) {
            books.erase(it);
        }
    }

    // 修改图书信息
    void updateBook(int id, const string& newTitle, double newPrice) {
        auto it = find_if(books.begin(), books.end(), [id](const Book& b) { return b.id == id; });
        if (it != books.end()) {
            it->title = newTitle;
            it->price = newPrice;
        }
    }

    // 查询图书信息
    Book* findBook(int id) {
        auto it = find_if(books.begin(), books.end(), [id](const Book& b) { return b.id == id; });
        if (it != books.end()) {
            return &(*it);
        }
        return nullptr; // 没找到返回nullptr
    }

    // 对图书按编号排序
    void sortBooksById() {
        sort(books.begin(), books.end(), [](const Book& b1, const Book& b2) { return b1.id < b2.id; });
    }

    // 统计图书数量
    int countBooks() {
        return books.size();
    }

    // 显示图书信息
    void displayBooks() {
        for (const auto& book : books) {
            cout << "ID: " << book.id << ", Title: " << book.title << ", Price: " << book.price << endl;
        }
    }
};

int main() {
    // 创建图书顺序表类对象
    BookList bookList;

    // 添加图书
    bookList.addBook(101, "Book1", 10.99);
    bookList.addBook(102, "Book2", 20.99);
    bookList.addBook(103, "Book3", 15.99);

    // 显示所有图书信息
    cout << "All books:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 查询图书信息
    int idToFind = 102;
    cout << "Finding book with ID " << idToFind << ":" << endl;
    Book* foundBook = bookList.findBook(idToFind);
    if (foundBook) {
        cout << "Book found: ID " << foundBook->id << ", Title: " << foundBook->title << ", Price: " << foundBook->price << endl;
    } else {
        cout << "Book with ID " << idToFind << " not found." << endl;
    }
    cout << endl;

    // 删除图书信息
    int idToDelete = 101;
    cout << "Deleting book with ID " << idToDelete << ":" << endl;
    bookList.deleteBook(idToDelete);
    cout << "After deletion:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 修改图书信息
    int idToUpdate = 103;
    cout << "Updating book with ID " << idToUpdate << ":" << endl;
    bookList.updateBook(idToUpdate, "Updated Book3", 25.99);
    cout << "After update:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 对图书按编号排序
    cout << "Sorting books by ID:" << endl;
    bookList.sortBooksById();
    cout << "After sorting:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 统计图书数量
    cout << "Number of books: " << bookList.countBooks() << endl;

    return 0;
}

```

> 这段代码是一个简单的图书信息管理系统的实现，使用了图书顺序表（数组）作为存储结构。
>
> 1. **定义图书结构体 `Book`**：
>    - `Book` 结构体包含了图书的三个基本信息：编号 `id`、书名 `title` 和价格 `price`。
>
> 2. **定义图书顺序表类 `BookList`**：
>    - `BookList` 类用于管理图书信息的数组。
>    - 私有成员变量 `books` 是一个 `vector<Book>` 类型的数组，用于存储图书信息。
>
> 3. **添加图书 `addBook` 方法**：
>    - `addBook` 方法用于向图书顺序表中添加新的图书信息。
>    - 它接受图书的编号、书名和价格作为参数，创建一个 `Book` 结构体对象并将其添加到数组末尾。
>
> 4. **删除图书 `deleteBook` 方法**：
>    - `deleteBook` 方法用于删除指定编号的图书信息。
>    - 它接受一个图书编号作为参数，使用 `find_if` 算法查找具有相同编号的图书，并使用 `erase` 方法从数组中删除该图书。
>
> 5. **修改图书信息 `updateBook` 方法**：
>    - `updateBook` 方法用于修改指定编号图书的书名和价格。
>    - 它接受图书编号、新书名和新价格作为参数，使用 `find_if` 算法找到具有相同编号的图书，然后更新其书名和价格。
>
> 6. **查询图书信息 `findBook` 方法**：
>    - `findBook` 方法用于查询指定编号的图书信息。
>    - 它接受一个图书编号作为参数，使用 `find_if` 算法查找具有相同编号的图书，并返回该图书的指针。
>
> 7. **按编号排序 `sortBooksById` 方法**：
>    - `sortBooksById` 方法用于按照图书编号对图书顺序表进行排序。
>    - 它使用 `sort` 算法对数组中的图书信息进行排序，排序依据是图书编号。
>
> 8. **统计图书数量 `countBooks` 方法**：
>    - `countBooks` 方法用于统计图书顺序表中的图书数量。
>    - 它返回数组的大小，即图书的数量。
>
> 9. **显示图书信息 `displayBooks` 方法**：
>    - `displayBooks` 方法用于显示图书顺序表中的所有图书信息。
>    - 它遍历数组中的每一本图书，并将其编号、书名和价格输出到标准输出流。
>
> 10. **主函数 `main`**：
>     - 在 `main` 函数中，首先创建了一个 `BookList` 类对象 `bookList`，用于管理图书信息。
>     - 然后，通过调用 `addBook` 方法向图书顺序表中添加了几本图书。
>     - 接着，分别执行了查询、删除、修改、排序和计数等操作，并输出了各种操作的结果。
>
> 这样，这段代码实现了一个简单的图书信息管理系统，可以通过各种基本操作来管理图书信息，包括添加、删除、修改、查询、排序和计数等功能。









#### ==图书链表==

```c++
#include <iostream>
#include <string>
using namespace std;

struct Book {
    int id;         // 图书编号
    string title;   // 书名
    double price;   // 价格
    Book* next;     // 指向下一本书的指针
};

class BookList {
private:
    Book* head; // 指向链表头部的指针

public:
    // 构造函数，初始化链表为空
    BookList() : head(nullptr) {}

    // 添加图书
    void addBook(int id, const string& title, double price) {
        Book* newBook = new Book{ id, title, price, nullptr };
        if (!head) {
            head = newBook;
        }
        else {
            Book* current = head;
            while (current->next) {
                current = current->next;
            }
            current->next = newBook;
        }
    }

    // 删除图书
    void deleteBook(int id) {
        if (!head) {
            return; // 链表为空，无需操作
        }
        if (head->id == id) {
            Book* temp = head;
            head = head->next;
            delete temp;
            return;
        }
        Book* prev = head;
        Book* current = head->next;
        while (current) {
            if (current->id == id) {
                prev->next = current->next;
                delete current;
                return;
            }
            prev = current;
            current = current->next;
        }
    }

    // 修改图书信息
    void updateBook(int id, const string& newTitle, double newPrice) {
        Book* current = head;
        while (current) {
            if (current->id == id) {
                current->title = newTitle;
                current->price = newPrice;
                return;
            }
            current = current->next;
        }
    }

    // 查询图书信息
    Book* findBook(int id) {
        Book* current = head;
        while (current) {
            if (current->id == id) {
                return current;
            }
            current = current->next;
        }
        return nullptr; // 没找到返回nullptr
    }

    // 对图书按编号排序
    void sortBooksById() {
        if (!head || !head->next) {
            return; // 链表为空或只有一个节点，无需排序
        }
        Book* current = head;
        Book* nextNode = nullptr;
        Book tempNode{ 0, "", 0.0, nullptr };
        while (current) {
            nextNode = current->next;
            while (nextNode) {
                if (current->id > nextNode->id) {
                    tempNode = *current;
                    current->id = nextNode->id;
                    current->title = nextNode->title;
                    current->price = nextNode->price;
                    nextNode->id = tempNode.id;
                    nextNode->title = tempNode.title;
                    nextNode->price = tempNode.price;
                }
                nextNode = nextNode->next;
            }
            current = current->next;
        }
    }

    // 统计图书数量
    int countBooks() {
        int count = 0;
        Book* current = head;
        while (current) {
            count++;
            current = current->next;
        }
        return count;
    }

    // 显示图书信息
    void displayBooks() {
        Book* current = head;
        while (current) {
            cout << "ID: " << current->id << ", Title: " << current->title << ", Price: " << current->price << endl;
            current = current->next;
        }
    }
};

int main() {
    // 创建图书链表管理类对象
    BookList bookList;

    // 添加图书
    bookList.addBook(101, "Book1", 10.99);
    bookList.addBook(102, "Book2", 20.99);
    bookList.addBook(103, "Book3", 15.99);

    // 显示所有图书信息
    cout << "所有图书信息" << endl;
    bookList.displayBooks();
    cout << endl;

    // 所有图书信息
    int idToFind = 102;
    cout << "Finding book with ID " << idToFind << ":" << endl;
    Book* foundBook = bookList.findBook(idToFind);
    if (foundBook) {
        cout << "Book found: ID " << foundBook->id << ", Title: " << foundBook->title << ", Price: " << foundBook->price << endl;
    }
    else {
        cout << "Book with ID " << idToFind << " not found." << endl;
    }
    cout << endl;

    // 删除图书信息
    int idToDelete = 101;
    cout << "Deleting book with ID " << idToDelete << ":" << endl;
    bookList.deleteBook(idToDelete);
    cout << "After deletion:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 修改图书信息
    int idToUpdate = 103;
    cout << "Updating book with ID " << idToUpdate << ":" << endl;
    bookList.updateBook(idToUpdate, "Updated Book3", 25.99);
    cout << "After update:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 排序图书信息
    cout << "Sorting books by ID:" << endl;
    bookList.sortBooksById();
    cout << "After sorting:" << endl;
    bookList.displayBooks();
    cout << endl;

    // 统计图书数量
    cout << "Number of books: " << bookList.countBooks() << endl;

    return 0;
}


```

> 这段代码实现了一个简单的图书信息管理系统，使用了**链表**作为存储结构。
>
> 1. **定义图书结构体 `Book`**：
>    - `Book` 结构体包含了图书的三个基本信息：编号 `id`、书名 `title` 和价格 `price`。
>    - `Book` 结构体还包含了一个指向下一本书的指针 `next`，用于构建链表结构。
>
> 2. **定义图书链表类 `BookList`**：
>    - `BookList` 类用于管理图书信息的链表。
>    - 私有成员变量 `head` 是一个指向链表头部的指针。
>
> 3. **构造函数 `BookList()`**：
>    - 构造函数用于初始化链表为空，即将 `head` 指针置为 `nullptr`。
>
> 4. **添加图书 `addBook` 方法**：
>    - `addBook` 方法用于向图书链表中添加新的图书信息。
>    - 它接受图书的编号、书名和价格作为参数，创建一个 `Book` 结构体对象并将其添加到链表末尾。
>
> 5. **删除图书 `deleteBook` 方法**：
>    - `deleteBook` 方法用于删除指定编号的图书信息。
>    - 它遍历链表，找到具有指定编号的图书节点，并删除该节点。
>
> 6. **修改图书信息 `updateBook` 方法**：
>    - `updateBook` 方法用于修改指定编号图书的书名和价格。
>    - 它遍历链表，找到具有指定编号的图书节点，并更新其书名和价格。
>
> 7. **查询图书信息 `findBook` 方法**：
>    - `findBook` 方法用于查询指定编号的图书信息。
>    - 它遍历链表，找到具有指定编号的图书节点，并返回该节点的指针。
>
> 8. **排序图书信息 `sortBooksById` 方法**：
>    - `sortBooksById` 方法用于按照图书编号对图书链表进行排序。
>    - 它使用冒泡排序算法对链表中的图书信息进行排序，排序依据是图书编号。
>
> 9. **统计图书数量 `countBooks` 方法**：
>    - `countBooks` 方法用于统计图书链表中的图书数量。
>    - 它遍历链表，并计算链表中的节点个数。
>
> 10. **显示图书信息 `displayBooks` 方法**：
>     - `displayBooks` 方法用于显示图书链表中的所有图书信息。
>     - 它遍历链表，依次输出每本图书的编号、书名和价格。
>
> 11. **主函数 `main`**：
>     - 在 `main` 函数中，首先创建了一个 `BookList` 类对象 `bookList`，用于管理图书信息。
>     - 然后，通过调用 `addBook` 方法向图书链表中添加了几本图书。
>     - 接着，分别执行了查询、删除、修改、排序和计数等操作，并输出了各种操作的结果。
>



#### 小结

> 1. 线性表中数据元素的类型可以是简单类型，也可以是复杂类型
>
> 2. 许多实际应用问题锁设计的基本操作有很大的相似性，可以类比！
>
> 3. 从具体应用中抽象出共性的逻辑结构和基本操作
>
>    然后实现其存储结构和基本操作

### 线性的类型定义

![image-20240217151246583](数据结构第2周/image-20240217151246583.png) 

线性表的初始化

+ InitList(&L)

  结果：构造一个空的线性表

+ DestoryList(&L)

  初始条件：线性表已存在

  操作结果：销毁线性表L，在内存中已经不存在了

+ ClearLit(&L)

  初始条件：线性表L已存在

  操作结果：将线性表L充值为空表，空表

+ ListEmpty(L)

  初始条件：线性表L已经存在

  操作结果：如果线性表L为空表，就返回True，否则返回False

+ ListLength(L)

  初始条件：线性表L已经存在

  操作结果：返回线性表L中的数据元素个数

+ GetElem(L,i,&e)

  初始条件：线性表L已经存在`1<=i<=ListLength(L)`

  操作结果：用e返回线性表L中第i个数据元素的值

+ LocateElem(L,e,compare())

  初始条件：线性表L已经存在，compare()是数据元素判断函数

  操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这压根的数据元素不存在则返回0

+ PriorElem(L,cur_e,&pre_e)

  初始条件：线性表L已经存在

  操作结果：若cur_e是L的数据元素，切不是第一个，则用pre_e返回她的全区，否则操作失败，pre_e无效

+ NextElem(L,cur_e,&next_e)

  初始条件:线性表L已经存在

  操作结果：若cur_e是L的数据元素，切不是第最后个，则用next_e返回她的后记，否则操作失败，next_e无意义

+ ListInsert(&L,i,e)

  初始条件:线性表L已经存在`1<=i<=ListLength(L)+1`

  操作结果：在L的第i个位置之前插入新的数据元素e，L的长度加一

  ![image-20240217152738084](数据结构第2周/image-20240217152738084.png)

+ ListDelete(&L,i,&e)

  初始条件：线性表L已经存在`1<=i<=ListLength(L)`

  操作结果：删除L的第i个数据元素，并且用e返回其值，L的长度减一

  ![image-20240217153108524](数据结构第2周/image-20240217153108524.png)  

+ `ListTraverse(&L,visited())`

  初始条件:线性表L已经存在

  操作结果：依次对线性表中每个元素调用visited()

![image-20240217153130198](数据结构第2周/image-20240217153130198.png) 



> 在计算机内，线性表有两种基本的存储结构
>
> 顺序存储结构和链式存储结构

### ==线性表的顺序表示和实现==

#### 线性表的存储表示

线性表的顺序标识又称为**顺序存储结构**或**顺序映像**

顺序存储定义：把**逻辑上相邻**的数据元素存储在**物理上相邻**的存储单元中的存储结构

![image-20240217153502638](数据结构第2周/image-20240217153502638.png) 

#### 顺序存储结构



依次存储，地址连续，没有空出存储单元

地址不连续：中间存在空的存储单元，那么她就不是线性表顺序存储结构

![image-20240217153629674](数据结构第2周/image-20240217153629674.png) 



#### 顺序表中元素存储位置的计算

![image-20240217153838395](数据结构第2周/image-20240217153838395.png) 

#### 线性表的顺序存储结构的图示

![image-20240217154112439](数据结构第2周/image-20240217154112439.png)

![image-20240217154328131](数据结构第2周/image-20240217154328131.png) 



#### 多项式的顺序存储结构类型定义

![image-20240217154648228](数据结构第2周/image-20240217154648228.png)



#### 图书表的顺序存储结构类型定义

![image-20240217154725233](数据结构第2周/image-20240217154725233.png)



#### 补充：元素类型说明

![image-20240217155443047](数据结构第2周/image-20240217155443047.png)

 ![image-20240217155535833](数据结构第2周/image-20240217155535833.png)



##### C++的动态存储分配

![image-20240217171654453](数据结构第2周/image-20240217171654453.png)



##### c++中的参数传递



 ![image-20240217171731532](数据结构第2周/image-20240217171731532.png)







##### 操作算法中用到的预定义常量和类型

![image-20240218133525498](数据结构第2周/image-20240218133525498.png) 

#### 线性表的顺序存储表示

![image-20240218132611032](数据结构第2周/image-20240218132611032.png) 

#### 顺序表示意图

![image-20240218133244311](数据结构第2周/image-20240218133244311.png) 

![image-20240218133238075](数据结构第2周/image-20240218133238075.png) 

指向结构体的指针可以用->去访问结构体的成员等价*结构.成员



#### ==线性表的基本操作==

 ![image-20240218133453700](数据结构第2周/image-20240218133453700.png) 



##### 线性表的初始化

![image-20240218133743614](数据结构第2周/image-20240218133743614.png) 

if(L.elem为false)也就是内存分配出现异常，就exit

##### 销毁线性表& 清空线性表

![image-20240219140459603](数据结构第2周/image-20240219140459603.png)

> 销毁是释放对应的内存空间
>
> 清空是仅仅清空线性表的存储信息



##### 线性表的长度&线性表是否为空

![image-20240219140610877](数据结构第2周/image-20240219140610877.png) 

##### 顺序表的取值

逻辑下标和物理下标的差值为1

---

获取L[i]对应L[i-1]

[0,length]其他情况为异常情况

![image-20240219140905393](数据结构第2周/image-20240219140905393.png)

复杂度分析:

> 语句执行一次：复杂度为C(常量)
>
> 所以就体现到了顺序表的查询(访问)的方便
>
> 后面的链式存储就不一样了...

 

##### 顺序表的查找操作

###### 按值查找

![image-20240219141240593](数据结构第2周/image-20240219141240593.png) 

![image-20240219141646898](数据结构第2周/image-20240219141646898.png)

![image-20240219142930065](数据结构第2周/image-20240219142930065.png) 

>  复杂度分析：时间复杂度
>
> ?								基本操作：L.elem[i]==e执行多少次？
>
> 执行的次数[1,length]
>
>  平均需要执行(1+2+3+4+.....+length)/

###### ==平均查找长度==

![image-20240219143059909](数据结构第2周/image-20240219143059909.png)

![image-20240219143816289](数据结构第2周/image-20240219143816289.png)   

##### ==顺序表的插入==

![image-20240219144639481](数据结构第2周/image-20240219144639481.png) 

![image-20240219144626578](数据结构第2周/image-20240219144626578.png) 

![PixPin02-19_14-44-23](数据结构第2周/PixPin02-19_14-44-23.gif)

![PixPin02-19_14-45-54](数据结构第2周/PixPin02-19_14-45-54.gif)

---

![image-20240219144810126](数据结构第2周/image-20240219144810126.png) 

也就是让新的元素来做L[i]后面的往后推

> 可以插入的位置
>
> 假设有n个元素
>
> 那么可以插入在[0,n]的位置
>
> a[n+1]就插不了
>
> ---
>
> 算法思想：**判断插入位置i是否合法。**
>
> **判断顺序表的存储空间是否已满**，若已满返回 ERROR
>
> 将第n至第i位的元素依次向后移动一个位置，空出第i个位置。
>
> 将要插入的新元素e放入第i个位置。
>
> 表长加1，插入成功返回OK
>
> ![image-20240219151849713](数据结构第2周/image-20240219151849713.png)  

![image-20240219151950521](数据结构第2周/image-20240219151950521.png)



算法分析:
 ![image-20240219152107202](数据结构第2周/image-20240219152107202.png)

![image-20240220112420483](数据结构第2周/image-20240220112420483.png)

平均时间复杂度为O(n)  

----



##### 顺序表的删除

![image-20240220110259297](数据结构第2周/image-20240220110259297.png) 

![PixPin02-20_11-01-38](数据结构第2周/PixPin02-20_11-01-38.gif)

![PixPin02-20_11-02-09](数据结构第2周/PixPin02-20_11-02-09.gif)

![image-20240220111653259](数据结构第2周/image-20240220111653259.png)

![image-20240220111736033](数据结构第2周/image-20240220111736033.png) 

> 算法思想：
>
> 判断删除位置i是否合法(合法值为1≤i≤n)
>
> 将欲删除的元素保留在e中
>
> 将第i+1至第n位的元素依次向前移动一个位置
>
> 表长减1，删除成功返回OK

---

算法分析：

![image-20240220111824954](数据结构第2周/image-20240220111824954.png)![image-20240220112616308](数据结构第2周/image-20240220112616308.png)

**平均时间复杂度为O(n)** 



#### 顺序表的特点

 ![image-20240220112900629](数据结构第2周/image-20240220112900629.png)

 ![image-20240220112914137](数据结构第2周/image-20240220112914137.png)

![image-20240220113008554](数据结构第2周/image-20240220113008554.png) ![image-20240220113215691](数据结构第2周/image-20240220113215691.png) 

### ==线性表的链式表示和实现==

#### 线性表的链式表示1

![image-20240318130934532](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318130934532.png)

![image-20240318131111783](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131111783.png) 

![image-20240318131422898](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131422898.png) 

#### 线性表的链式表示2

![image-20240318131536090](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131536090.png) 

#### 头指针，节点，首元节点，头节点

![image-20240318132126895](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318132126895.png)

![image-20240318173514657](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318173514657.png)  

> 1. **头指针（Head Pointer）**：链表中的**头指针是指向链表的第一个节点的指针**。它是链表的入口，通过头指针可以访问整个链表。如果链表为空，则头指针指向空（null）。
> 2. **节点（Node）**：**节点是链表中的基本单元，它包含数据（通常是一个值）和一个指向下一个节点的指针。**
> 3. **首元节点（First Node）**：也称为头节点（Header Node），在某些情况下，它可以指代链表中的第一个真实节点，即不包含链表头信息的第一个节点。有时候，人们会在链表的头部添加一个额外的节点，作为头节点，这个头节点不存储有效数据，只是为了方便操作而存在。
> 4. **头节点（Header Node）**：有时候，特别是在一些高级数据结构中，会在链表的头部添加一个额外的节点，作为头节点。这个头节点不存储有效数据，只是为了方便操作而存在，例如，它可以用来记录链表的长度或者其他元信息。在这种情况下，头指针指向的就是这个头节点。
>
> 
>
> 当链表中存在头节点时，头指针指向的是头节点所包含的数据元素，而不是跳过头节点直接指向第一个存储数据元素的节点。这样设计可以确保头指针可以直接访问链表中的第一个数据元素，包括头节点所存储的数据元素。
>
> **头节点是一种在链表头部额外添加的节点，通常不存储有效数据，只用来记录链表的元信息。**

![image-20240318133352161](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318133352161.png) 

![image-20240318131621492](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131621492.png) 

#### 链表的示意图

##### 带/不带头节点的单链表

![image-20240318132410542](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318132410542.png) 

![image-20240318131654202](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131654202.png) 

##### 单链表&存储结构&例子

###### 单链表

单链表（Singly Linked List）：单链表是一种数据结构

+ **每个节点包含一个指向下一个节点的指针**

+ **最后一个节点的指针指向空（null）**。

+ 单链表**只能从头节点开始沿着指针方向遍历到尾节点。**

![image-20240318131827736](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131827736.png)

![image-20240318173632406](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318173632406.png)

---

###### 存储结构

![image-20240318174245450](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318174245450.png)

![image-20240318174453233](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318174453233.png)  

ElemType就是元素的类型

----

###### 例子   

![image-20240318174714261](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318174714261.png)

###### 提升

 统一 链表的操作 

![image-20240318182437709](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318182437709.png) 

##### 双链表&存储结构

双链表（Doubly Linked List）：双链表是一种数据结构、

+ **其中每个节点包含两个指针**，一个指向前一个节点，一个指向后一个节点。
+ 这样的设计允许在双链表中进行**双向遍历**，**可以从头部或尾部开始遍历链表。**

![image-20240318131936327](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318131936327.png) 

##### 循环链表

循环链表（Circular Linked List）：循环链表是一种链表

+ **其中最后一个节点指向第一个节点，形成一个闭环**。

+ 这意味着在循环链表中，可以从任何节点开始遍历整个链表

![image-20240318132018873](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318132018873.png)



#### 单链表基本操作的实现

##### 单链表的初始化

c/c++

 ![image-20240318183038768](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318183038768.png) 

```c++
Status InitList_L(LinkList &L)
{
	L=new LNode;//分配空间c++
    //c版本L=(LinkList)malloc(sizeof(LNode));
	
	L->next=NULL;//赋空值
	
	return OK;
}
```

##### 判断链表是否为空

==判断头节点指针与是否为空==

![image-20240318183314568](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318183314568.png) 

##### 单链表的销毁

==从头指针开始，依次释放所有的节点的空间==

头节点的空间也被释放了

![image-20240318184004353](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318184004353.png)

![image-20240318184127490](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318184127490.png)  

```c++
Status DestoryList_L(LinkList &L)
{
	Lnode *p;//LinkList p;
	while(L)//判断条件是如果L或者P不为null
	{
		p=L;//先把现在要释放的位置给p
		L=L->next;//让L指向下一个节点
		delete p;//释放对应的空间
	}
	return OK;
}
```

##### 清空链表

链表还存在

 ![image-20240318185432312](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318185432312.png)  

```c++
Status ClearList(LinkList &L)
{
	Lnode *p,*q;//LinkList p,q;
	p=L->next;
	while(p)
	{
		q=p->next;
		delete(p);
		p=q;
	}
	L->next=NULL;//头节点指针域w

}
```

##### 链表的表长

==从首元节点开始，依次计数所有节点==

![image-20240319153916653](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240319153916653.png) 

![image-20240319153912089](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240319153912089.png) 

```c++
int ListLength_L (LinkList L)
{
	LinkList p;
	int count=0;
	p=L->next;
	while(p)
	{
		p=p->next;
		count++;
	}
	return count;
}
```

##### ==小结==

![image-20240319154902879](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240319154902879.png)

##### 取第i个元素值

顺序表直接是逻辑顺序L->emem[i-1]

==随机存取==

链表如何取第i个元素呢

**边数边判断**

![image-20240319155500248](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240319155500248.png)

![image-20240401121746381](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401121746381.png)  

> 1．从第1个结点（L->next）顺链扫描，用指针p指向当前扫描到的结点，p初值p = L->next。
>
> 2.j做计数器，累计当前扫描过的结点数，j初值为1
>
> 3.当 p 指向扫描到的下一结点时，计数器j加1
>
> 4.当j == i时,，p所指的结点就是要找的第i个结点。 

```c++
Status GetElem_L(LinkList L,int i,ElemType &e)
{
    int count=0;
    LinkList p;
    p=L->next;
    while(p)
    {
        if(count==i)
        {
            e=p->data;
        }
        p=p->next;
        count++;
        
    }
}
```



#####  按值查找

![image-20240320123033539](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240320123033539.png) 

![image-20240320123023119](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240320123023119.png)

----

![image-20240320123427464](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240320123427464.png) 

```c
Status LocateElem_L(LinkList L,ElemType &e)
{
    LinkList p;
    p=L->next;//让p指向首元结点
    while(p)
    {
        if(p->data==i)
        {
            return p;
        }
        p=p->next;//更新p
    }
}
```





##### 插入节点

> 顺序不能反！

插入：在第i个结点前插入新结点

![image-20240401112759459](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401112759459.png)

算法实现

![image-20240401113149960](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401113149960.png)   



##### 删除节点

![image-20240401120646645](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401120646645.png)

![image-20240401121857826](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401121857826.png) 





##### ==查找，插入，删除，算法效率分析==

查找

> 跟找的位置有关系，如果是第一个元素就是O(1)
>
> 最差就是最后才找到
>
> 所以是O(n)

插入和删除:

> 不用移动元素，只修改指针就ok了一般情况下时间复杂度为O(1)
>
> 但是如果在单链表中尽心前插或者删除操作，就要从头
>
> 找到前驱节点
>
> 时间复杂度为O(n);

 ![image-20240401123643497](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401123643497.png) 





##### 单链表的建立-头插法(前插法)

> 从一个空表开始，重复读入数据;
>
> 生成新结点，将读入数据存放到新结点的数据域中
>
> 从最后一个结点开始，依次将各结点插入到链表的前端

![image-20240401123919012](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401123919012.png) 

![image-20240401124434955](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401124434955.png) 

![image-20240401124605682](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401124605682.png)  



##### 单链表的建立-尾插法(后插法)

![image-20240401125354838](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401125354838.png) 

> 借助尾指针
>
> 尾指针一直指向最后一个节点

算法实现

时间复杂度是O(n)

![image-20240401125540327](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240401125540327.png) 





####  问题

##### 如何表示空表？

![image-20240318132519698](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318132519698.png) 

##### 链表设置头节点的好处

![image-20240318133456920](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318133456920.png)

##### 链表的特点

![image-20240318133702172](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318133702172.png)

顺序表是随机存取法。  

![image-20240318133727015](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240318133727015.png) 

#### 循环链表

##### 概述

> 循环链表（Circular Linked List）是一种**链表数据结构**，其中**最后一个节点的指针指向第一个节点，形成一个环形结构**。与普通链表不同的是，**循环链表没有一个明确的终止节点，因为它的最后一个节点指向第一个节点，所以可以无限地遍历。**
>
> 循环链表的优点之一是**可以快速地在链表中插入和删除元素**，因为不需要遍历整个链表找到末尾节点。但缺点是可能会导致出现无限循环的情况，因此需要小心处理循环链表的操作，以防止陷入无限循环。
>
> 在循环链表中，通常有两种节点结构：
>
> 1. **单向循环链表（Singly Circular Linked List）**：每个节点包含一个数据项和一个指向下一个节点的指针。最后一个节点的指针指向第一个节点。
>    
> 2. **双向循环链表（Doubly Circular Linked List）**：每个节点包含一个数据项、一个指向下一个节点的指针和一个指向前一个节点的指针。最后一个节点的后继指针指向第一个节点，第一个节点的前驱指针指向最后一个节点。
>

![image-20240407123242266](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407123242266.png) 

![image-20240407123314721](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407123314721.png) 

##### ==循环链表主要用的就是尾指针！==

why？

![image-20240407123754734](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407123754734.png) 

##### 合并循环链表

![image-20240407125309731](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407125309731.png)   

![image-20240407125418748](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407125418748.png)  

##### 算法描述

![image-20240407125525701](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407125525701.png) 







#### 双链表

#####  概述

> 双向链表（Doubly Linked List）是一种**链表数据结构**，**每个节点包含两个指针，一个指向前一个节点（前驱），另一个指向后一个节点（后继）。**相比于单向链表，**双向链表可以在节点间双向移动**，这使得在双向链表中可以**更方便地进行插入、删除、以及反向遍历等操作**。
>
> 以下是双向链表的基本特点：
>
> 1. **节点结构**：每个节点通常包含三个部分：
>    - 数据域：存储实际的数据。
>    - 前驱指针（prev）：指向前一个节点的指针。
>    - 后继指针（next）：指向后一个节点的指针。
>
> 2. **头节点和尾节点**：双向链表通常有一个头节点和一个尾节点，它们分别位于链表的起始和结束处。**头节点的前驱指针指向空（null），尾节点的后继指针也指向空**。
>
> 3. **灵活性**：双向链表具有较高的灵活性，因为每个节点都可以向前和向后移动。这使得在链表中插入或删除节点时更加高效，因为不需要像单向链表那样重新定位前一个节点。
>
> 4. **逆序遍历**：由于每个节点都有一个指向前一个节点的指针，因此可以方便地从尾部向头部遍历链表，这在某些场景下很有用。
>

![image-20240407125910237](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407125910237.png) 

##### 结构表示

```c++
typedef struct DuLNoder
{
    Elemtype data;
    struct DuLNode *prior,*next;
} DuLNode, *DuLinkList;
```

##### 图示

![image-20240407130041407](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407130041407.png) 

![image-20240407130047685](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407130047685.png) 

空表: 

![image-20240407130126561](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407130126561.png) 

##### 双向循环链表

![image-20240407130304084](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407130304084.png) 

空表

![image-20240407130319844](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407130319844.png) 



##### 结构的对称性

`p->prior->next=p=p->next->prior`

![image-20240407130456859](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407130456859.png)  



##### 双向链表的插入

![image-20240407132132549](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407132132549.png) 

 ![image-20240407132102313](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407132102313.png) 

算法描述

> 双向链表修改四个指针
>
> 单向链表修改两个指针

![image-20240407132147777](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407132147777.png) 





##### 双向链表的删除 

![image-20240407132647530](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407132647530.png) 

![image-20240407133140740](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407133140740.png) 

算法描述

![image-20240407133159058](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407133159058.png) 

O(n)删除是O(1)但是查找是O(n)



#### 单链表、循环链表和双向链表的时间效率比较

 ![image-20240407133353675](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240407133353675.png) 

### 顺序表和链表的比较

#### 优缺点比较

 ![image-20240408101705787](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408101705787.png) 

#### 存储密度

![image-20240408101458297](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408101458297.png) 

一般地，**存储密度越大，存储空间的利用率就越高。**

显然，顺序表的存储密度为1（100%），而链表的存储密度小于1。 

#### 比较

![image-20240408101723775](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408101723775.png) 

### 线性表的应用

#### 线性表的合并

![image-20240408102906438](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408102906438.png)  

##### 算法描述

![image-20240408102945824](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408102945824.png)  

#### 有序表的合并

![image-20240408103222539](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408103222539.png) 

##### 有序表的合并(顺序表实现)

######   算法描述

 ![image-20240408105039639](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408105039639.png) 

###### 算法实现

![image-20240408104327192](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408104327192.png) ![image-20240408105324231](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408105324231.png)  

![image-20240408105010492](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408105010492.png) 

##### 有序表的合并(链表实现)





###### 算法描述

![image-20240408122741377](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408122741377.png) 

![image-20240408122718337](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408122718337.png) 

######  算法实现

La和Lb的节点都访问一次就是O(总节点数)

![image-20240408123752397](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408123752397.png)

不需要额外的空间空间复杂度为(O(1)) 

![image-20240408123652752](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408123652752.png)   

### 案例分析与实现

#### 一元多项式的运算

 ![image-20240408124101687](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408124101687.png) 

##### 顺序表实现

![image-20240408124217789](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408124217789.png) 

##### 具体实现

> 待完善



#### 稀疏多项式的运算

##### 线性表实现

![image-20240408124518137](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408124518137.png) 

![image-20240408124836198](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408124836198.png)

##### 链式存储实现

因为顺序存储不能动态分配

![image-20240408124936471](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408124936471.png) 

升级节点

##### 多项式实现

![image-20240408125327947](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408125327947.png)

![image-20240408125144606](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408125144606.png) 

##### 多项式相加实现

![image-20240408130809407](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408130809407.png) 

![image-20240408130653107](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408130653107.png) 

##### 具体实现

> 待完善 





#### 图书信息管理系统



##### 顺序表实现

![image-20240408131127615](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408131127615.png) 

![image-20240408130959488](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408130959488.png) 





##### 链表实现

![image-20240408131137702](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408131137702.png) 

![image-20240408131014293](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC2%E5%91%A8/image-20240408131014293.png) 



















