# 数据的运算-查找

## 相关术语

### 查找表

查找表是由**同一类型的数据元素**（或记录）构成的**集合**。由于“集合”中的数据元素之间存在着松散的关系，因此查找表是一种应用灵便的结构。 

---

### 查找

根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或(记录)

---

### 关键字

+ 主关键字：可唯一地标识一个记录的关键字是主关键字；

+ 次关键字：反之，用以识别若干记录的关键字是次关键字

---

### 查找成功

查找――根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或(记录)

+ 若查找表中存在这样一个记录，则称‘查找成功’查找结果给出整个记录的信息，或指示该记录在查找表中的位置; 
+ 否则称查找不成功查找结果给出“空记录”或"空指针"

---

### 查找目的

+ 查询某个‘特定的’数据元素是否在

+ 查找表中检索某个‘特定的’数据元素的各种属性;

+ 在查找表中插入一个数据元素；

+ 删除查找表中的某个数据元素。

所以查找可以说是增删改的基础

---

### 查找表的分类

+ 静态查找表

  仅作“查询”(检索)操作的查找表

+ 动态查找表

  作“插入"和“删除”操作的查找表有时在查询之后，还需要将“查询”结果为“不在查找表中”的数据元素插入到查找表中；或者，从查找表中删除其其“查询”结果为在查找表中”的数据元素，此类表为动态查找表。

---

### ASL平均查找长度

关键字的平均比较次数

![image-20240517131652343](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240517131652343.png) 

---

**查找的方法取决于查找表的结构**

即表中数据元素是依何种关系组织在一起的。由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时，若无规律可循，只能对集合中的元素加以辨认直至找到为止。

而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点。

为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系

研究查找表的**各种组织方法**及其**查找过程的**实施





## 线性表的查找

### 顺序查找

#### 应用范围

+ 顺序表或线性链表表示的静态查找表

+ 表内元素之间无序

在顺序表中查找值为key的数据元素

从头开始或者从尾开始

```c
typedef struct {
    KeyType key;
    // 其他字段
} ElemType;

typedef struct {
    ElemType* R;
    int length;
} SSTable;

int Search_Seq(SSTable ST, KeyType key) {
    // 若成功返回其位置信息，否则返回0
    for (int i = ST.length; i >= 1; --i) {
        if (ST.R[i].key == key) {
            return i;  // 找到了，返回位置信息 i
        }
    }
    return 0;  // 没找到，返回 0
}

```

#### 改进

改进：使用“哨兵”来优化顺序查找的关键在于避免**每次循环检查是否超出数组边界**。可以**将待查关键字放在数组的第一个位置（即表头）**，然后**从后向前查找**。在这种情况下，**不需要在循环内部检查是否越界。**

```c
typedef int KeyType; // 假设 KeyType 是 int 类型
typedef struct {
    KeyType key;
    // 其他字段
} ElemType;

typedef struct {
    ElemType* R; // 数组指针
    int length; // 数组长度
} SSTable;

int Search_Seq(SSTable ST, KeyType key) {
    // 将待查关键字放入表头作为哨兵
    ST.R[0].key = key;

    // 从后向前查找
    int i;
    for (i = ST.length; ST.R[i].key != key; --i);
    //注意分号！！！！

    // 如果找到，返回位置；如果没找到（即 i == 0），返回 0
    return i;
}

```

> 1. **哨兵设置**：`ST.R[0].key = key;` 将待查找的关键字放入表头位置，即 `R[0]`。
> 2. **查找过程**：从表的末尾开始查找，一直到找到关键字为止，或者直到查找到表头（`R[0]`）。
> 3. **返回值**：如果找到关键字，返回其位置；如果未找到（即最后查找到 `R[0]` ），则返回 0。

当 ST.length 较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。

#### 算法分析

![image-20240517143900395](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240517143900395.png)

1. **最优情况**：

   - 如果待查找的关键字在数组的最后一个位置上，那么只需要进行一次比较，时间复杂度为 O(1)。

2. **最坏情况**：

   - 如果待查找的关键字不存在于数组中，那么需要遍历整个数组。由于使用了哨兵，即使在最坏的情况下也会有 *n* 次比较，其中 *n* 是数组的长度，时间复杂度为 O*(*n)。

3. **平均情况**：

   `ASL=(1+2+3...+n)/n=(n+1)/2`

   - 假设待查找的关键字在数组中的任何一个位置出现的概率是相同的，平均情况下需要检查一半的元素。平均时间复杂度为O(n/2)=*O*(*n*)。

> - 需要额外设置哨兵，虽然对空间的影响可以忽略不计，但在某些情况下可能会增加实现的复杂度。
> - 对于已经有序的数组，可以使用更高效的查找算法（如二分查找），顺序查找的效率并不高。

#### 讨论

1.记录的查找概率不相等时如何提高查找效率？

查找表存储记录原则按查找概率高低存储：

+ 1）查找概率越高，比较次数越少
+ 2）查找概率越低，比较次数较多

---

2.记录的查找概率无法测定时如何提高查找效率？

方法按查找概率动态调整记录顺序：

+ 1）在每个记录中设一个访问频度域
+ 2）始终保持记录按非递增有序的次序排列
+ 3）每次查找后均将刚查到的记录直接移至表头

#### 特点

实现简单、适用无序数据和小规模数据集

但由于其**线性时间复杂度**，对于大型数据集或对查找效率要求较高的应用场景并不适用。

优点：算法简单，逻辑次序无要求，且不同存储结构均适用

缺点：ASL太长时间效率太低





---

### 折半查找(二分查找)

二分查找（Binary Search）是一种在有序数组中查找目标值的高效算法，其时间复杂度为`O(logn)`

二分查找的前提是数据集必须是`有序的`。以下是二分查找的实现，包`括迭代版本`和`递归版本`

折半查找：每次将待查记录所在区间缩小一半

前提条件：已经排好序

#### 非递归版本

```c++
int BinarySearch(int arr[], int size, int key) {
    int left = 0;
    int right = size - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止溢出

        if (arr[mid] == key) {
            return mid;  // 找到目标值，返回其索引
        } else if (arr[mid] < key) {
            left = mid + 1;  // 在右半部分继续查找
        } else {
            right = mid - 1;  // 在左半部分继续查找
        }
    }

    return -1;  // 未找到目标值，返回 -1
}
```

![image-20240517145343671](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240517145343671.png) 

```c++
#include <iostream>
using namespace std;
int BinarySearch(int arr[], int size, int key);
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(arr[0]);
    int key;
    cout<<"输入要查找的key"<<endl;
    cin>>key;
    int result = BinarySearch(arr, size, key);
    if (result != -1) {
        std::cout << "成功找到，下标为" << result << std::endl;
    } else {
        std::cout << "没找到！" << std::endl;
    }
    return 0;
}
int BinarySearch(int arr[], int size, int key) {
    int left = 0;
    int right = size - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止溢出

        if (arr[mid] == key) {
            return mid;  // 找到目标值，返回其索引
        } else if (arr[mid] < key) {
            left = mid + 1;  // 在右半部分继续查找
        } else {
            right = mid - 1;  // 在左半部分继续查找
        }
    }

    return -1;  // 未找到目标值，返回 -1
}
```

![image-20240517150045139](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240517150045139.png) 

#### 递归版本

```c++
#include <iostream>
using namespace std;
int BinarySearchRecursive(int arr[], int left, int right, int key) {
    if (left > right) {
        return -1;  // 基本情况：未找到目标值
    }

    int mid = left + (right - left) / 2;  // 防止溢出

    if (arr[mid] == key) {
        return mid;  // 找到目标值，返回其索引
    } else if (arr[mid] < key) {
        return BinarySearchRecursive(arr, mid + 1, right, key);  // 在右半部分继续查找
    } else {
        return BinarySearchRecursive(arr, left, mid - 1, key);  // 在左半部分继续查找
    }
}
int main() {
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int size = sizeof(arr) / sizeof(arr[0]);
    int key;
    cin>>key;
    int result;
    result = BinarySearchRecursive(arr, 0, size - 1, key);
    if (result != -1) {
        std::cout << "成功找到，下标为" << result << std::endl;
    } else {
        std::cout << "没找到！" << std::endl;
    }

    return 0;
}


```





#### 判定树

在二分查找中，判定树可以用来描述查找过程中所有可能的比较和分支情况。

判定结构:

> - **节点**：每个节点表示一次比较操作，具体来说，是当前搜索范围的中间元素与目标值之间的比较。
>
> - 分支
>
>   每个分支表示比较操作的结果，通常有两条分支：
>
>   - 一条分支表示目标值小于中间元素，将搜索范围缩小到左半部分。
>   - 另一条分支表示目标值大于中间元素，将搜索范围缩小到右半部分。

举例：假设我们有一个长度为 8 的有序数组 [*a*0,*a*1,*a*2,*a*3,*a*4,*a*5,*a*6,*a*7] 要进行二分查找，目标值为 `key`。判定树如下：

```json
                            a_3
                          /     \
                      a_1         a_5
                    /   \        /    \
                 a_0     a_2  a_4      a_6
                                             \
                                              a_7
```

- 每个节点表示中间元素的比较。
- 每个分支表示比较结果后的决策路径。

> - 判定树的高度决定了算法的时间复杂度。
> - 对于一个包含 n* 个元素的数组，二分查找的判定树是一棵完全二叉树，其高度为log2*n*。
> - 因此，二分查找的时间复杂度为 O*(log*n*)，对应于判定树的高度。













#### 算法性能

##### `时间复杂度分析`

![二分查找时间复杂度](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png)

![image-20240517152238455](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240517152238455.png) 

1. **最优情况**：
   - 最优情况下，目标值位于数组的**中间位置。只需要一次比较即可找到目标值**，时间复杂度为 `O(1)`
2. **最坏情况**：
   - 最坏情况下，目标值可能**位于数组的最末端或者不存在于数组中**。每次查找将数组的搜索范围缩小一半，因此时间复杂度为 `O(logn)`，其中 *n* 是数组的长度。
3. **平均情况**：
   - 平均情况下，二分查找需要的比较次数也大约是 `O(logn)`。 

![image-20240517152159392](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240517152159392.png) 





##### ASL

![二分查找ASL](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEASL.png)

##### `空间复杂度分析`

1. **迭代版本**：

   - 迭代版本的二分查找使用恒定的额外空间来存储索引变量 `left`、`right` 和 `mid`，因此空间复杂度为 `O(1)`。

2. **递归版本**：

   - 递归版本的二分查找每次递归调用都会在调用栈上增加一个新的栈帧，栈帧的最大深度为 log??log*n*，因此空间复杂度为 `O(logn)`。

   1. **递归深度**：

      - 二分查找在每次递归调用时，将数组的搜索范围缩小一半。
      - 每次递归调用时，参数 `left` 和 `right` 会调整以缩小搜索范围，直到 `left > right`，此时递归结束。
      - 最坏情况下（即目标值不存在或者是最末尾元素时），递归的深度为对数级别，即 log?2?log2*n*，其中 n* 是数组的长度。

   2. **栈空间消耗**：

      - 每次递归调用都会在调用栈上增加一个新的栈帧，包含当前函数的局部变量、参数、返回地址等信息。
      - 在递归的最深层次上，栈帧的最大深度为log2*n*。
      - 因此，递归版本的二分查找所需的栈空间是log2*n* 个栈帧。

   3. **空间复杂度**：

      - 栈帧的数量决定了递归算法的空间复杂度。
      - 由于递归的深度为 log2*n*，递归版本的二分查找的空间复杂度为 O*(log*n*)。

      假设数组的长度为 16（*n*=16）：

      - 初始调用：`BinarySearchRecursive(arr, 0, 15, key)`，范围 `[0, 15]`。
      - 第一次递归：`BinarySearchRecursive(arr, 8, 15, key)` 或 `BinarySearchRecursive(arr, 0, 7, key)`，范围缩小到一半。
      - 第二次递归：`BinarySearchRecursive(arr, 12, 15, key)` 或 `BinarySearchRecursive(arr, 8, 11, key)` 或更小的范围。
      - 继续递归，直到 `left > right`，结束递归。

   递归的最大深度为 log216=4，即递归调用最多会进行 4 次，每次调用消耗一个栈帧。





#### 特点

- **必须有序**：二分查找只能应用于有序数据集。
- **数据存储在连续内存中**：需要随机访问支持。



折半查找优点：效率比顺序查找高

折半查找缺点：只适用于有序表且限于顺序存储结构（对线性链表无效



### 分块查找



#### 什么是分块查找

分块查找（Block Search）是一种基于分块技术的查找算法，主要用于在**有序数组或列表中查找特定元素**。它将数据分成若干块，**每块内部的数据是有序的，然后通过在块之间和块内进行查找来提高查找效率**。

分块查找的基本步骤如下：

1. **分块**：将数据**分成若干大小相同或接近相同的块**，块间有序，块内无序；就是分块有序；

   若则第块中所有记录的关键字均大于第/块中的最大关键字。

2. **建立索引表**：为每个块建立索引，通常是每块的**最大（或最小）元素**。索引表也是有序的。

3. **块间查找**：**在索引表中查找，确定目标元素所在的块**。

4. **块内查找**：在确定的块内进行**线性查找或二分查找**。

块内是无序顺序查找；有序就可以二分查找；

![image-20240521104902308](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240521104902308.png) 



#### 分块查找的查找效率

查找效率：ASL=L<sub>b</sub>+L<sub>w</sub>

> 假设有一个包含 *n* 个元素的数组，每个块的大小大约为 s元素。我们将其分成 n/s 个块。索引表的大小为n/s 。

---

L<sub>b</sub>:对索引表查找的ASL`log2(n/s)`

L<sub>w</sub>:对块内查找的ASL=`s/2`

![image-20240521111904104](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240521111904104.png) 

---

 优点：(插入和删除比较容易，无需进行大量移动。

缺点：要增加一个索引|表的存储空间并对初始索引|表进行排序运算。

适用情况：如果线性表既要快速查找又经常动态变化，则可采用分块查找。

### 三种查找比较

| 查找方法/属性      | 顺序查找        | 折半查找        | 分块查找                       |
| ------------------ | --------------- | --------------- | ------------------------------ |
| ASL                | (n+1)/2最大     | log?(n+1)-1最小 | 依赖于块的大小和查找方法(中间) |
| 最大最小中间表结构 | 无              | 有              | 有                             |
| 表结构             | 无序表,有序表   | 有序表          | 分块有序                       |
| 存储结构           | 顺序表/线性链表 | 顺序表          | 顺序表/线性链表                |

## 树表的查找

### 动态查找表

> 动态查找表（Dynamic Search Table）是一类**允许在查找过程中插入和删除操作的数据结构**。常见的动态查找表包括平衡二叉搜索树（如AVL树、红黑树）、B树以及散列表（哈希表）。以下是对这些动态查找表的介绍以及其时间复杂度分析。

![image-20240521122519286](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240521122519286.png) 



### 二叉排序树

二叉排序树（Binary Sort Tree）又称为二叉搜索树、二叉查找树

二叉排序树（Binary Search Tree，简称 BST）是一种常见的二叉树数据结构，用于高效地进行查找、插入和删除操作。

二叉排序树（Binary Search Tree，简称 BST）是一种特殊的二叉树，其定义如下：

1. 如果它的左子树不为空，则左子树上所有节点的值均小于根节点的值。
2. 如果它的右子树不为空，则右子树上所有节点的值均大于等于根节点的值。
3. 它的左右子树本身也是二叉排序树。

这种特性确保了 BST 的查找、插入和删除等操作都能够在较高效率下进行。

#### 二叉排序树的判断

  ![image-20240521123643534](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240521123643534.png) 

#### 中序遍历的结果

二叉排序树的性质：**中序遍历非空的二叉排序树所得到的数据元素序列**是一个**按关键字排列的递增有序序列**

![image-20240521124220311](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240521124220311.png) 

#### 查找的实现

`开始标志`

- **根节点为空**：如果二叉排序树为空树，那么查找过程结束，返回找不到的标志（例如 `NULL` 或 `-1` 等）。
- **根节点不为空**：从根节点开始查找。

`结束标志`

- **找到节点**：如果找到目标节点，返回该节点的指针。
- **未找到节点**：如果遍历完整棵树（或子树），且未找到目标节点，则返回找不到的标志。

`查找过程`

1. **从根节点开始**：
   - 如果目标值等于当前节点的值，则返回当前节点。
   - 如果目标值小于当前节点的值，则继续在当前节点的左子树中查找。
   - 如果目标值大于当前节点的值，则继续在当前节点的右子树中查找。
2. **移动规则**：
   - 如果目标值小于当前节点的值，移动到左子节点。
   - 如果目标值大于当前节点的值，移动到右子节点。
   - 如果目标值等于当前节点的值，查找结束，返回当前节点。
3. **结束条件**：
   - 如果当前节点为 `NULL`，表示已经到达叶子节点的子节点（不存在的节点），查找结束，返回找不到的标志。
   - 如果找到目标节点，返回该节点的指针。

示例

假设有如下的二叉排序树：

```markdown
		5
       / \
      3   7
     / \ / \
    2  4 6  8
```

我们来查找节点值为 4 的节点：

```markdown
从根节点 5 开始查找。
1. 目标值 4 小于当前节点 5，移动到左子节点 3。
   - 目标值 4 大于当前节点 3，移动到右子节点 4。
     - 找到目标节点值为 4，返回该节点。
```

查找完成，找到了节点值为 4 的节点。

##### 递归实现

---

```c
#include <stdio.h>
#include <stdlib.h>

// 定义树节点结构体
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 创建新节点
struct TreeNode* createNode(int val) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
// 递归查找
struct TreeNode* recursiveSearch(struct TreeNode* root, int key) {
    // 基本情况：根节点为空或根节点的值等于要查找的值
    if (root == NULL || root->val == key)
        return root;
    
    // 要查找的值小于根节点的值，在左子树中查找
    if (key < root->val)
        return recursiveSearch(root->left, key);
    
    // 要查找的值大于根节点的值，在右子树中查找
    return recursiveSearch(root->right, key);
}
int main() {
    // 创建一个示例二叉排序树
    struct TreeNode* root = createNode(50);
    root->left = createNode(30);
    root->right = createNode(70);
    root->left->left = createNode(20);
    root->left->right = createNode(40);
    root->right->left = createNode(60);
    root->right->right = createNode(80);

    // 查找值为 40 的节点
    int key = 40;
    struct TreeNode* result = recursiveSearch(root, key);
    if (result != NULL) {
        printf("找到节点: %d\n", result->val);
    } else {
        printf("未找到节点\n");
    }

    return 0;
}

```

##### 非递归实现

```c
#include <stdio.h>
#include <stdlib.h>

// 定义树节点结构体
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 创建新节点
struct TreeNode* createNode(int val) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
// 非递归查找
struct TreeNode* iterativeSearch(struct TreeNode* root, int key) {
    while (root != NULL && root->val != key) {
        if (key < root->val)
            root = root->left;
        else
            root = root->right;
    }
    return root;
}
int main() {
    // 创建一个示例二叉排序树
    struct TreeNode* root = createNode(50);
    root->left = createNode(30);
    root->right = createNode(70);
    root->left->left = createNode(20);
    root->left->right = createNode(40);
    root->right->left = createNode(60);
    root->right->right = createNode(80);

    // 查找值为 40 的节点
    int key = 40;
    struct TreeNode* result = iterativeSearch(root, key);
    if (result != NULL) {
        printf("找到节点: %d\n", result->val);
    } else {
        printf("未找到节点\n");
    }

    return 0;
}

```



#### 二叉排序树的查找分析

![image-20240522112344290](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522112344290.png) 

含有**n个结点的二叉排序树**的**平均查找长度**和**树的形态**有关

![image-20240522114334111](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522114334111.png) 

如何提高形态不均衡的二叉排序树的查找效率？

平衡化处理

#### 二叉排序树的操作

##### 二叉排序树的递归插入/生成

> 1. **从根节点开始**：
>    - 如果树是空的，那么插入的节点作为根节点。
> 2. **比较当前节点的值与插入值**：
>    - 如果插入值小于当前节点的值：
>      - 如果当前节点的左子树为空，则将新节点插入到左子树位置。
>      - 如果当前节点的左子树不为空，则递归地将新节点插入到左子树中。
>    - 如果插入值大于当前节点的值：
>      - 如果当前节点的右子树为空，则将新节点插入到右子树位置。
>      - 如果当前节点的右子树不为空，则递归地将新节点插入到右子树中。
> 3. **递归结束条件**：
>    - 当找到一个空位置（即当前节点的左子树或右子树为空）时，将新节点插入到该位置。

```c
#include <stdio.h>
#include <stdlib.h>

// 定义树节点结构体
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 创建新节点
struct TreeNode* createNode(int val) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}


// 插入新节点
struct TreeNode* insertNode(struct TreeNode* root, int val) {
    // 如果树为空，创建一个新节点作为根节点
    if (root == NULL) {
        return createNode(val);
    }

    // 否则， 
    if (val < root->val) {
        root->left = insertNode(root->left, val);
    } else if (val > root->val) {
        root->right = insertNode(root->right, val);
    }

    // 返回根节点（未改变）
    return root;
}
// 中序遍历
void inorderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->val);
        inorderTraversal(root->right);
    }
}
int main() {
    struct TreeNode* root = NULL;

    // 插入节点
    root = insertNode(root, 50);
    root = insertNode(root, 30);
    root = insertNode(root, 20);
    root = insertNode(root, 40);
    root = insertNode(root, 70);
    root = insertNode(root, 60);
    root = insertNode(root, 80);

    // 中序遍历输出树的节点
    printf("中序遍历结果: ");
    inorderTraversal(root);
    printf("\n");

    return 0;
}
在插入节点50、30、20、40、70、60、80
```

![image-20240522171521100](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522171521100.png) 

```makefile
      50
     /  \
   30    70
  /  \  /  \
 20  40 60  80
```

> 一个无序序列可通过构造二叉排序树而变成一个有序序列构造树的过程就是对无序序列进行排序的过程。

![image-20240522171823148](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522171823148.png)

>  插入的结点均为叶子结点故无需移动其他结点。相**当于在有序序列上插入记录而无需移动其他记录**。
>
> ---
>
> 不同插入次序的序列生成不同形态的二叉排序树
>
> ![image-20240522171959004](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522171959004.png) 



##### 二叉排序树的删除

要求 :

> 从二叉排序树中删除一个结点，不能把以该结点为根的子树都删去，只能删掉该结点，并且还应**保证删除后所得的二叉树仍然满足二叉排序树的性质不变**。
>
> ---
>
> 由于**中序遍历二叉排序树可以得到一个递增有序的序列**。那么，在二叉排序树中**删去一个结点相当于删去有序序列中的一个结**点。
>
> 将因删除结点而断开的二叉链表重新链接起 来
>
> 防止重新链接后树的高度增加



---

删除节点的三种情况

1. **删除叶节点**：

   - 直接删除该节点。

   ![image-20240522173315711](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522173315711.png) 

2. **删除只有一个子节点的节点**：

   - 让该节点的父节点指向其唯一的子节点。

   ![image-20240522173513538](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522173513538.png) 

3. **删除有两个子节点的节点**：

   - 找到该节点的中序**后继**（右子树中最小的节点）或中序**前驱**（左子树中最大的节点）。
   - 用中序后继或中序前驱的值替换该节点的值，然后**删除中序后继或中序前驱节点。**(`2的删除`)

   ![image-20240522173801417](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522173801417.png) 

```c
#include <stdio.h>
#include <stdlib.h>

// 定义树节点结构体
struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
};

// 创建新节点
struct TreeNode* createNode(int val) {
    struct TreeNode* newNode = (struct TreeNode*)malloc(sizeof(struct TreeNode));
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
// 插入新节点
struct TreeNode* insertNode(struct TreeNode* root, int val) {
    if (root == NULL) {
        return createNode(val);
    }
    if (val < root->val) {
        root->left = insertNode(root->left, val);
    } else if (val > root->val) {
        root->right = insertNode(root->right, val);
    }
    return root;
}
// 寻找最小值节点
struct TreeNode* findMin(struct TreeNode* node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

// 删除节点
struct TreeNode* deleteNode(struct TreeNode* root, int key) {
    if (root == NULL) {
        return root;
    }

    if (key < root->val) {
        root->left = deleteNode(root->left, key);
    } else if (key > root->val) {
        root->right = deleteNode(root->right, key);
    } else {
        // 找到要删除的节点
        if (root->left == NULL) {
            struct TreeNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            struct TreeNode* temp = root->left;
            free(root);
            return temp;
        }

        // 有两个子节点，找中序后继（右子树中最小节点）
        struct TreeNode* temp = findMin(root->right);
        root->val = temp->val;
        root->right = deleteNode(root->right, temp->val);
    }
    return root;
}
// 中序遍历
void inorderTraversal(struct TreeNode* root) {
    if (root != NULL) {
        inorderTraversal(root->left);
        printf("%d ", root->val);
        inorderTraversal(root->right);
    }
}
int main() {
    struct TreeNode* root = NULL;

    // 插入节点
    root = insertNode(root, 50);
    root = insertNode(root, 30);
    root = insertNode(root, 20);
    root = insertNode(root, 40);
    root = insertNode(root, 70);
    root = insertNode(root, 60);
    root = insertNode(root, 80);

    // 中序遍历输出树的节点
    printf("中序遍历结果: ");
    inorderTraversal(root);
    printf("\n");

    // 删除节点
    root = deleteNode(root, 20);  // 删除叶节点
    root = deleteNode(root, 30);  // 删除只有一个子节点的节点
    root = deleteNode(root, 50);  // 删除有两个子节点的节点

    // 中序遍历输出树的节点
    printf("删除后的中序遍历结果: ");
    inorderTraversal(root);
    printf("\n");

    return 0;
}

```

```markdown
删除20后的树
         50
        /  \
      30    70
       \   /  \
       40 60  80

删除30后的树
         50
        /  \
      40    70
           /  \
          60  80

删除50后的树
         60
        /  \
      40    70
              \
               80

```

---

![image-20240522175231115](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240522175231115.png) 







### 平衡二叉树

如何提高形态不均衡的二叉排序树的查找效率?

平衡二叉树AVL

#### AVL的定义

> 平衡二叉树(balanced binary tree)
>
> 又称`AVL树(`Adelson-Velskii and Landis)
>
> 一棵平衡二叉树或者是空树，或者是具有下列性质的二叉排序树：
>
> + **左**子树与右子树的**高度之差的绝对值小于等于1**
>
> + **左**子树和**右**子树也 是平衡二叉树。

为了方便起见，**给每个结点附加一个数字**，给出该结点左子树一右子树的高度差。

这个数字称为结点的**平衡因子（BF）** 

`平衡因子=结点左子树的高度－结点右子树的高度`

根据平衡二叉树的定义，平衡二叉树上**所有结点的平衡因子**只能是`1、0、或-1`。

![image-20240529143043061](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529143043061.png) 

> 对于一棵有n个结点的AVL树，其高度保持在O(log2n)数量级，ASL也保持在O(log2n)量级

#### 平衡二叉树

> 如果在一棵AVL树中插入一个新结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。

> 四种基本的旋转类型 
>
> 1. **单右旋 (Single Right Rotation, RR)**
> 2. **单左旋 (Single Left Rotation, LL)**
> 3. **左右旋 (Left-Right Rotation, LR)**
> 4. **右左旋 (Right-Left Rotation, RL)**

![image-20240529143846530](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529143846530.png) 

> 调整原则：1）**降低高度**2)**保持二叉排序树性质**
>
> 中序排序后中间的作为根节点！
>
> 仔细观察图就能发现规律

![image-20240529145344829](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529145344829.png) 

 ![image-20240529154153779](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529154153779.png) 

#### 例子

##### `RR调整`

![image-20240529151550760](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529151550760.png)

![image-20240529151325082](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529151325082.png)  

![PixPin05-29_15-11-35](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/PixPin05-29_15-11-35.gif)



##### `RL调整`

![image-20240529152354178](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529152354178.png) 

![image-20240529152333691](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529152333691.png) 

#### 例题

> 输入关键字序列(16，3，7，11，9，26，18，14，15)，给出构造AVL树的步骤。

![image-20240610175738986](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240610175738986.png) 

![image-20240610175725148](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240610175725148.png) 

![image-20240610175757868](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240610175757868.png) 

---

![image-20240610175819154](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240610175819154.png)

![image-20240610175843828](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240610175843828.png)  

![image-20240529153235107](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240529153235107.png) 





## 散列表哈希表的查找

### 散列表

散列表：关键字（Key）映射到表中的某个位置来实现快速查找。

![image-20240607161131926](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240607161131926.png) 

![image-20240607161338479](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240607161338479.png) 

> 优点：查找效率高
>
> 缺点：空间效率低!

### 散列表的相关术语

#### 散列方法

选取某个函数，依该函数按关键字计算元素的存储位置并按此存放;查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比，确定查找是否成功。



#### 散列函数

**散列函数（Hash Function）**

- 散列函数是将输入的关键字转化为散列表中一个位置的函数。



#### 冲突

冲突：不同的关键码映射到同一个散列地址key1≠key2, 但是H(key1)=H(key2)

![image-20240607161804671](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240607161804671.png) 

同义词：具有**相同函数值**的多个关键字





### 散列表的构造

**构造好的散列函数**

+ 所选函数尽可能简单，以便提高转换速度；
+ 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费。

制定一个好的解决冲突的方案

+ 查找时，如果从散列函数计算出的地址中查不到关键码，则应当依据解决冲突的规则，有规律地查询其它相关单元。

---

构造散列函数考虑的因素

+ 执行速度（即计算散列函数所需时间）
+ 关键字的长度
+ 散列表的大小
+ 关键字的分布情况
+ 查找频率

---

根据元素集合的特性构造

+ 要求一：n个数据原仅占用n个地址虽然散列查找是以空间换时间，但仍希望**散列的地址空间尽量小**
+ 要求二：无论用什么方法存储，的都是**尽量均匀地存放元素，以避免冲突**

有下列方法

1. **直接定址法**
2. 数字分析法
3. 平方取中法
4. 折叠法
5. **除留余数法**
6. 随机数法

#### **直接定址法**

`Hash(key) = a・key + b (a、b为常数)`

优点：以关键码key的某个线性函数值为散列地址，**不会产生冲突**。

缺点：**要占用连续地址空间空间效率低**

例：{100,300,500,700,800，900},散列函数 Hash(key)=key/100(a=1/100, b=0)

![image-20240611161516901](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611161516901.png) 



#### 除留余数法

`Hash(key)=key mod p(p是一个整数)`

关键：如何选取合适的p?

技巧 :  设**表长为m**，**取 p≤m且为质数**

例： {15, 23, 27, 38, 53, 61,70}

表长：7

散列函数` Hash(key)=key mod 7`

![image-20240611161723089](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611161723089.png) 





### 处理冲突

开放定址法（开地址法）

链地址法（拉链法）

再散列法（双散列函数法）

#### 开放地址法

![image-20240611162158797](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611162158797.png) 

##### 线性探测法

![image-20240611162131970](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611162131970.png) 

---

**	**

`关键码集为 {47, 7, 29, 11, 16, 92, 22, 8, 3}，散列为 m=11m = 11m=11；散列函数为 Hash(key)=key mod??11。拟用线性探测解决冲突。请构建散列表。`

> **计算每个关键码的散列值**：
>
> 47、7均是由散列函数得到的没有冲突的散列地址
>
> Hash(29)=7，散列地址有冲突，需寻找下一个空的散列地址:由H,=(Hash(29)+1) mod 11=8，散列地址8为空，因此将29存入
>
> 11、16、92均是由散列函数得到的没有冲突的散列地址;
>
> 另外，22、8、3同样在散列地址上有冲突，也是由H,找到空的散列地址的。
>
> **用线性探测解决冲突并构建散列表**：
>
> - 关键码 47 的散列值是 3，插入位置 3
> - 关键码 7 的散列值是 7，插入位置 7
> - 关键码 29 的散列值是 7，位置 7 被占用，线性探测找到位置 8
> - 关键码 11 的散列值是 0，插入位置 0
> - 关键码 16 的散列值是 5，插入位置 5
> - 关键码 92 的散列值是 4，插入位置 4
> - 关键码 22 的散列值是 0，位置 0 被占用，线性探测找到位置 1
> - 关键码 8 的散列值是 8，位置 8 被占用，线性探测找到位置 9
> - 关键码 3 的散列值是 3，位置 3 被占用，线性探测找到位置 6

| 位置     | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 关键码   | 11   | 22   |      | 47   | 92   | 16   | 3    | 7    | 29   | 8    |      |
| 散列值   | 0    | 0    |      | 3    | 4    | 5    | 3    | 7    | 7    | 8    |      |
| 是否冲突 |      | 是   |      |      |      |      | 是   |      | 是   | 是   |      |
| 查找次数 | 1    | 2    |      | 4    | 1    | 1    | 2    | 1    | 2    | 2    |      |

ASL=（1+1+4+1+1+1+2+2+2）/9

ASL=15/9

ASL≈1.67

##### 二次探测法

关键码集为 {47, 7, 29, 11, 16, 92, 22, 8, 3}

设散列函数为 `Hash(key) = key mod 11;`

` H = (Hash(key) + di) mod m`

其中 m 为散列表长度，m 要求是某个 4k+3 的质数；

di 为增量序列 {1^2, -1^2, 2^2, -2^2, …q^2}。 用线性探测解决冲突，构建散列表如下：

增量序列

` 1, -1, 4, -4, 9, -9, 16, -16, 25, -25`



> 关键码集为 {47, 7, 29, 11, 16, 92, 22, 8, 3}，散列函数为 Hash(key) = key mod 11。
>
> 散列表构建过程
>
> ---
>
> 1. 关键码 47 的散列值是 3，插入位置 3（查找步数 = 1）
> 2. 关键码 7 的散列值是 7，插入位置 7（查找步数 = 1）
> 3. 关键码 29 的散列值是 7，位置 7 被占用，二次伪随机探测找到位置 (7 + 1) mod 11 = 8（查找步数 = 2）
> 4. 关键码 11 的散列值是 0，插入位置 0（查找步数 = 1）
> 5. 关键码 16 的散列值是 5，插入位置 5（查找步数 = 1）
> 6. 关键码 92 的散列值是 4，插入位置 4（查找步数 = 1）
> 7. 关键码 22 的散列值是 0，位置 0 被占用，二次伪随机探测找到位置 (0 + 1) mod 11 = 1（查找步数 = 2）
> 8. 关键码 8 的散列值是 8，位置 8 被占用，二次伪随机探测找到位置 (8 + 1) mod 11 = 9（查找步数 = 2）
> 9. 关键码 3 的散列值是 3，位置 3 被占用，二次伪随机探测找到位置 (3 + 1) mod 11 = 4，然后位置 4 被占用，找到位置 (3 - 1) mod 11 = 2，插入位置2(查找步数= 3)
>
> ---
>
> 最终的散列表及相关信息
>
> | 位置   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
> | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | 关键码 | 11   | 22   | 3    | 47   | 92   | 16   |      | 7    | 29   | 8    |      |
> | 散列值 | 0    | 0    | 3    | 3    | 4    | 5    |      | 7    | 7    | 8    |      |
> | 冲突   | 否   | 是   | 是   | 否   | 否   | 否   |      | 否   | 是   | 是   |      |
> | 步数   | 1    | 2    | 3    | 1    | 1    | 1    |      | 1    | 2    | 2    |      |
>

---

##### 伪随机探测法

![image-20240611170400725](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611170400725.png) 

类似！

#### 链地址法（拉链法）

![image-20240611181255171](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611181255171.png) 

how to 创建

> Step1:取数据元素的关键字key，计算其散列函数值（地址）。若该地址对应的链表为空，则将该元素插入此链表；否则执行Step2解决冲突。
>
> Step2:根据选择的冲突处理方法，计算关键字key的下一个存储地址若该地址对应的链表为不为空，则利用链表的前插法或后插法将该元素插入此链表。 

优点：

+ 非同义词不会冲突，无“聚集”现象

+ 链表上结点空间动态申请，更适合于表长不确定的情况

---

> 链地址法（拉链法）来处理冲突，构建散列表。在链地址法中，每个散列槽都是一个链表，冲突的关键码将被插入到相应链表的末尾。
>
> 关键码集为 {47, 7, 29, 11, 16, 92, 22, 8, 3}，散列函数为 Hash(key) = key mod 11。
>
> 散列表构建过程
>
> ---
>
> 1. **初始化散列表**：创建一个长度为 11 的链表数组。
>
> 2. **插入关键码**：
>    - 关键码 47 的散列值是 3，插入位置 3（新链表节点：47）
>    - 关键码 7 的散列值是 7，插入位置 7（新链表节点：7）
>    - 关键码 29 的散列值是 7，位置 7 被占用，插入到链表末尾（链表变为：7 -> 29）
>    - 关键码 11 的散列值是 0，插入位置 0（新链表节点：11）
>    - 关键码 16 的散列值是 5，插入位置 5（新链表节点：16）
>    - 关键码 92 的散列值是 4，插入位置 4（新链表节点：92）
>    - 关键码 22 的散列值是 0，位置 0 被占用，插入到链表末尾（链表变为：11 -> 22）
>    - 关键码 8 的散列值是 8，位置 8 被占用，插入到链表末尾（链表变为：8）
>    - 关键码 3 的散列值是 3，位置 3 被占用，插入到链表末尾（链表变为：47 -> 3）
>
> ----
>
> 最终的散列表及相关信息
>
> | 位置 | 0        | 1    | 2    | 3       | 4    | 5    | 6    | 7       | 8    | 9    | 10   |
> | ---- | -------- | ---- | ---- | ------- | ---- | ---- | ---- | ------- | ---- | ---- | ---- |
> | 链表 | 11 -> 22 |      |      | 47 -> 3 | 92   | 16   |      | 7 -> 29 | 8    |      |      |
>

ASL=（1+2+1+2+1+1+1+2+1）/9



### 散列表的查找

![image-20240611182519780](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611182519780.png) 

#### 例题

![image-20240611185051707](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611185051707.png) 

#### 例题

![image-20240611185246396](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611185246396.png) 





#### 算法性能分析

+ 散列函数

+ 处理冲突的方法

+ 散列表的装填因子α

`・α=(表中填入的记录数/哈希表的长度)・`

α越大，表中记录数越多，说明表装得越满，发生冲突的可能性就越大，查找时比较次数就越多。

 ![image-20240611185812662](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC7%E5%91%A8/image-20240611185812662.png) 

#### 结论

散列表技术具有很好的平均性能，优于一些传统的技术

链地址法优于开地址法

除留余数法作散列函数优于其它类型函数 






### 动态查找表时间复杂度总结

| 数据结构 | 查找                               | 插入                               | 删除                               |
| -------- | ---------------------------------- | ---------------------------------- | ---------------------------------- |
| AVL树    | \(O(log n)\)                       | \(O(log n)\)                       | \(O(log n)\)                       |
| 红黑树   | \(O(log n)\)                       | \(O(log n)\)                       | \(O(log n)\)                       |
| B树      | \(O(log n)\)                       | \(O(log n)\)                       | \(O(log n)\)                       |
| B+树     | \(O(log n)\)                       | \(O(log n)\)                       | \(O(log n)\)                       |
| 哈希表   | \(O(1)\)（平均），\(O(n)\)（最坏） | \(O(1)\)（平均），\(O(n)\)（最坏） | \(O(1)\)（平均），\(O(n)\)（最坏） |
