# 这是数据结构第1周的内容



## 课前叮嘱

### 课程内容

![image-20240119112817074](数据结构第1周/image-20240119112817074.png) 

### 数据结构重要嘛？

**程序=数据结构+算法**

起着一个承上启下的核心地位。

![image-20240119113328355](数据结构第1周/image-20240119113328355.png) 



### 数据结构在计算机学科中的地位

![image-20240119113029668](数据结构第1周/image-20240119113029668.png) 

![image-20240119113128676](数据结构第1周/image-20240119113128676.png) 



### 这门课好学嘛

![image-20240119113433436](数据结构第1周/image-20240119113433436.png) 



### 怎么才能学好这门课呢？

学习数据结构是一个渐进的过程，不要急于求成。

通过不断练习和实践，你将能够更好地理解和应用数据结构的概念

切忌，眼高手低！

![image-20240119113632837](数据结构第1周/image-20240119113632837.png) 





## 第一章-绪论

### 数据结构的研究内容

用计算机来解决实际问题的过程。。。

> 1. 具体问题抽象为数学模型
>
>    分析问题：
>
>    提取操作对象
>
>    找出操作对象之间的联系
>
>    用数学语言描述---数据结构
>
> 2. 设计算法
>
> 3. 编译，调试，运行

![image-20240119113954737](数据结构第1周/image-20240119113954737.png) 

#### 例子

![image-20240119114154481](数据结构第1周/image-20240119114154481.png) 

#### 随着计算机的发展，越来越用于非数值的运算

![image-20240119114547309](数据结构第1周/image-20240119114547309.png)

![image-20240119115110645](数据结构第1周/image-20240119115110645.png) 

 ![image-20240119115205613](数据结构第1周/image-20240119115205613.png) 

求最短路径

![image-20240119115435358](数据结构第1周/image-20240119115435358.png)

#### 小结

![image-20240119115612695](数据结构第1周/image-20240119115612695.png) 

### 基本概念和术语

#### 数据

能输入计算机且能被计算机处理的

**数据（Data）**：

- 数据是对客观事物的符号表示，是所有能输入到计算机中并被计算机程序处理的符号集合。数据可以是数字、文字、声音、图像等。

![image-20240119152421722](数据结构第1周/image-20240119152421722.png) 

#### 数据元素&数据项

1. **数据元素（Data Element）**：
   - 数据元素是数据的最小单位，是对一个数据的描述。例如，一个整数、一个字符或一个实数可以是一个数据元素。
2. **数据项（Data Item）**：
   - 数据项是**组成数据元素的基本单位**，是一个数据元素中的一个最小部分。例如，在一个学生的数据元素中，姓名、学号、成绩等可以是数据项。

![image-20240119152658813](数据结构第1周/image-20240119152658813.png)

数据>数据元素>数据项 

#### 数据对象

数据对象是**具有相同性质的数据元素**的集合，是对一组数据元素的整体描述。一个数据对象可以是一个简单的数据元素，也可以是一个复杂的结构。

![image-20240119152922176](数据结构第1周/image-20240119152922176.png)

![image-20240119153045467](数据结构第1周/image-20240119153045467.png)  

![image-20240119153408487](数据结构第1周/image-20240119153408487.png)

#### ==数据结构：==

 ![image-20240119163623592](数据结构第1周/image-20240119163623592.png) ![image-20240119153500605](数据结构第1周/image-20240119153500605.png)![image-20240119154048062](数据结构第1周/image-20240119154048062.png)![image-20240119155159822](数据结构第1周/image-20240119155159822.png) 

![image-20240119163152767](数据结构第1周/image-20240119163152767.png) 

#### ==逻辑结构==

![image-20240119160603731](数据结构第1周/image-20240119160603731.png) 

**逻辑结构（Logical Structure）**：

- 逻辑结构是指**数据对象中数据元素之间的相互关系**。它包括线性结构、树形结构和图状结构三种基本逻辑结构。
  - **线性结构**：元素之间存在一对一的关系，如线性表、栈、队列等。
  - **树形结构**：元素之间存在一对多的关系，如树结构。
  - **图状结构**：元素之间存在多对多的关系，如图结构。 

---

数据结构中，线性关系是**一种数据元素之间存在一对一的关系**

每个元素都**最多有一个直接前驱和直接后继**。

这与非线性关系不同，非线性关系中元素之间的关系不是一对一的。

线性关系主要有两种基本结构：线性表和栈与队列。

1. **线性表（Linear List）**：
   - 线性表是一种最简单的数据结构，它是具有相同数据类型的 n 个数据元素的有限序列。线性表的两种存储结构分别是顺序存储结构和链式存储结构。
   - 顺序存储结构：元素在内存中连续存储，通过数组实现。访问元素的时间复杂度为 O(1)。
   - 链式存储结构：元素在内存中不必连续，通过指针相连。链表有单链表、双链表和循环链表等形式。

2. **栈（Stack）**：
   - 栈是一种特殊的线性表，它只允许在表的一端进行插入和删除操作，这一端称为栈顶。栈的特点是后进先出（Last In, First Out，LIFO）。
   - 栈的应用场景很多，比如函数调用的执行过程、表达式求值、括号匹配、浏览器的前进和后退等。

3. **队列（Queue）**：
   - 队列也是一种特殊的线性表，它允许在表的一端插入元素，而在另一端删除元素，这两端分别称为队尾和队头。队列的特点是先进先出（First In, First Out，FIFO）。
   - 队列的应用广泛，例如任务调度、广度优先搜索、打印队列等。

这些线性结构在数据结构中都有重要的应用，它们提供了基本的存储和操作方式，为许多算法和数据处理提供了基础。

| 特征       | 线性表                             | 栈                                    | 队列                               |
| ---------- | ---------------------------------- | ------------------------------------- | ---------------------------------- |
| 基本结构   | 有限序列的线性表                   | 具有一端限制的线性表                  | 具有两端限制的线性表               |
| 操作       | 插入、删除、查找                   | 入栈（Push）、出栈（Pop）             | 入队（Enqueue）、出队（Dequeue）   |
| 存储结构   | 顺序存储（数组）和链式存储（链表） | 顺序存储（数组）和链式存储（链表）    | 顺序存储（数组）和链式存储（链表） |
| 存取速度   | 取决于存储结构                     | 取决于存储结构                        | 取决于存储结构                     |
| 操作复杂度 | 插入/删除 O(n)，查找 O(1)          | 入栈/出栈 O(1)                        | 入队/出队 O(1)                     |
| 特殊性质   | 无                                 | 后进先出（LIFO）                      | 先进先出（FIFO）                   |
| 应用       | 通用结构，用于存储一组元素         | 函数调用、表达式求值、浏览器前进/后退 | 任务调度、广度优先搜索、打印队列等 |

---

##### 线性结构

![image-20240119155408009](数据结构第1周/image-20240119155408009.png) 

##### 非线性结构

人机对弈，一对多，多对多。。。

**数据元素之间存在一对多或多对多的关系**，与线性结构的一对一关系不同。

在非线性结构中，**数据元素之间的连接不仅仅是简单的前后关系，而可以是多样的形式**。两种主要的非线性结构是**树形结构和图状结构。**

1. **树形结构（Tree Structure）**：
   - **定义**：树形结构是一种层次关系的结构，其中一个元素称为根，其他元素按照层次关系划分为若干层次，每个元素都有唯一的前驱（父节点）和零个或多个后继（子节点）。
   
   - **关键概念**：
     - 根（Root）：树的顶端元素，没有父节点。
     - 节点（Node）：树中的元素。
     - 父节点（Parent）：一个节点的直接上层节点。
     - 子节点（Child）：一个节点的直接下层节点。
     - 叶子节点（Leaf）：没有子节点的节点。
     - 层次（Level）：根节点为第1层，其子节点为第2层，以此类推。
   
   - **示例**：文件系统、家谱、组织结构等。
   
2. **图状结构（Graph Structure）**：

   - **定义**：图状结构是由节点和边组成的集合，节点表示数据元素，边表示节点之间的关系。图可以分为有向图和无向图，有向图中边有方向，无向图中边没有方向。

   - **关键概念**：
     - 节点（Vertex）：图中的元素。
     - 边（Edge）：连接节点的线段，描述节点之间的关系。
     - 有向图（Directed Graph）：边有方向。
     - 无向图（Undirected Graph）：边没有方向。
     - 路径（Path）：由边连接的节点序列。
     - 环（Cycle）：路径形成一个环。

   - **示例**：社交网络、网络拓扑结构、城市交通网络等。

---

##### 逻辑结构的第二种划分

![image-20240119160527183](数据结构第1周/image-20240119160527183.png)

![image-20240119163331987](数据结构第1周/image-20240119163331987.png)  

#### ==存储结构（物理结构）==

![image-20240119163427377](数据结构第1周/image-20240119163427377.png)

![image-20240119163521191](数据结构第1周/image-20240119163521191.png)  

---

##### ==顺序存储结构==

> **顺序存储结构（Sequential Storage Structure）**：
>
> - **定义**：将**数据元素存储在一块连续的存储区域**中，通过**线性关系依次排列**，**元素在内存中的存储位置相邻**。
> - **特点**：
>   - 直观简单，适用于**元素个数固定或很少变化的情况**。
>   - 可以通过下标直接访问元素，**查找速度较快。**
> - **示例**：数组是顺序存储结构的一种典型实现。

![image-20240119162241153](数据结构第1周/image-20240119162241153.png) 

##### ==链式存储结构==

> **链式存储结构（Linked Storage Structure）**：
>
> - **定义**：链式存储结构是指**将数据元素存储在内存的任意位置**，**通过指针（链接）将相邻的元素连接在一起，形成一个链表。**
> - **特点**：
>   - 灵活，**适用于元素个数不固定、经常变化的情况**。
>   - **不需要预先分配存储空间，动态分配和释放内存**。
>   - **查找速度相对较慢，需要遍历链表。**
> - **示例**：单链表、双链表等是链式存储结构的实现。

![image-20240119162552243](数据结构第1周/image-20240119162552243.png)

存储一个元素的同时，还存储了下一个元素的位置![image-20240119162632058](数据结构第1周/image-20240119162632058.png) 

##### 索引存储结构

> **索引存储结构（Indexed Storage Structure）**：
>
> - **定义**：索引存储结构是在**数据元素和关键字之间建立一个索引表**，**索引表中的每个元素都包含关键字和指向实际数据元素的指针**。
> - **特点**：
>   - **加快查找速度，通过索引表先找到关键字，再根据指针找到实际数据。**
>   - 需要**额外的存储空间来存储索引表。**
> - **示例**：数据库中的B树、B+树等数据结构，以及某些文件系统的索引。

##### 散列存储结构

> **散列存储结构（Hashed Storage Structure）**：
>
> - **定义**：散列存储结构通过**散列函数将数据元素的关键字映射到一个地址**，**将数据元素存储在该地址的位置。**
> - **特点**：
>   - **高效的查找速度，通过散列函数直接计算存储位置。**
>   - 需要解决冲突问题，即**多个关键字映射到相同的散列地址。**
> - **示例**：**哈希表是散列存储结构的一种实现**。

#### 数据类型和抽象数据类型

##### 数据类型

![image-20240119164046369](数据结构第1周/image-20240119164046369.png) 

![image-20240119164247066](数据结构第1周/image-20240119164247066.png) 

![image-20240119164339871](数据结构第1周/image-20240119164339871.png) 

##### 抽象数据类型

> 抽象数据类型（Abstract Data Type，ADT）是一种数学模型
>
> **描述数据对象和定义在这些对象上操作的数学规则**。
>
> ==**就是对数据和操作进行了抽象**==
>
> 它将**数据的表示**和**操作****与实际的实现细节分离**，让用户可以通过操作来使用数据，而不必关心底层的实现。
>
> 1. **比喻成实物**：
>    - 想象一个抽象数据类型就像一台自动售货机。你知道如何使用售货机（通过按钮选择商品，投入硬币，等待商品出货），但你并不需要了解售货机内部的工作原理，比如商品的储存方式、货币的验证过程等。
>
> 2. **类比成自定义数据类型**：
>    - 创建一个抽象数据类型，比如`Student`，它有成员变量（数据）如姓名、年龄、学号等，以及成员函数（操作）如获取学生信息、修改年龄等。这个`Student`类就是一个抽象数据类型，可以使用它来表示学生，而不必关心它在内部是如何实现的。
>
> 3. **接口和实现的分离**：
>    - 你知道如何点击图标来打开一个应用，但你并不需要知道应用是如何在底层的操作系统中运行的。**这就是抽象数据类型的思想，用户只需要知道如何使用接口（操作），而不必关心实现的细节。**
>
> 4. **数学模型**：
>    - 将抽象数据类型看作一种数学模型，就像数学中的集合或者图。你知道集合有哪些操作（并、交、补等），但对于集合内部的实现并不关心。A
>
> 抽象数据类型就是一种**将数据和操作进行抽象**，**隐藏内部细节**，提供清晰的接口供用户使用的概念。这样的设计使得代码更易维护、扩展，同时让用户更专注于问题的逻辑而不是底层实现。

![image-20240119165146407](数据结构第1周/image-20240119165146407.png)



######  抽象数据类型的形式定义

![image-20240119165253220](数据结构第1周/image-20240119165253220.png)

![image-20240119165455237](数据结构第1周/image-20240119165455237.png)

![image-20240119165826287](数据结构第1周/image-20240119165826287.png)

​		

###### 抽象数据类型的定义

   ![image-20240119170344805](数据结构第1周/image-20240119170344805.png)

复数的定义：

![image-20240119170449466](数据结构第1周/image-20240119170449466.png) 

### 抽象数据类型的表现与实现

![image-20240120092923163](数据结构第1周/image-20240120092923163.png) 

类C语言（介于伪代码和C语言之间）的描述区别

#### 例1，抽象数据类型“复数”的实现

![image-20240120093238518](数据结构第1周/image-20240120093238518.png) 

#### 复习C语言的结构体和typedef

1. typedef

   `typedef` 是C语言中的一个关键字，用于为已存在的数据类型（包括基本数据类型和自定义数据类型）定义一个新的别名。这有助于提高代码的可读性和简化复杂的声明。

   `typedef` 的一些常见用法：

   1. 为基本数据类型定义别名

   ```c
   typedef int Integer;  // 为 int 类型定义别名 Integer
   typedef float RealNumber;  // 为 float 类型定义别名 RealNumber
   ```

   这样可以使用 `Integer` 代替 `int`，`RealNumber` 代替 `float`。

   2. 为结构体定义别名

   ```c
   typedef struct {
       int x;
       int y;
   } Point;  // 为匿名结构体定义别名 Point
   ```

   这样可以直接使用 `Point` 作为结构体类型的名称。

   3. 为指针定义别名

   ```c
   typedef int* IntPtr;  // 为 int 指针定义别名 IntPtr
   ```

   这样可以使用 `IntPtr` 作为 `int` 类型的指针的别名。

   4. 为函数指针定义别名

   ```c
   typedef void (*FunctionPointer)(int);  // 为接受 int 参数并返回 void 的函数指针定义别名 FunctionPointer
   ```

   这样可以使用 `FunctionPointer` 作为**函数指针类型**的名称。

   5. 为数组定义别名

   ```c
   typedef char String[50];  // 为字符数组定义别名 String
   ```

   这样可以使用 `String` 作为字符数组类型的名称。

2. struct的`.运算符`和`->运算符`

   当有一个结构体变量 `a` 时，你可以使用 `a.属性` 的形式来访问结构体的成员属性。

   有一个指向结构体 `a` 的同类型指针，你可以使用 `a->属性` 的形式来通过指针访问结构体的成员属性。

   **箭头运算符允许你通过指针直接访问结构体的成员。**

   ```c
   #include <stdio.h>
   
   // 定义结构体
   struct Point {
       int x;
       int y;
   };
   
   int main() {
       // 声明结构体变量并初始化
       struct Point p1 = {1, 2};
       
       // 声明指向结构体的指针，并将其指向 p1
       struct Point *ptr = &p1;
       
       // 使用箭头运算符访问结构体成员
       printf("Coordinates: (%d, %d)\n", ptr->x, ptr->y);
       
       return 0;
   }
   
   ```

#### 操作的实现：

```c
#include <stdio.h>
#include <iostream>
using namespace std;
//定义结构体
typedef struct
{
	float real;
	float virtul;
} Complex;
void assign(Complex* A, float a, float b)
{
	A->real = a;
	A->virtul = b;
}
void add(Complex* A, float a, float b)
{
	A->real = A->real + a;
	A->virtul = A->virtul + b;
}

void myminus(Complex* A, float a, float b)
{
	A->real = A->real - a;
	A->virtul = A->virtul - b;
}
void multiply(Complex* A, float a, float b)
{
	A->real = A->real * a;
	A->virtul = A->virtul * b;
}
void mydevide(Complex* A, float a, float b)
{
	A->real = A->real / a;
	A->virtul = A->virtul / b;
}
void myprint(Complex* A)
{
	cout << "A的实部是" << A->real << "虚部是" << A->virtul << endl;
}
int main()
{

	Complex a = { 1,2 };

	Complex* ptr = &a;
	myprint(ptr);
	assign(ptr, 2, 3);
	myprint(ptr);

	add(ptr, 2, 3);
	myprint(ptr);



	myminus(ptr,2, 3);
	myprint(ptr);
	
	multiply(ptr, 2, 3);
	myprint(ptr);

	mydevide(ptr, 2, 3);
	myprint(ptr);


	return 0;
}
```

![image-20240120095347345](数据结构第1周/image-20240120095347345.png) 

### 算法和算法分析

#### **算法（Algorithm）**

 是**解决特定问题或执行特定任务的一系列步骤或规则**。

是一种精确定义的计算过程，通常包括输入、输出、以及处理输入以产生输出的步骤。

算法是**独立于特定编程语言**的，而是**描述了解决问题的一般步骤**。

算法可以在各种领域中找到应用，例如计算机科学、数学、工程、生物学等。在计算机科学中，算法是设计和分析的核心概念，因为它们决定了计算机程序的执行步骤。

![image-20240120095954991](数据结构第1周/image-20240120095954991.png) 

![image-20240120100124658](数据结构第1周/image-20240120100124658.png) 



#### 算法特性

> 1. **有限性（Finiteness）：** 算法必须在**有限的步骤内执行结束**。
>
> 2. **确定性（Determinism）：** **对于相同的输入，算法必须产生相同的输出**。
>
> 3. **输入（Input）：** 算法**有零个或多个输入。**
>
> 4. **输出（Output）：** 算法**至少有一个输出。**
>
> 5. **效率（Efficiency）：** 算法解决问题的**效率应该尽可能高**，即在合理的时间内完成。
>
> 6. **清晰性（Clarity）：** 算法应该**以清晰、明确的方式描述，易于理解和实现**。
>
> 7. **通用性（Generality）：** 算法应该**能够解决一类问题而不仅仅是特定实例**。
>
> 8. **可行性（Feasibility）：** 算法应该**在实际中可行，考虑实际资源限制**。
>
> 这些特性是算法设计和分析中的基本原则，确保算法在解决问题时是可靠、有效且可理解的。

#### 算法设计的要求



> 1. **正确性（Correctness）：** 算法必须产生正确的输出，并解决问题的本质。这是最基本的要求，算法应该对所有输入都能给出正确的结果。
> 2. **可读性（Readability）：** 算法应该以清晰、易读的方式描述，**使其他人能够理解和实现**。良好的可读性有助于代码的维护和团队协作。
> 3. **健壮性（Robustness）：** 算法应该能够处理各种输入情况，**包括异常情况**。**它不应该因为输入数据的变化而导致崩溃或不合理的输出。**
> 4. **高效性（Efficiency）：** 算法应该在**合理的时间内解决问题**。高效性涉及到**时间复杂度**和**空间复杂度**的优化
> 5. **可维护性（Maintainability）：** 算法的设计应该考虑到后续的维护工作，使得代码易于修改和更新。这包括合理的模块化、注释和命名规范等。
> 6. **通用性（Generality）：** 算法设计应该考虑解决一类问题而不仅仅是特定实例。这有助于提高算法的重用性。
> 8. **最佳性（Optimality）：** 在一些情况下，算法设计可能需要追求最佳解决方案。这涉及到在满足其他要求的前提下，尽量提高效率或减小资源使用。
>



#### ==**算法分析（Algorithm Analysis）**==

 是对**算法性能的研究和评估**。它涉及到确定算法在不同输入情况下的**运行时间、空间需求等方面的性能特征**。

常见的算法分析包括：

1. **时间复杂度（Time Complexity）**
2. **空间复杂度（Space Complexity）**
3. **最坏情况、平均情况和最好情况复杂度**：描述了算法在不同输入情况下的性能。
4. **稳定性和稳定性分析**：稳定性表示对于相等的元素，排序算法是否保持它们的相对位置。
5. **可行性分析**：算法是否在合理的时间内解决问题。

> 时间效率和空间效率有时是矛盾的

算法分析的目标是找到一种对问题的解决方案，使得在不同的输入下，**算法表现出较好的性能**。选择合适的算法来解决特定问题，并优化程序的执行效率。

##### **时间复杂度（Time Complexity）**

![image-20240120150103790](数据结构第1周/image-20240120150103790.png) 

![image-20240120103339282](数据结构第1周/image-20240120103339282.png) 

---

**时间复杂度（Time Complexity）**：描述了**==算法运行时间==随==输入规模==增加而增加的==趋势==**。通常以“大O符号”表示，例如 O(n)，O(n^2)。

常见的时间复杂度有：

1. **常数时间复杂度（O(1)）：** 不论输入规模大小，算法的运行时间都是常数。

2. **线性时间复杂度（O(n)）：** 算法的运行时间与输入规模成线性关系。

3. **对数时间复杂度（O(log n)）：** 算法的运行时间与输入规模的对数成正比。

4. **线性对数时间复杂度（O(n log n)）：** 通常出现在某些高效排序算法中。

5. **平方时间复杂度（O(n^2)）：** 算法的运行时间与输入规模的平方成正比。

6. **指数时间复杂度（O(2^n)）：** 算法的运行时间与输入规模的指数成正比。通常是一些暴力穷举的算法。

7. **多项式时间复杂度（O(n^k)）：** 其中 k 是常数。

关注算法的主要执行步骤，并根据这些步骤的数量级来确定时间复杂度。例如，循环结构、递归、嵌套循环等都会影响时间复杂度的分析。

关注算法的**最坏情况时间复杂度**，因为这给出了**算法性能的一个上界**。同时，平均情况时间复杂度也是一个重要的度量，但由于难以准确估算“平均”情况，所以**最坏情况时间复杂度更为常用。**

> 时间复杂度是对算法性能的一种抽象**估计**，具体的执行时间还受到硬件、编译器优化等因素的影响。

![image-20240120101319158](数据结构第1周/image-20240120101319158.png) 

###### 事前分析方法:

![image-20240120101503645](数据结构第1周/image-20240120101503645.png)![image-20240120101733879](数据结构第1周/image-20240120101733879.png) 

 

###### 例子

> 若有某个**辅助函数f(n)**，使得当**n趋近于无穷大时**，T**(n)/f(n)的极限值为不等于零的常数**，则称**f(n)是T(n)的同数量级函数**。**记作T(n)=O(f(n))**,称O（f(n))为**算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度**

> 算法的渐进时间复杂度（O是数量级的符号），简称时间复杂度

假设有一个算法的运行时间 T(n) 是 n^2 + 3n + 5，我们想要找到它的**渐进时间复杂度。**

1. **辅助函数 f(n)：** 可以选择 f(n) = n^2，因为在 **n 趋近于无穷大时，主导项 n^2 的影响最大。**

2. **T(n)/f(n) 极限值：** 计算极限值 lim(n→∞) (T(n)/f(n))，**如果这个极限值存在并不等于零的常数，那么 f(n) 就是 T(n) 的同数量级函数**。

   ```latex
   latexCopy codelim(n→∞) (n^2 + 3n + 5) / n^2
   = lim(n→∞) (1 + 3/n + 5/n^2)
   = 1 (当 n 趋近于无穷大时，3/n 和 5/n^2 的影响趋近于零)
   ```

1. **渐进时间复杂度：** 由于极限值为 1，不等于零的常数，我们可以说 **T(n) 的渐进时间复杂度是 O(n^2)。**

###### 例子2

![image-20240120102818995](数据结构第1周/image-20240120102818995.png) 

![image-20240120102910517](数据结构第1周/image-20240120102910517.png)



>  一般情况下，**不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数**，它是问题规模n的某个函数，用T(n)表示。
>
> ![image-20240120103653014](数据结构第1周/image-20240120103653014.png)  

###### 小结

![image-20240120103936259](数据结构第1周/image-20240120103936259.png)

忽略所有低次幂项和最高次幂系数，体现出增长率的含义

![image-20240120104306603](数据结构第1周/image-20240120104306603.png)

![image-20240120104451618](数据结构第1周/image-20240120104451618.png)

![image-20240120104621834](数据结构第1周/image-20240120104621834.png)

![image-20240120110743498](数据结构第1周/image-20240120110743498.png)

![image-20240120111954109](数据结构第1周/image-20240120111954109.png)    

> 时间复杂度是**由嵌套最深层语句的频度**决定的 



###### 语句频度

> 语句频度（Statement Frequency）是在算法分析中用于估计算法执行时间的一种度量。它表示**某一条语句在算法中被执行的次数**。通常，语句频度与输入规模有关。
>
> 在算法分析中，我们经常使用循环结构的语句频度来描述算法的执行次数。假设有一个循环结构，其中包含一条语句，我们想要计算这条语句的执行次数。以下是一些常见的情况：
>
> 1. **常数频度：** 如果某个语句在算法中是常数频度，表示它在算法执行的过程中只执行一次，与输入规模无关。
>
>    例如：
>    ```c
>    int x = 0;  // 常数频度语句，只执行一次
>    ```
>
> 2. **线性频度：** 如果某个语句的执行次数与输入规模成线性关系，表示它在算法中会随着输入规模的增加而线性增加。
>
>    例如：
>    ```c
>    for (int i = 0; i < n; i++) {
>        // 线性频度语句，执行次数与 n 成正比
>    }
>    ```
>
> 3. **对数频度：** 如果某个语句的执行次数与输入规模的对数成正比，表示它在算法中具有对数频度。
>
>    例如：
>    ```c
>    int i = 1;
>    while (i < n) {
>        i = i * 2;
>        // 对数频度语句，执行次数与 log(n) 成正比
>    }
>    ```
>

总结常见的时间复杂度及其对应的描述、例子表示：

| 时间复杂度 | 描述               | 例子               | 图形表示 |
| ---------- | ------------------ | ------------------ | -------- |
| O(1)       | 常数时间复杂度     | 单个语句或操作     |          |
| O(log n)   | 对数时间复杂度     | 二分查找           |          |
| O(n)       | 线性时间复杂度     | 单层循环           |          |
| O(n log n) | 线性对数时间复杂度 | 快速排序、归并排序 |          |
| O(n^2)     | 平方时间复杂度     | 双层嵌套循环       |          |
| O(n^k)     | 多项式时间复杂度   | k层嵌套循环        |          |
| O(2^n)     | 指数时间复杂度     | 求解子集问题       |          |
| O(n!)      | 阶乘时间复杂度     | 求解全排           |          |



###### 复杂算法的复杂度的处理

处理复杂算法的渐进时间复杂度的两个重要法则。大O加法法则和乘法法则。

T(n)=O(n);

1. **大O加法法则：**
   
   - **概念：** 大O加法法则用于描述当算法包含多个独立操作时，其总体时间复杂度是如何计算的。
   
   - **表述：** 如果一个算法的时间复杂度可以表示为`T1(n)+T(n)+....+T(n)`，那么总体的时间复杂度为
   
     `O(g(n))+O(f(n))+.....`
   
   - ![image-20240120151456875](数据结构第1周/image-20240120151456875.png) 
   
   - **意义：** 这个法则表示，==**当算法由多个独立操作组成时，总体时间复杂度由其中最高阶的部分决定==**。在**渐进分析中，我们通常只关注最高阶项，忽略掉其他次要项和低次项**。
   
2. **大O乘法法则：**
   
   - **概念：** 大O乘法法则用于描述**当算法的不同部分相互嵌套时**，其总体时间复杂度是如何计算的。
   - **表述：** 如果一个算法的时间复杂度可以表示为\[ T(n) = O(f(n)) \times O(g(n)) \]，那么总体的时间复杂度为\[ O(T(n)) = O(f(n) \times g(n)) \]。
   - ![image-20240120151509353](数据结构第1周/image-20240120151509353.png) 
   - **意义：** 这个法则表示，当算法的各个部分相互嵌套时，总体时间复杂度等于各部分时间复杂度的乘积。在渐进分析中，我们关注的是最高阶的乘积。

这两个法则帮助我们对复杂算法进行更容易的时间复杂度分析，尤其是在算法的各个部分或操作具有独立性或相互嵌套的情况下。通过应用这些法则，我们可以更简洁地表示和理解算法的总体性能。

###### 算法时间效率的比较

![image-20240120151942586](数据结构第1周/image-20240120151942586.png) 



##### 空间复杂度

---

**空间复杂度（Space Complexity）**：描述了**算法在执行过程中所需的额外空间或内存随输入规模增加而增加的趋势。**

![image-20240120152114711](数据结构第1周/image-20240120152114711.png) 

> 算法的空间复杂度是指**算法在执行过程中所需的内存空间的度量**，通常**用大O符号表示**。空间复杂度主要关注的是**算法对内存资源的使用情况，而不是执行时间。**
>
> 以下是一些常见的空间复杂度：
>
> 1. **O(1) - 常数空间复杂度：** 算法的空间使用与输入规模无关，即算法在执行时只需要常数级别的内存空间。
>
> 2. **O(n) - 线性空间复杂度：** 算法的空间使用与输入规模成线性关系。典型的例子包括数组、链表等数据结构，其**空间占用随着输入规模的增加而线性增长。**
>
> 3. **O(n^2)、O(n^3) 等 - 多项式空间复杂度：** **算法的空间使用与输入规模的某个多项式关系成正比**。这种情况通常涉及到多层嵌套的数据结构，如**二维数组**。
>
> 4. **O(log n) - 对数空间复杂度：** 算法的空间使用与输入规模的对数关系成正比。这在一些分治算法中比较常见，例如二分搜索。
>
> 5. **O(n log n) - 线性对数空间复杂度：** 算法的空间使用与输入规模的对数乘以线性关系成正比。例如，快速排序、归并排序等常见的排序算法。
>
> 空间复杂度的分析同样可以采用类似于时间复杂度的渐进分析方法，关注算法在输入规模趋近无穷大时对内存空间的增长趋势。在实际应用中，选择合适的算法时，除了考虑时间复杂度外，还需要考虑空间复杂度，特别是在资源受限的环境中。

###### 例子

![image-20240120153316841](数据结构第1周/image-20240120153316841.png) 

对于第一种逆序算法:

```c
void nixu1(int a[], int line)
{
	for (int i = 0; i < line/2; i++)
	{
		int t = a[i];
		a[i] = a[line - i - 1];
		a[line - i - 1] = t;
	}
	cout << endl;
}
```

第二种逆序算法:

```c
void nixu2(int a[], int line)
{
	int* b = (int*)malloc(line * sizeof(int));
	for (int i = 0; i < line; i++)
	{
		b[i] = a[line - 1 - i];
	}
	for (int i = 0; i < line; i++)
	{
		a[i] = b[i];
	}
    free(b);
}
```

c++

```c++
void nixu2(int a[], int line)
{
	int* b = new int(5);
	for (int i = 0; i < line; i++)
	{
		b[i] = a[line - 1 - i];
	}
	for (int i = 0; i < line; i++)
	{
		a[i] = b[i];
	}
}
```

---

###### C/C++里的动态内存分配

> 复习动态内存分配
>
> ----
>
> **动态内存分配**是在**程序运行时根据需要分配和释放内存的过程**。
>
> 在C和C++中，分别使用了 `malloc`、`free`（C）和 `new`、`delete`（C++）来进行**动态内存的分配和释放**。
>
> ---
>
> **在C语言中的动态内存分配与释放（使用 `malloc` 和 `free`）**
>
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> 
> int main() {
>     // 动态分配一个整数的内存空间
>     int *ptr = (int *)malloc(sizeof(int));
> 
>     if (ptr != NULL) {
>         *ptr = 42;  // 使用分配的内存
>         printf("%d\n", *ptr);
> 
>         free(ptr);  // 释放内存
>     }
>     return 0;
> }
> ```
>
> - `malloc(size_t size)` 用于分配 `size` 字节的内存，并返回一个**指向分配内存起始地址的指针**。
> - 所以我们需要再强制转换一下，才能复制给我们开辟的数组指针
> - `free(void *ptr)` 用于释放之前使用 `malloc` 分配的内存。
>
> ---
>
> **在C++中的动态内存分配（使用 `new` 和 `delete`）
>
> **在C++中动态数组的分配和释放**
>
> ```cpp
> #include <iostream>
> 
> int main() {
>     // 动态分配一个整数数组的内存空间
>     int *arr = new int[5];
> 
>     if (arr != nullptr) {
>         // 使用分配的内存
>         for (int i = 0; i < 5; i++) {
>             arr[i] = i * 2;
>             std::cout << arr[i] << " ";
>         }
> 
>         delete[] arr;  // 释放内存
>     }
> 
>     return 0;
> }
> ```
>
> - `new T[n]` 用于动态分配类型 `T` 的数组，包含 `n` 个元素。
> - `delete[] arr` 用于释放之前使用 `new[]` 分配的数组内存。
>
> 总体而言，在**使用动态内存时，要确保及时释放已经分配的内存，以防止内存泄漏**。在C++中，推荐使用 `new` 和 `delete`，并且对于动态数组的分配和释放，应使用 `new[]` 和 `delete[]`。

#### 设计好算法的过程

![image-20240120155548721](数据结构第1周/image-20240120155548721.png) 
