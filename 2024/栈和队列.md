# 栈和队列

## 普通线性表的插入和删除

![image-20240409183820516](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409183820516.png)

![image-20240409183908491](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409183908491.png)   

## 栈和队列的定义

### 栈

#### 栈的定义

![image-20240409184331463](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409184331463.png)

**LIFO原则**：栈遵循后进先出（Last In, First Out）的原则，即最后进入栈的元素首先被移出。 

#### 栈的概念

![image-20240409184717699](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409184717699.png)  

#### 栈的示意图

![image-20240409184846587](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409184846587.png)

#### 栈的操作

##### 入栈

![PixPin04-09_18-50-04](D:/pixpinGif/i2024/PixPin04-09_18-50-04.gif)

##### 出栈

![PixPin04-09_18-53-16](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/PixPin04-09_18-53-16.gif)

**基本操作**：栈通常支持以下基本操作：

- **Push（入栈）**：将元素添加到栈的顶部。
- **Pop（出栈）**：从栈的顶部移除元素。
- **Peek（查看栈顶元素）**：查看栈顶部的元素，但不移除它。
- **isEmpty（判断栈是否为空）**：检查栈是否为空。

#### 栈的应用

![image-20240409184059332](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409184059332.png)

#### 栈的思考

![image-20240409185719014](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409185719014.png) 

#### 栈的总结

![image-20240409185803392](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409185803392.png) 

![image-20240409185829239](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409185829239.png) 



#### 栈的测试代码

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100   // 定义栈的最大容量

// 定义栈的结构体
typedef struct {
    int *items;     // 存储栈元素的数组指针
    int maxSize;    // 栈的最大容量
    int top;        // 栈顶指针，指向栈顶元素的位置
} Stack;

// 初始化栈
void initializeStack(Stack *stack, int maxSize) {
    stack->top = -1;  // 空栈时，top初始化为-1
    stack->maxSize = maxSize;
    stack->items = (int *)malloc(maxSize * sizeof(int));  // 分配内存
    if (stack->items == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }
}

// 判断栈是否为空
int isEmpty(Stack *stack) {
    return stack->top == -1;
}

// 将元素入栈
void push(Stack *stack, int item) {
    stack->top++;
    stack->items[stack->top] = item;
}

// 将栈顶元素出栈
int pop(Stack *stack) {
    int item = stack->items[stack->top];
    stack->top--;
    return item;
}

// 十进制转换为任意进制
void decimalToBase(int decimal, int base) {
    Stack stack;
    initializeStack(&stack, MAX_SIZE);

    // 将每一位的余数入栈，直到商为0
    while (decimal > 0) {
        int remainder = decimal % base;
        push(&stack, remainder);
        decimal = decimal / base;
    }

    // 出栈并打印，得到目标进制数
    printf("%d进制表示：", base);
    while (!isEmpty(&stack)) {
        int digit = pop(&stack);
        // 如果是大于10的数字，则使用字母表示
        if (digit >= 10) {
            printf("%c", 'A' + (digit - 10));
        } else {
            printf("%d", digit);
        }
    }
    printf("\n");
}

// 测试进制转换功能
int main() {
    int decimal, base;
    printf("请输入一个十进制数：");
    scanf("%d", &decimal);
    printf("请输入目标进制数（2~16）：");
    scanf("%d", &base);

    if (base < 2 || base > 16) {
        printf("目标进制数必须在2到16之间\n");
        return 1;
    }

    decimalToBase(decimal, base);

    return 0;
}

```

> 栈为空的时候让top=-1
>
> 栈顶指针 `stack->top` 和栈的最大容量 `stack->maxSize` 来确定栈是否已满。如果栈顶指针等于 `stack->maxSize - 1`，则表示栈已经满了，因为栈的索引是从 0 开始的，所以最后一个位置的索引是 `maxSize - 1`。
>
> ---
>
> 1. **栈的定义**：栈是一种后进先出（LIFO）的数据结构。在这段代码中，栈通过结构体 `Stack` 来定义，包括了一个数组指针 `items` 用于存储栈元素，一个整数 `maxSize` 表示栈的最大容量，以及一个整数 `top` 表示栈顶指针，指向栈顶元素的位置。
> 2. **初始化栈**：`initializeStack` 函数用于初始化栈，设置栈的最大容量和栈顶指针，并动态分配内存来存储栈元素。
> 3. **判断栈是否为空**：`isEmpty` 函数用于判断栈是否为空，如果栈顶指针 `top` 等于 -1，则表示栈为空。
> 4. **判断栈是否已满**：`isFull` 函数用于判断栈是否已满，如果栈顶指针 `top` 等于栈的最大容量减1，则表示栈已满。
> 5. **入栈操作**：`push` 函数用于将元素入栈，首先检查栈是否已满，然后将栈顶指针 `top` 向上移动一个位置，并将元素存储在新的栈顶位置。
> 6. **出栈操作**：`pop` 函数用于将元素出栈，首先检查栈是否为空，然后从当前栈顶位置取出元素，并将栈顶指针 `top` 向下移动一个位置。
> 7. **获取栈顶元素**：`peek` 函数用于获取栈顶元素的值，但不对栈进行修改，首先检查栈是否为空，然后返回栈顶元素的值。
> 8. **清空栈**：`clearStack` 函数用于清空栈，释放动态分配的内存并将栈顶指针 `top` 设置为 -1。

### 队列

#### 队列的定义和特点

队列（Queue）是一种数据结构，它遵循**先进先出（FIFO）的原则**。在队列中，数据项只能在队尾进行插入操作，在队头进行删除操作，这样就保证了最先插入的元素会最先被移除。队列常用于需要先进先出顺序访问元素的场景，比如任务调度、消息传递、广度优先搜索等。

队列的定义通常包括以下要素：

1. **元素集合**：队列由一组元素组成，这些元素可以是**任意类型的数据。**
2. **插入操作（入队）**：将元素添加到队列的末尾。
3. **删除操作（出队）**：从队列的开头移除元素。
4. **队头和队尾**：队列有两个指针，分别指向队列的头部和尾部。
5. **空队列**：当队列中没有元素时，称之为空队列。

队列可以用数组、链表或其他数据结构来实现。在实际应用中，队列有着广泛的应用，比如线程池、消息队列、操作系统的进程调度等。

![image-20240414105901887](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105901887.png) 

![image-20240412102116585](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412102116585.png)

 

#### 队列的相关概念

![image-20240412102138975](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412102138975.png) 

#### 队列的应用

![image-20240409184044047](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240409184044047.png) 

#### 队列的测试代码

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100   // 定义队列的最大容量

// 定义队列结构体
typedef struct {
    int items[MAX_SIZE];   // 用数组存储队列元素
    int front;             // 指向队列头部的指针
    int rear;              // 指向队列尾部的指针
} Queue;

// 初始化队列
void initializeQueue(Queue *queue) {
    queue->front = -1;   // 队列头部指针初始化为-1
    queue->rear = -1;    // 队列尾部指针初始化为-1
}

// 判断队列是否为空
int isEmpty(Queue *queue) {
    return queue->front == -1;
}

// 判断队列是否已满
int isFull(Queue *queue) {
    return (queue->rear + 1) % MAX_SIZE == queue->front;
}

// 入队
void enqueue(Queue *queue, int item) {
    if (isFull(queue)) {
        printf("队列已满，无法入队\n");
        return;
    }
    if (isEmpty(queue)) {
        queue->front = 0;
    }
    queue->rear = (queue->rear + 1) % MAX_SIZE;
    queue->items[queue->rear] = item;
}

// 出队
int dequeue(Queue *queue) {
    if (isEmpty(queue)) {
        printf("队列为空，无法出队\n");
        exit(1);
    }
    int item = queue->items[queue->front];
    if (queue->front == queue->rear) {
        initializeQueue(queue);   // 如果队列中只有一个元素，出队后需要重置队列
    } else {
        queue->front = (queue->front + 1) % MAX_SIZE;
    }
    return item;
}

// 获取队头元素
int peek(Queue *queue) {
    if (isEmpty(queue)) {
        printf("队列为空\n");
        exit(1);
    }
    return queue->items[queue->front];
}

// 清空队列
void clearQueue(Queue *queue) {
    queue->front = -1;
    queue->rear = -1;
}

// 测试队列的功能
int main() {
    Queue queue;
    initializeQueue(&queue);

    enqueue(&queue, 10);
    enqueue(&queue, 20);
    enqueue(&queue, 30);

    printf("队头元素：%d\n", peek(&queue));

    printf("出队：%d\n", dequeue(&queue));
    printf("出队：%d\n", dequeue(&queue));

    printf("队列是否为空：%d\n", isEmpty(&queue));

    clearQueue(&queue);

    return 0;
}

```

> 1. **队列的定义**：代码中通过结构体 `Queue` 来定义了一个队列。队列包含了一个固定大小的数组 `items` 用于存储元素，以及两个指针 `front` 和 `rear` 分别指向队列的头部和尾部。
> 2. **初始化队列**：`initializeQueue` 函数用于初始化队列，将队列的 `front` 和 `rear` 初始化为 -1，表示队列为空。
> 3. **判断队列是否为空**：`isEmpty` 函数用于判断队列是否为空，如果 `front` 指针为 -1，则表示队列为空。
> 4. **判断队列是否已满**：`isFull` 函数用于判断队列是否已满，如果 `(rear + 1) % MAX_SIZE` 等于 `front`，则表示队列已满。
> 5. **入队操作**：`enqueue` 函数用于将元素添加到队列的末尾。如果队列已满，则无法添加元素。
> 6. **出队操作**：`dequeue` 函数用于从队列的头部移除元素，并返回移除的元素值。如果队列为空，则无法移除元素。
> 7. **获取队头元素**：`peek` 函数用于获取队列头部的元素值，但不移除它。如果队列为空，则无法获取元素。
> 8. **清空队列**：`clearQueue` 函数用于清空队列，将 `front` 和 `rear` 重置为 -1。



## 案例引入

### 进制转换

![image-20240412102915264](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412102915264.png) 

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100   // 定义栈的最大容量

// 定义栈的结构体
typedef struct {
    int items[MAX_SIZE];   // 存储栈元素的数组
    int top;               // 栈顶指针
} Stack;

// 初始化栈
void initializeStack(Stack *stack) {
    stack->top = -1;  // 空栈时，top初始化为-1
}

// 判断栈是否为空
int isEmpty(Stack *stack) {
    return stack->top == -1;
}

// 将元素入栈
void push(Stack *stack, int item) {
    stack->top++;
    stack->items[stack->top] = item;
}

// 将栈顶元素出栈
int pop(Stack *stack) {
    int item = stack->items[stack->top];
    stack->top--;
    return item;
}

// 十进制转换为二进制
void decimalToBinary(int decimal) {
    Stack stack;
    initializeStack(&stack);

    // 将每一位的余数入栈，直到商为0
    while (decimal > 0) {
        int remainder = decimal % 8;
        push(&stack, remainder);
        decimal = decimal / 8;
    }

    // 出栈并打印，得到二进制数
    printf("二进制表示：");
    while (!isEmpty(&stack)) {
        printf("%d", pop(&stack));
    }
    printf("\n");
}

// 测试进制转换功能
int main() {
    int decimal;
    printf("请输入一个十进制数：");
    scanf("%d", &decimal);

    decimalToBinary(decimal);

    return 0;
}

```

![image-20240412103541293](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412103541293.png) 





### 括号匹配

![image-20240412103732166](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412103732166.png) 

先入栈的后匹配，后入栈的先匹配

![image-20240412103828914](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412103828914.png) 





```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义栈的结构体
typedef struct {
    char *items;     // 存储栈元素的数组指针
    int maxSize;    // 栈的最大容量
    int top;        // 栈顶指针，指向栈顶元素的位置
} Stack;

// 初始化栈
void initializeStack(Stack *stack, int maxSize) {
    stack->top = -1;  // 空栈时，top初始化为-1
    stack->maxSize = maxSize;
    stack->items = (char *)malloc(maxSize * sizeof(char));  // 分配内存
    if (stack->items == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }
}

// 判断栈是否为空
int isEmpty(Stack *stack) {
    return stack->top == -1;
}

// 判断栈是否已满
int isFull(Stack *stack) {
    return stack->top == stack->maxSize - 1;
}

// 将元素入栈
void push(Stack *stack, char item) {
    if (isFull(stack)) {
        printf("栈已满，无法入栈\n");
        return;
    }
    stack->top++;
    stack->items[stack->top] = item;
}

// 将栈顶元素出栈
char pop(Stack *stack) {
    if (isEmpty(stack)) {
        printf("栈为空，无法出栈\n");
        exit(1);
    }
    char item = stack->items[stack->top];
    stack->top--;
    return item;
}

// 检验括号匹配，并返回匹配失败的原因和种类
int checkParentheses(char *expression) {
    Stack stack;
    initializeStack(&stack, strlen(expression));

    for (int i = 0; expression[i] != '\0'; i++) {
        if (expression[i] == '(' || expression[i] == '{' || expression[i] == '[') {
            push(&stack, expression[i]);
        } else if (expression[i] == ')' || expression[i] == '}' || expression[i] == ']') {
            if (isEmpty(&stack)) {
                return 1;  // 右括号多余
            }
            char left = pop(&stack);
            if ((expression[i] == ')' && left != '(') ||
                (expression[i] == '}' && left != '{') ||
                (expression[i] == ']' && left != '[')) {
                return 2;  // 括号类型不匹配
            }
        }
    }

    return isEmpty(&stack) ? 0 : 3;  // 0表示匹配成功，3表示左括号多余
}

// 打印括号匹配失败的原因和种类
void printFailureReason(int reason) {
    switch (reason) {
        case 1:
            printf("括号匹配失败：右括号多余\n");
            break;
        case 2:
            printf("括号匹配失败：括号类型不匹配\n");
            break;
        case 3:
            printf("括号匹配失败：左括号多余\n");
            break;
        default:
            printf("括号匹配成功\n");
    }
}

// 测试括号匹配功能
int main() {
    char expression[100];
    int continue_flag = 1;

    while (continue_flag) {
        printf("请输入一个包含括号的表达式：\n");
        scanf("%s", expression);

        int result = checkParentheses(expression);
        printFailureReason(result);

        printf("是否继续（1表示是，0表示否）：");
        scanf("%d", &continue_flag);
    }

    return 0;
}

```

> 1. **栈的结构体定义**：
>    - 定义了一个结构体 `Stack`，用来表示栈。其中包含了存储栈元素的数组指针 `items`、栈的最大容量 `maxSize` 和栈顶指针 `top`。
> 2. **初始化栈函数**：
>    - `initializeStack` 函数用来初始化栈，将栈的顶部指针 `top` 设为 -1，表示空栈，并为存储栈元素的数组 `items` 分配内存。
> 3. **栈的基本操作函数**：
>    - `isEmpty` 函数用来判断栈是否为空。
>    - `isFull` 函数用来判断栈是否已满。
>    - `push` 函数用来将元素入栈。
>    - `pop` 函数用来将栈顶元素出栈。
> 4. **括号匹配检验函数**：
>    - `checkParentheses` 函数用来检验括号匹配。它遍历输入的表达式，当遇到左括号时将其入栈，当遇到右括号时与栈顶元素匹配。如果匹配成功，则继续遍历；如果匹配失败或者栈已空（即右括号多余），则返回相应的错误码。
> 5. **打印错误原因函数**：
>    - `printFailureReason` 函数用来根据检验结果打印括号匹配失败的原因和种类。

---

> 匹配算法的详细步骤：
>
> 1. **初始化一个空栈用于存储左括号**。
> 2. **从左到右遍历表达式中的每个字符**。
> 3. 如果**当前字符是左括号（包括圆括号、方括号和花括号），则将其入栈**。
> 4. 如果当前字符是**右括号**：
>    - 如果栈为空，则括号不匹配，返回匹配失败`右括号多余`
>    - 否则，尝试将**当前右括号**与**栈顶元素**匹配：
>      - 如果匹配成功，则**将栈顶元素出栈，继续遍历下一个字符**。`这个括号成功匹配了，继续下一个`
>      - 如果匹配失败，则括号不匹配，返回匹配失败。·`例如:([)]`
> 5. 遍历完所有字符后，检查栈是否为空：
>    - **如果栈为空，则说明所有左括号都找到了匹配的右括号，括号匹配成功。**
>    - **如果栈不为空，则说明有左括号没有匹配的右括号，括号匹配失败。**
>
> 关键在于利用栈的后进先出特性。左括号会按顺序入栈，而右括号会按顺序与栈顶元素进行匹配
>
> 保证了**括号的顺序匹配。**

### 表达式求值

#### 中缀表达式转换为后缀表达式（逆波兰表达式）

![image-20240413193250514](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413193250514.png) 

将中缀表达式转换为后缀表达式是一种常见的算法，通常使用栈来实现。在这个算法中，我们需要考虑操作符的优先级和结合性，并将中缀表达式转换为等价的后缀表达式

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定义栈的结构体
typedef struct {
    char *items;     // 存储栈元素的数组指针
    int maxSize;    // 栈的最大容量
    int top;        // 栈顶指针，指向栈顶元素的位置
} Stack;

// 初始化栈
void initializeStack(Stack *stack, int maxSize) {
    stack->top = -1;  // 空栈时，top初始化为-1
    stack->maxSize = maxSize;
    stack->items = (char *)malloc(maxSize * sizeof(char));  // 分配内存
    if (stack->items == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }
}

// 判断栈是否为空
int isEmpty(Stack *stack) {
    return stack->top == -1;
}

// 判断栈是否已满
int isFull(Stack *stack) {
    return stack->top == stack->maxSize - 1;
}

// 将元素入栈
void push(Stack *stack, char item) {
    if (isFull(stack)) {
        printf("栈已满，无法入栈\n");
        return;
    }
    stack->top++;
    stack->items[stack->top] = item;
}

// 将栈顶元素出栈
char pop(Stack *stack) {
    if (isEmpty(stack)) {
        printf("栈为空，无法出栈\n");
        exit(1);
    }
    char item = stack->items[stack->top];
    stack->top--;
    return item;
}

// 获取栈顶元素
char peek(Stack *stack) {
    if (isEmpty(stack)) {
        printf("栈为空\n");
        exit(1);
    }
    return stack->items[stack->top];
}

// 获取操作符优先级
int precedence(char op) {
    switch(op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0;
    }
}

// 中缀表达式转后缀表达式
void infixToPostfix(char *infix, char *postfix) {
    Stack stack;
    initializeStack(&stack, strlen(infix));
    int postfixIndex = 0;

    for (int i = 0; infix[i] != '\0'; i++) {
        char ch = infix[i];
        if (ch >= '0' && ch <= '9') {
            postfix[postfixIndex++] = ch; // 数字直接输出到后缀表达式
        } else if (ch == '(') {
            push(&stack, ch); // 左括号直接入栈
        } else if (ch == ')') {
            while (!isEmpty(&stack) && peek(&stack) != '(') {
                postfix[postfixIndex++] = pop(&stack); // 将栈内的运算符输出到后缀表达式，直到遇到左括号
            }
            pop(&stack); // 弹出左括号
        } else { // 运算符
            while (!isEmpty(&stack) && precedence(ch) <= precedence(peek(&stack))) {
                postfix[postfixIndex++] = pop(&stack); // 弹出优先级高于当前运算符的运算符
            }
            push(&stack, ch); // 当前运算符入栈
        }
    }

    // 将栈中剩余的运算符输出到后缀表达式
    while (!isEmpty(&stack)) {
        postfix[postfixIndex++] = pop(&stack);
    }

    postfix[postfixIndex] = '\0'; // 在后缀表达式末尾添加字符串结束符
}

// 测试中缀转后缀功能
int main() {
    char infix[100];
    char postfix[100];

    printf("请输入一个中缀表达式（不含空格）：");
    scanf("%s", infix);

    infixToPostfix(infix, postfix);

    printf("对应的后缀表达式为：%s\n", postfix);

    return 0;
}
```

![image-20240412124147257](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240412124147257.png) 

> 中缀表达式 `9+(3-1)*3+10/2` 转换为后缀表达式的过程，以及在转换过程中栈的情况：
>
> 1. **初始情况**：
>    - 输入的中缀表达式为 `9+(3-1)*3+10/2`。
>    - 后缀表达式暂时为空。
>    - 栈为空。
>
> 2. **遍历表达式**：
>    - 我们从左到右逐个字符地遍历中缀表达式。
>
> 3. **遇到数字 `9`**：
>    - 将数字 `9` 直接输出到后缀表达式。
>    - 后缀表达式：`9`
>    - 栈的情况：空栈。
>
> 4. **遇到运算符 `+`**：
>    - 由于栈为空，直接将 `+` 入栈。
>    - 后缀表达式：`9`
>    - 栈的情况：`+`
>
> 5. **遇到左括号 `(`**：
>    - 直接将左括号入栈。
>    - 后缀表达式：`9`
>    - 栈的情况：`+(`
>
> 6. **遇到数字 `3`**：
>    - 将数字 `3` 直接输出到后缀表达式。
>    - 后缀表达式：`93`
>    - 栈的情况：`+(`
>
> 7. - **遇到运算符 `-`**：
>      - 和栈顶元素的优先级比较，如果大于等于都入栈，只有小于的时候才`将栈顶优先级高于或等于当前运算符的运算符依次弹出，并输出到后缀表达式中`
>      - 后缀表达式：`93`
>      - 栈的情况：`+(-`
>
> 8. **遇到数字 `1`**：
>    - 将数字 `1` 直接输出到后缀表达式。
>    - 后缀表达式：`931`
>    - 栈的情况：`+(-`
>
> 9. **遇到右括号 `)`**：
>    - 弹出栈内的运算符**直到遇到左括号，并将这些运算符输出到后缀表达式。**
>    - 后缀表达式：`931-`
>    - 栈的情况：`+`
>
> 10. **遇到运算符 `*`**：
>     - 由于 `*` 的**优先级高于**栈顶的 `+`，所以将 `*` 入栈。
>     - 后缀表达式：`931-`
>     - 栈的情况：`+*`
>
> 11. **遇到数字 `3`**：
>     - 将数字 `3` 直接输出到后缀表达式。
>     - 后缀表达式：`931-3`
>     - 栈的情况：`+*`
>
> 12. **遇到运算符 `+`**：
>     - 由于 `+` 的优先级低于栈顶的 `*`，所以将栈内的 `*` 弹出并输出到后缀表达式。
>     - 后缀表达式：`931-3*`
>     - 栈的情况：`+`
>
> 13. **遇到数字 `10`**：
>     - 将数字 `10` 直接输出到后缀表达式。
>     - 后缀表达式：`931-3*10`
>     - 栈的情况：`+`
>
> 14. **遇到运算符 `/`**：
>     - 由于 `/` 的优先级不高于栈顶的 `+`，所以将 `/` 入栈。
>     - 后缀表达式：`931-3*10`
>     - 栈的情况：`+/`
>
> 15. **遇到数字 `2`**：
>     - 将数字 `2` 直接输出到后缀表达式。
>     - 后缀表达式：`931-3*102`
>     - 栈的情况：`+/`
>
> 16. **遍历完表达式**：
>     - 将栈内剩余的运算符依次

1. **遍历中缀表达式**：从左到右逐个字符地扫描中缀表达式。
2. **遇到操作数**：如果遇到操作数（数字），直接输出到后缀表达式中。
3. **遇到左括号**：如果遇到左括号，将其入栈。
4. **遇到运算符**：
   - 如果遇到运算符，检查其与栈顶运算符的优先级。
   - 如果栈为空，或者**遇到的运算符优先级高于栈顶运算符，直接将运算符入栈**。
   - 否则，将**栈顶优先级高于或等于当前运算符的运算符依次弹出，并输出到后缀表达式中**，直到栈顶运算符优先级低于当前运算符，然后将当前运算符入栈。
5. **遇到右括号**：
   - **如果遇到右括号，弹出栈内运算符直到遇到左括号，并输出到后缀表达式中。**
6. **遍历完表达式**：
   - **当表达式遍历完成后，将栈内剩余的运算符依次弹出，并输出到后缀表达式中。**

#### 计算后缀表达式

![image-20240413190707717](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413190707717.png) 

## 栈的表示和操作的实现

### 栈的抽象数据类型定义

![image-20240413193725961](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413193725961.png)



### 栈的顺序表示和实现

#### 顺序栈的表示

```c
// 定义顺序栈结构
typedef struct {
    int *base;  // 栈底指针
    int *top;    // 栈顶指针
    int stackSize; // 栈的最大容量
} SqStack;
```

![image-20240413194408019](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413194408019.png) 

#### 空栈和满栈 

![image-20240413194947803](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413194947803.png) 



#### top和base指针

![image-20240413195134262](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413195134262.png) 

top和base可以用整形(下标)表示

#### 顺序栈的操作和实现

##### 栈的初始化

![image-20240413222511666](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413222511666.png) 

```c
// 初始化顺序栈
void initStack(SqStack *stack) {
    stack->base = (int *)malloc(MAX_SIZE * sizeof(int));  // 分配内存空间
    if (stack->base == NULL) {
        printf("Error: Memory allocation failed\n");
        exit(1);
    }
    stack->top = stack->base;  // 初始时栈底和栈顶指针指向同一个位置
    stack->stackSize = MAX_SIZE;  // 栈的最大容量为MAX_SIZE
}
```

##### 判断顺序栈是否为空

> 只需检查栈顶指针是否等于栈底指针。如果栈顶指针和栈底指针相等，则表示栈为空。

![image-20240413222554426](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413222554426.png) 

```c
bool isEmpty(SqStack *stack) {
    return stack->top == stack->base;  // 栈顶指针等于栈底指针表示栈为空
}
```

##### 栈的长度

> 栈顶指针和栈底指针之间的距离来计算。栈的长度等于栈顶指针减去栈底指针的值。

![image-20240413222731759](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413222731759.png) 

```c
// 获取栈的长度
int stackLength(SqStack *stack) {
    return stack->top - stack->base;  // 栈顶指针减去栈底指针的值即为栈的长度
}
```



##### 清空顺序栈

> 简单地将栈顶指针指向栈底，这样原先在栈中的元素就不再被认为是栈中的元素，即视为空栈状态。

![image-20240413223013222](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413223013222.png)  

```c
// 清空栈
void clearStack(SqStack *stack) {
    stack->top = stack->base;  // 将栈顶指针指向栈底，即清空栈
}
```

##### 销毁栈

> 要销毁栈，需要**释放栈所占用的内存空间**，并将**栈的指针置为 NULL**，以防止误用。

![image-20240413223113467](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413223113467.png) 

```c
// 销毁栈
void destroyStack(SqStack *stack) {
    free(stack->base);  // 释放内存空间
    stack->base = NULL;  // 栈底指针置为NULL
    stack->top = NULL;   // 栈顶指针置为NULL
    stack->stackSize = 0;  // 栈的最大容量置为0
}
```

##### 入栈PUSH

> 入栈操作即将元素压入栈中，需要将元素放置在栈顶位置，并更新栈顶指针。

![image-20240413223431872](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413223431872.png)

> 联写的话
>  先执行赋值操作。后++

```c
// 入栈操作
void push(SqStack *stack, int element) {
    // 判断栈是否已满
    if (stack->top - stack->base == stack->stackSize) {
        printf("栈都满了！\n");
        return;
    }
    // 将元素放置在栈顶位置，并更新栈顶指针
    *(stack->top) = element;
    stack->top++;
}
```

##### 出栈POP

> 出栈操作即将**栈顶元素移出栈**，需要将**栈顶元素取出并更新栈顶指针**。

![image-20240413224317469](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413224317469.png)

> 后置递+-优先级高于解引用
> 前置递+-优先级低于解引用

```c
// 出栈操作
bool pop(SqStack *stack, int *element) {
    // 判断栈是否为空
    if (isEmpty(stack)) {
        printf("Error: 栈是空的！\n");
        return false;
    }
    // 将栈顶元素取出，并更新栈顶指针
    stack->top--;
    //*element =*(--stack->top);
    *element = *(stack->top);
    return true;
}
```





### 栈的链式表示和实现

#### 链栈的表示

```c
typedef struct StackNode{
	SElemType data;//数据域
	struct StackNode *next;//指针 域
}StackNode,*LinkStack;
LinkStack S; 
```

> [类似链表的头插](https://xu-runbo.gitee.io/xu-runbo/post/cadd49f.html#单链表的建立-头插法-前插法)
>
> 灵活的，只是这样方便

![image-20240413225814407](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413225814407.png) 

#### 为什么引入链栈

引入链栈的主要目的是解决顺序栈（数组实现的栈）固定容量的限制。

链栈使用链表作为底层数据结构，可以根据需要动态地增加或减少栈的大小。

1. **动态扩展**：链栈可以根据实际需要动态地分配内存空间，不受固定容量的限制。这意味着可以处理任意数量的元素，而不会发生栈溢出的情况。
2. **灵活性**：由于链栈的大小没有固定限制，因此可以根据需要随时增加或减少栈的大小，使其更加灵活适应不同的应用场景。
3. **节省内存**：链栈只使用了必要的内存空间来存储元素和指针，不会浪费额外的空间。相比之下，顺序栈需要预先分配一定大小的内存空间，可能会造成空间的浪费。
4. **便于操作**：链栈的节点结构可以轻松地插入和删除，操作相对简单。这使得链栈在某些情况下更加方便，例如在需要频繁进行栈大小变动的场景下。



#### 空栈

头指针指向NULL就是空

#### 链栈的操作和实现

##### 栈的初始化

> 初始化操作主要是将链栈的头指针置为空，表示链栈中没有任何节点。

![image-20240413230223293](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413230223293.png) 

```c
// 初始化链栈
void InitStack(LinkStack S) {
    S = NULL;  // 将链栈头指针置空
}
```





##### 栈是否为空

> 如果链栈为空，则头指针为空；如果链栈非空，则头指针指向链栈的第一个节点。

![image-20240413230415689](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413230415689.png) 

```c
// 判断链栈是否为空
int IsEmpty(LinkStack S) {
    return S == NULL;  // 如果头指针为空，则链栈为空
}
```



##### 入栈PUSH

> 入栈操作 PUSH 需要**创建一个新节点，将数据压入栈顶，并将链栈的头指针指向新节点**。

![image-20240413230930164](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413230930164.png) 

```c
// 入栈操作 PUSH
void Push(LinkStack S, SElemType e) {
    // 创建新节点
    StackNode *newNode = (StackNode *)malloc(sizeof(StackNode));
    if (newNode == NULL) {
        printf("内存分配失败\n");
        exit(1);
    }
    // 将数据压入新节点
    newNode->data = e;
    
    
    // 新节点指向原栈顶元素
    newNode->next = S;
    // 更新链栈的头指针，使其指向新节点
    S = newNode;
}

```



##### 出栈POP

> 出栈操作即将链栈的栈顶元素删除，并返回其数值。

![image-20240413231004202](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413231004202.png) 

```c
// 出栈操作 POP
SElemType Pop(LinkStack S) {
    if (IsEmpty(S)) {
        printf("栈为空，无法出栈\n");
        exit(1);
    }//或者if(*s==null)return ERROR;
    // 保存栈顶元素的值
    SElemType topElem = (S)->data;
    // 暂存栈顶节点
    StackNode *temp = S;
    // 头指针指向下一个节点，即出栈
    S = (S)->next;
    // 释放原栈顶节点的内存空间
    free(temp);
    return topElem;
}

```



##### 取栈顶元素

![image-20240413231515360](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240413231515360.png) 

```c
// 取栈顶元素 GetTop
SElemType GetTop(LinkStack S) {
    if (IsEmpty(S)) {
        printf("栈为空，无法取栈顶元素\n");
        exit(1);
    }
    return S->data; // 返回栈顶元素值
}

```











## 栈与递归

### 递归的定义

![image-20240414103917723](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414103917723.png) 

递归是一种在**函数定义中使用函数自身的方法**。，递归通常用于解决可以被分解为相似子问题的问题，其中每个子问题都是该问题的更小实例。递归的定义可以分为两个部分：

1. 基本情况（Base Case）：定义递归的结束条件，当满足这些条件时，递归不再继续执行，而是返回一个确定的值。
2. 递归步骤（Recursive Step）：定义递归函数的具体操作，通常是将问题分解为更小的子问题，并调用自身来解决这些子问题。

递归的典型特点包括简洁性和表达能力强，但在使用时需要注意递归深度过深可能导致栈溢出的问题。

因此，在编写递归函数时，需要确保递归能够终止，并且要考虑性能和内存消耗。

### 递归定义的数学函数

菲波那契数列（Fibonacci sequence）是一个经典的数学问题，其定义如下：

1. 第一个和第二个数字为 1。
2. 从第三个数字开始，每个数字都是前两个数字之和。

数列的前几个数字依次是：1, 1, 2, 3, 5, 8, 13, 21, ...

#### 菲波那契数列

##### 递归解决

```c
#include <stdio.h>

int fibonacci_recursive(int n) {
    if (n <= 1)
        return n;
    else
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2);
}

int main() {
    int n = 10; // 第10个数
    int result = fibonacci_recursive(n);
    printf("第 %d 个斐波那契数是：%d\n", n, result);
    return 0;
}

```



##### 迭代解决

```c
#include <stdio.h>

int fibonacci_iterative(int n) {
    if (n <= 1)
        return n;

    int prev1 = 0, prev2 = 1, curr;
    for (int i = 2; i <= n; i++) {
        curr = prev1 + prev2;
        prev1 = prev2;
        prev2 = curr;
    }
    return curr;
}

int main() {
    int n = 10; // 第10个数
    int result = fibonacci_iterative(n);
    printf("第 %d 个斐波那契数是：%d\n", n, result);
    return 0;
}

```



#### 迷宫问题



#### Hanoi塔问题

汉诺塔问题是一个经典的递归问题，通常用于演示递归算法的原理。问题的描述是：有三根柱子（编号为A、B、C），在A柱子上从下往上按照大小顺序摞着64个圆盘，现在要把这64个圆盘从A柱子移动到C柱子，移动过程中可以借助B柱子，但有以下限制条件：

1. 每次只能移动一个圆盘；
2. 大圆盘不能叠在小圆盘上。

### 分治法

![image-20240414104436093](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414104436093.png) 

![image-20240414104545136](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414104545136.png) 

#### 调用过程

调用栈和执行栈是相反的

调用f(3)发现f(2)再发现f(1)

执行f(1)然后再f(1)结果的基础上f(2)最后是f(3);

![image-20240414104802394](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414104802394.png) 



### 函数的嵌套调用

![image-20240414105100543](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105100543.png)



### n的阶乘问题

![image-20240414105122915](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105122915.png) 

#### 递归函数调用的实现

![image-20240414105319780](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105319780.png) 

![image-20240414105415535](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105415535.png) 





### 递归的优缺点

优点包括：

1. **简洁清晰**：递归能够将复杂的问题简化成相对简单的子问题，使得代码结构更加清晰易懂。
2. **可读性强**：递归代码通常具有直观的逻辑结构，易于理解和阅读。
3. **代码复用**：递归能够将问题分解成可复用的模块，提高代码的复用性。
4. **实现简单**：某些问题使用递归方法解决会比迭代更为简单和直观。

缺点包括：

1. **性能损耗**：递归调用会增加额外的函数调用开销和内存消耗，可能导致性能下降。
2. **内存消耗**：递归深度过深时可能导致栈溢出，因为每次递归调用都需要在内存中保存函数的上下文信息。
3. **可能陷入死循环**：如果递归条件设置不当或者终止条件不明确，可能导致递归调用无法终止，陷入死循环。
5. **效率低下**：某些问题使用递归方法解决可能效率较低，比如斐波那契数列的递归解法会出现重复计算。

![image-20240414105537498](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105537498.png) 

#### 转化为非递归

![image-20240414105712780](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105712780.png) 

![image-20240414105700678](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105700678.png) 

![image-20240414105602112](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414105602112.png) 







## 队列的表示和操作的实现

### 队列的抽象数据类型定义

  ![image-20240414110028947](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414110028947.png) 



### 队列的顺序表示和实现

#### 队列的顺序表示

![image-20240414110306422](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414110306422.png) 

```c
#define MAXSIZE 100  // 定义队列的最大容量

typedef struct {
    QElemType *base  // 初始化的动态分配存储空间
    int front;  // 队头指针 下标
    int rear;   // 队尾指针 下标
} SeqQueue;

```

#### 溢出问题

![image-20240414110931009](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414110931009.png) 

下标范围[0,maxsize-1];

![image-20240414110850983](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414110850983.png) 

> front出去后后面自动移动一下就好了

##### 如何解决？

![image-20240414111226932](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414111226932.png) 

![image-20240414111658648](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414111658648.png)  

#### 空队和满队

![image-20240414112042777](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414112042777.png)

##### 如何解决？

![image-20240414112155952](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414112155952.png) 



#### 队列的操作和实现

##### 队列的初始化

> 动态分配一个存储空间给队列，并将队头和队尾指针初始化为0。 

![image-20240414220602197](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414220602197.png) 

```c
// 初始化队列
void InitQueue(SeqQueue *Q) {
    Q->base = (QElemType *)malloc(MAXSIZE * sizeof(QElemType)); // 分配存储空间
    if (!Q->base) {
        printf("初始化失败，存储空间分配失败！\n");
        exit(EXIT_FAILURE);
    }
    Q->front = Q->rear = 0; // 队头和队尾指针初始化为0，表示空队列
}
```

##### 队列的长度

> 队尾指针 rear 减去队头指针 front，并且考虑到循环队列的特性，所以需要使用取模运算。 

![image-20240414220822866](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414220822866.png) 

```c
// 计算队列长度
int QueueLength(SeqQueue Q) {
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;//包括循环队列的情况
}
```



##### 队列的入队

> 检查队列是否已满，如果队尾指针 `rear` 的下一个位置与队头指针 `front` 相同，则表示队列已满，无法入队。如果队列未满，则将新元素插入队尾，并更新 `rear` 指针。

![image-20240414221003643](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414221003643.png) 

```c
// 入队操作
int EnQueue(SeqQueue *Q, QElemType e) {
    // 队列已满，无法入队
    if ((Q->rear + 1) % MAXSIZE == Q->front) {
        printf("队列已满，入队失败！\n");
        return 0; // 返回0表示入队失败
    }
    // 将新元素插入队尾，并更新 rear 指针
    Q->base[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return 1; // 返回1表示入队成功
}

```

##### 队列的出队

> 检查队列是否为空，如果队头指针 `front` 等于队尾指针 `rear`，则表示队列为空，无法出队。如果队列不为空，则将队头元素存储到 `e` 中，并将 `front` 指针后移一位。

![image-20240414221055842](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414221055842.png) 

```c
// 出队操作
int DeQueue(SeqQueue *Q, QElemType *e) {
    // 队列为空，无法出队
    if (Q->front == Q->rear) {
        printf("队列为空，出队失败！\n");
        return 0; // 返回0表示出队失败
    }
    // 获取队头元素，并更新 front 指针
    *e = Q->base[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
    return 1; // 返回1表示出队成功
}

```

##### 取队头元素

> 先检查队列是否为空，如果队头指针 `front` 等于队尾指针 `rear`，则表示队列为空，无法取队头元素。如果队列不为空，则将队头元素存储到 `e` 中。 

![image-20240414221158026](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414221158026.png) 

```c
// 取队头元素
int GetHead(SeqQueue Q, QElemType *e) {
    // 队列为空，无法取队头元素
    if (Q.front == Q.rear) {
        printf("队列为空，无法取队头元素！\n");
        return 0; // 返回0表示取队头元素失败
    }
    // 将队头元素赋值给 e
    *e = Q.base[Q.front];
    return 1; // 返回1表示取队头元素成功
}

```

### 队列的链式表示和实现

#### 队列的链式表示

![image-20240414221531152](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414221531152.png) 

```c
// 定义队列节点结构体
typedef struct QNode {
    QElemType data;         // 数据域
    struct QNode *next;     // 指针域，指向下一个节点
} QNode;

// 定义队列结构体
typedef struct {
    QNode *front;   // 队头指针
    QNode *rear;    // 队尾指针
} LinkQueue;
```

#### 链队列运算指针的变化

![image-20240414221832925](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414221832925.png) 

#### 链队列的操作和实现

##### 链队列的初始化

> 初始化操作通常包括创建头结点，并将队头指针和队尾指针都指向头结点。

![image-20240414222111888](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414222111888.png) 

```c
// 初始化队列
void InitQueue(LinkQueue *Q) {
    Q->front = Q->rear = (QNode *)malloc(sizeof(QNode)); // 创建头结点
    if (!Q->front) {
        printf("初始化失败，内存分配失败！\n");
        exit(EXIT_FAILURE);
    }
    Q->front->next = NULL; // 头结点的next指针置空
}
```



##### 销毁链队列

> 使用循环遍历链表中的所有节点，并释放它们的内存空间。最后，将队头指针和队尾指针都置空。

![image-20240414222254053](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414222254053.png) 

```c
// 销毁链队列
void DestroyQueue(LinkQueue *Q) {
    QNode *p = Q->front;
    while (p) {
        QNode *temp = p;
        p = p->next;
        free(temp);
    }
    Q->front = Q->rear = NULL; // 将队头指针和队尾指针置空
}
```

##### 链队列的入队

> 创建一个新的节点 `p`，然后将元素 `e` 存储到节点的数据域中，并将节点的指针域 `next` 置空。接着将新节点插入到队列的尾部，并更新队尾指针。

![image-20240414222521279](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414222521279.png) 

```c
// 链队列的入队操作
void EnQueue(LinkQueue *Q, QElemType e) {
    QNode *p = (QNode *)malloc(sizeof(QNode)); // 创建新节点
    if (!p) {
        printf("入队失败，内存分配失败！\n");
        exit(EXIT_FAILURE);
    }
    p->data = e;        // 将元素e存入节点数据域
    p->next = NULL;     // 新节点的next指针置空
    Q->rear->next = p;  // 将新节点插入队尾
    Q->rear = p;        // 更新队尾指针
}

```

##### 链队列的出队

> 检查队列是否为空，如果队头指针 `front` 等于队尾指针 `rear`，则表示队列为空，无法出队。如果队列不为空，则获取队头节点的数据域，并将头结点的指针域指向下一个节点。如果出队后队列为空，更新队尾指针指向头结点。最后，释放出队节点的内存空间。

![image-20240414223142924](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414223142924.png) 

注意删除最后一个元素的时候还要修改尾指针的指向，实现空！

![image-20240414223110131](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414223110131.png) 

```c
// 链队列的出队操作
int DeQueue(LinkQueue *Q, QElemType *e) {
    if (Q->front == Q->rear) { // 队列为空
        printf("队列为空，出队失败！\n");
        return 0; // 返回0表示出队失败
    }
    QNode *p = Q->front->next;  // 指向第一个实际节点
    *e = p->data;               // 获取队头元素
    Q->front->next = p->next;   // 将头结点的next指针指向下一个节点
    //---------------------------------------------
    if (Q->rear == p)           // 如果出队后队列为空
        Q->rear = Q->front;     // 更新rear指针指向头结点
     //---------------------------------------------
    free(p);                    // 释放出队节点的内存
    return 1;                   // 返回1表示出队成功
}

```

##### 链队列的队头元素

> 先检查队列是否为空，如果队头指针 `front` 等于队尾指针 `rear`，则表示队列为空，无法取队头元素。如果队列不为空，则将队头节点的数据域存储到 `e` 中。

![image-20240414223224414](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC3%E5%91%A8/image-20240414223224414.png)

```c
// 获取链队列的队头元素
int GetHead(LinkQueue Q, QElemType *e) {
    if (Q.front == Q.rear) { // 队列为空
        printf("队列为空，无法取队头元素！\n");
        return 0; // 返回0表示取队头元素失败
    }
    *e = Q.front->next->data; // 获取队头节点的数据域
    return 1; // 返回1表示取队头元素成功
}
```

## 运算符优先级顺序

1. **前置递增/递减运算符 (++/--)**: 优先级最高，它们会首先被执行。
2. 解引用运算符 (*): 位于前置递增/递减运算符之后，优先级较高。
3. 一元加号/减号运算符 (+/-): 位于解引用运算符之后，优先级较低。
4. **后置递增/递减运算符 (++)/--):** 位于一元加号/减号运算符之后，优先级较低。
5. 乘法/除法/求余运算符 (*, /, %): 优先级次于递增/递减运算符和一元运算符。
6. 加法/减法运算符 (+, -): 优先级最低，位于乘法/除法/求余运算符之后。
