# 树和二叉树

数据的逻辑结构

![](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418170144113.png) 

> 线性结构：一对一
>
> 非线性结构：一对多，多对多

## 树

### 什么是树形结构

> 树形结构是一种层级组织数据的方式，其中**每个元素都与其他元素形成了分层关系**，从而构成了树状的结构。树形结构的核心特点是它的**分层性**，其中**每个节点都可以有零个或多个子节点**，但**只有一个父节点**（除了根节点，它没有父节点）。这种结构使得数据可以以一种逻辑和有序的方式进行组织和访问
>
> 常见的应用包括文件系统、组织结构图和网站导航。

![image-20240418170310593](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418170310593.png) 

### 树的定义

> 树是由**根节点**和**一组子树构成的**，而**每个子树又可以递归地看作是树**。
>
> ---
>
> 1. **树包含一个根节点**，它没有父节点，且每个节点最多只有一个父节点。
> 2. 每个节点可以有**零个或多个子节点**，这些子节点与父节点之间通过边相连。
> 3. **从根节点到任意节点都存在唯一的路径。**
> 4. 没有环路，即树中不存在回路，任意节点到其祖先节点的路径都是唯一的。

![image-20240418170534603](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418170534603.png) 

### 树的表示

#### 树的表示

![image-20240418170803390](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418170803390.png) 

集合的表示(嵌套的集合)

![image-20240418170938326](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418170938326.png) 

### 有关树的基本术语

![image-20240418171848320](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418171848320.png) 

> 1. **根节点（Root）**：**树的起始节点，它没有父节点，是树的唯一入口点。**
> 2. **节点（Node）**：树中的一个元素，可以包含一个值，也可以包含其他附加信息。每个节点可能会有零个或多个子节点。
> 3. **父节点（Parent）**：一个节点的直接上级节点。
> 4. **子节点（Child）**：一个节点的直接下级节点。
> 5. 节点的层次：从根开始根为第一次层。
> 6. **叶子节点(终端节点)（Leaf）**：**没有子节点的节点**。
> 7. **路径（Path）**：从树的一个节点到另一个节点的序列，沿着树的边走过的节点构成一条路径。
> 8. 深度&&高度：树中节点的最大层次
> 9. 节点的**度**（Degree）是指该**节点拥有的子节点数量**，即它的子树的数量。

#### 有序树和无序树

有序树（Ordered Tree）和无序树（Unordered Tree）是树的两种基本类型

它们之间的主要区别在于**子节点的顺序是否重要。**

1. **有序树**：有序树中，**子节点的顺序是固定的**，每个子节点都有一个**特定的位置**。换句话说，具有不同顺序的子节点序列会产生不同的树结构。

   在有序树中，同一个节点的子节点之间存在顺序关系。

2. **无序树**：无序树中，子节点的顺序是不重要的，即使改变了子节点的顺序，树的结构仍然保持不变。

   在无序树中，同一个节点的子节点之间不存在顺序关系。

#### 森林

> m棵互不相交的树的集合

![image-20240418172855266](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418172855266.png) 

#### 线性结构和树结构的对比

![image-20240418172932271](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418172932271.png) 







## 二叉树

### 二叉树的定义

![image-20240418173502359](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418173502359.png) 

1. **每个节点最多有两个子节点**：每个节点最多可以有两个子节点，分别称为左子节点和右子节点。这两个子节点可以存在也可以不存在。
2. **子节点的顺序是有序的**：如果一个节点有两个子节点，那么它的左子节点和右子节点的顺序是固定的。

因为树的节点可以有0或多个分支，二叉树是特殊的，只有两个叉

> 而且所有的树都能转为唯一对应的二叉树
>
> 二叉树的操作简单，还可以和任何树相互转换
>
> 二叉树是有序树

#### 注意

![image-20240418173719225](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418173719225.png) 

#### 思考

![image-20240418174134192](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418174134192.png) 

#### 二叉树的5种基本形态

![image-20240418174229058](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418174229058.png) 







### 案例引入

#### 数据压缩问题

> 将数据文件转化为01组成的的人禁止串，称之为编码

 ![image-20240418183530328](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418183530328.png) 

学习哈夫曼树后来



#### 利用二叉树求解表达式的值

![image-20240418183726706](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418183726706.png) 



### 二叉树的抽象数据类型定义

![image-20240418183950690](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418183950690.png)   ![image-20240418184004390](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418184004390.png) 



### 二叉树的性质和存储结构

#### 二叉树的性质

##### 性质1i层上最多有

> 性质1：二叉树的第i层上最多有2<sup>i-1</sup>次方个节点(i>=1)33333333333333333333333333333

![image-20240418184300405](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418184300405.png) 

证明:

![image-20240418184420754](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418184420754.png) 

思考：

> 二叉树第i层上**至少有1个节点**

##### 深度为k的二叉树最多

> 深度为k的二叉树最多有2<sup>k</sup>-1个节点

等比数列求和

![image-20240418184813329](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418184813329.png) 

思考：

> 深度为k的二叉树最少有k个节点
>
> 单只的！



#####  n<sub>0</sub> = n<sub>2</sub> + 1。

对任何一棵二叉树 T，如果其叶子数为 n<sub>0</sub>，度为 2 的结点数为 n2，

则 n<sub>0</sub> = n<sub>2</sub> + 1。

![image-20240418185611681](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418185611681.png) s

证明：

分别从下到上和从上到下分析边数的问题，然后求解！

![image-20240418190012862](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240418190012862.png) 

![image-20240419103251226](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419103251226.png) 



### 特殊形式的二叉树

#### 满二叉树 

> 满二叉树是一种**特殊类型的二叉树**，它具有以下两个特点：
>
> 1. **每个节点要么没有子节点**，要么有两个子节点。
> 2. **所有叶子节点都在同一层级上**，即深度相同。
>
> 满二叉树的节点数目可以通过以下公式计算：假设树的高度为h，那么节点数目为2<sup>k</sup> - 1

![image-20240419103756506](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419103756506.png) 

##### 特点

> 满二叉树在**同样深度**的二叉树中**结点个数最多**
>
> 满二叉树在**同样深度**的二叉树中**叶子结点个数最多**

#### 完全二叉树

> **完全二叉树**是一种**特殊类型的二叉树**，它具有以下两个特点：
>
> 1. **所有的叶子节点都在最底层**或者**倒数第二层**，而且**最底层的叶子节点都集中在靠左的位置**。
> 2. **除了最底层，其它层的节点数都达到最大**，如果最底层不是满的，则缺少的节点集中在该层的右侧。
>
> 与满二叉树不同，完全二叉树在**保持层级结构的同时**，**允许最底层缺少一些节点**。这种特性使得完全二叉树在实际应用中更为灵活，因为它的节点数目相对较少，同时具有较好的平衡性能。完全二叉树通常用于堆数据结构的实现，以及在一些搜索和排序算法中。

![image-20240419104103260](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419104103260.png) 

![image-20240419104244324](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419104244324.png)

都不是完全二叉树

##### 注意

满二叉树是完全二叉树，1

> 注：在满二叉树中，从**最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树**
>
> **一定是连续的去掉！！！！**

![PixPin04-19_10-44-10](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/PixPin04-19_10-44-10.gif) 

##### 特点

> 特点：1.叶子只可能分布在层次最大的两层上
>
> 2.对任一结点，如果其右子树的最大层次为i
>
> **则其左子树的最大层次必为i或i+1.**
>
> 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树





#### 完全二叉树的性质

##### 性质 4

性质 4：具有 n 个结点的完全二叉树的深度为[log<sub>2</sub>n」+ 1。

![image-20240419105219910](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419105219910.png) 

###### 证明

![image-20240419105231440](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419105231440.png) 

我们可以通过数学归纳法来证明这个性质。

**基础情况：**  
当完全二叉树只有一个节点时，深度为1。  
当 n = 1 时，log<sub>2</sub>1 = 0，所以深度为 log<sub>2</sub>1 + 1 = 1，**基础情况成立。**

**归纳假设：**  
假设对于**具有 k 个节点的完全二叉树**，其深度为 log<sub>2</sub>k + 1 成立，其中 k ≥ 1。

**归纳步骤：**  
考虑一个具有 n = 2k + 1 或 n = 2k + 2 个节点的完全二叉树，我们来证明其深度为 log<sub>2</sub>n + 1。

1. 首先，我们观察到对于完全二叉树而言，**每一层的节点数都是2的幂次方**。因此，对于深度为 d 的完全二叉树，其节点数 n 满足以下不等式关系：
   **2<sup>d-1</sup> ≤ n < 2<sup>d</sup>**

2. 我们对不等式两边同时取对数，得到：
   log<sub>2</sub>(2<sup>d-1</sup>) ≤ log<sub>2</sub>n < log<sub>2</sub>(2<sup>d</sup>)

3. 进一步化简：
   d - 1 ≤ log<sub>2</sub>n < d

4. 由于深度 d 是整数，我们可以得出：
   d - 1 ≤ log<sub>2</sub>n < d + 1

5. 因此，我们得到了深度 d 的范围，即 log<sub>2</sub>n < d < log<sub>2</sub>n + 1。

根据归纳假设，对于 k 个节点的完全二叉树，其深度为 log<sub>2</sub>k + 1。当 n = 2k + 1 或 n = 2k + 2 时，我们有：
log<sub>2</sub>(2k + 1) < d < log<sub>2</sub>(2k + 1) + 1
或
log<sub>2</sub>(2k + 2) < d < log<sub>2</sub>(2k + 2) + 1

即 log<sub>2</sub>n < d < log<sub>2</sub>n + 1。所以，这个性质对于任意具有 n 个节点的完全二叉树成立，通过归纳法证明了这一点。

##### 性质5

 ![image-20240419110645868](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419110645868.png)

性质 5：如果对一棵有 n 个节点的完全二叉树进行层序遍历编号（从第 1 层到第 ?log<sub>2</sub>n? + 1 层，每层从左到右），则对任一节点 i（1 ≤ i ≤ n），有：

1. 如果 i = 1，则 i 是根节点；
2. 如果 i > 1，则节点 i 的父节点为 i/2（整除）；
3. 如果 2i > n，则节点 i 为叶子节点，没有左子节点；否则，节点 i 的左子节点为 2i
4. 如果 2i + 1 > n，则节点 i 没有右子节点；否则，右子节点为 2i + 1。

这个性质描述了在完全二叉树中，根据节点编号可以找到其父节点、左子节点和右子节点的规律。

###### 证明

我们可以通过数学归纳法来证明这个性质。

**基础情况：**
对于**完全二叉树中的第一个节点 i = 1**，显然它是根节点，且没有父节点，**左子节点为 2 * 1 = 2，右子节点为 2 * 1 + 1 = 3。**

**归纳假设：**
假设对于完全二叉树中的某个节点 i（其中 1 ≤ i ≤ n），其父节点、左子节点和右子节点的关系满足描述。





**归纳步骤：**
考虑完全二叉树中的任意节点 i，我们来证明其父节点、左子节点和右子节点的关系仍然满足描述。

1. 如果 2i > n，**则节点 i 没有左子节点。这是因为节点 i 的左子节点编号为 2i**，但是大于了总节点数 n，意味着树中**不存在编号为 2i 的节点**，因此节点 i **没有左子节点**。这也符合描述中的要求。
2. 如果 2i + 1 > n，**则节点 i 没有右子节点**。同样的道理，节点 i 的**右子节点编号为 2i + 1**，但是大于了总节点数 n，所以**节点 i 没有右子节点**，也满足描述中的要求。
3. 对于其余情况，即 2i ≤ n 且 2i + 1 ≤ n，节点 i 存在左子节点和右子节点。这个情况下，根据归纳假设，节点 i 的左子节点为 2i，右子节点为 2i + 1，依然符合描述。

综上所述，对于完全二叉树中的任意节点 i，其父节点、左子节点和右子节点的关系满足描述。因此，这个性质得到了证明。



### 二叉树的存储结构



#### 二叉树的顺序存储

##### 存储结构

```c
//二叉树的顺序存储
#define MAXSIZE 100
typedef TElemType SqBiTree[MAXSIZE];
SqBiTree bt;
```



> 按满二叉树的节点层次编号，依次存放二叉树种的元素

##### 完全二叉树如何存储？

![image-20240419114759771](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419114759771.png) 

##### 一般二叉树如何存储？

> 那就按照满而二叉树那样标号，然后有元素的放元素，没有的就放空，要正确的描述空节点

![image-20240419115158849](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419115158849.png) 

##### 顺序存储还原二叉树

> 先画出对应 的满二叉树并编号，然后一一填空

![image-20240419115449058](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419115449058.png) 

##### 顺序存储的特点

> 1. 大小固定，定长的，就不灵活
> 2. 空节点在顺序表中不存或者存空，必须空一些元素，所以最坏的情况下却要浪费很多空间(`最坏的情况例如右单只树`),存储密度小

![image-20240419115719988](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419115719988.png) 

> 所以适合满二叉树或者完全二叉树存储！
>
> 特点:**结点间关系蕴含在其存储位置中**
>
> 浪费空间，适于存满二叉树和完全二叉树



#### 二叉树的链式存储

##### 二叉链表

![image-20240419115948161](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419115948161.png) 

###### 二叉链表存储结构

```c
typedef struct BiNode {
    TElemType data;
    struct BiNode *lchild, *rchild; // 左右孩子指针
} BiNode, *BiTree;

```

BiNode, BiTree分别是用来定义变量和对应的指针类型



##### 图形描述

> 有了头指针，然后顺藤摸瓜

![image-20240419120445797](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419120445797.png) 

##### 思考？

> 在**n个节点的二叉链表**中，有多少个**空指针域**？
>
> 分析：**必有2n个链域**。也就是2n个指针域！
>
> 除根结点外每个结点有且仅有一个双亲
>
> 所以只会有n－1个结点的链域存放指针指向非空子女结点
>
> （数边，除了根节点没有指向双亲的线，其他的节点都有，所以就是n-1）
>
> ---
>
> **空指针树=2n-(n-1)=n+1个**

##### 三叉链表

![image-20240419120921990](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419120921990.png) 

###### 三叉链表存储结构

> 又多了一个指向双亲的指针！

```c
typedef struct TriTNode {
    TElemType data;
    struct TriTNode *lchild, *parent, *rchild;
} TriTNode, *TriTree;

```



### 遍历二叉树

#### 概括

> 遍历定义一一**顺着某一条搜索路径巡访二叉树中的结点**，使得**每个结点均被访问一次**，而且**仅被访问一次** (又称周游)

`"访问”`的含义很广，可以是对结点作各种处理

如：输出结点的信息、修改结点的数据值等，但要求这种访问**不破坏原来的数据结构。**

> **遍历目的一一得到树中所有结点的一个线性排列**

> **遍历用途――它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心**

#### 遍历方法

![image-20240419121410451](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419121410451.png) 

若规定先左后右，则只有前三种情况：

> DLR先 (根)序遍历
>
> LDR中 (根)序遍历
>
> LRD一后 (根)序遍历

![image-20240419121535386](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419121535386.png) 

#### 遍历方法的算法描述

| 先序遍历                   | 中序遍历                       | 后序遍历                       |
| -------------------------- | ------------------------------ | ------------------------------ |
| 若二叉树为空，则空操作否则 | 否则若二叉树为空，则空操作否则 | 否则若二叉树为空，则空操作否则 |
| (1) **先序遍历左子树**     | (1) **中序遍历**左子树         | (1) **后序遍历左子树**         |
| (2) **先序遍历右子树**     | (2) 访问**根结点**             | (2) **后序遍历右子树**         |
| (3) **访问根结点**         | (3) **中序遍历**右子树         | (3) **访问根结点**             |

> 由二叉树的递归定义可知，遍历左子树和遍历右子树**可如同遍历二叉树一样“递归”进行**



#### 遍历的操作定义

##### 先序遍历

![image-20240419122641368](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122641368.png) 

![image-20240419122507427](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122507427.png) 

#####   中序遍历

![image-20240419122845181](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122845181.png) 

![image-20240419122516909](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122516909.png) 

#####   后序遍历

![image-20240419123035357](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419123035357.png) 

![image-20240419122526422](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122526422.png) 







##### 案例

![image-20240419122051004](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122051004.png) ![image-20240419122712901](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122712901.png) 

> 先序遍历:A  B  E  L  D  H  M  I  J

![image-20240419122859912](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419122859912.png) 

> 中遍历: E	L	B	A	M	H	I	D	J

![image-20240419123048287](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419123048287.png) 

> 后续遍历：L	E	B	M	I	H	J	D	A

##### 例子

![image-20240419123215169](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419123215169.png) 

##### 用二叉树表示算数表达式

![image-20240419123343848](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419123343848.png) 

#### 根据遍历序列得到二叉树

>  若二叉树中各节点的值均不相同，则二叉树节点的先序序列、中序序列和后序序列都是唯一的。
>
> 由二叉树的
>
> **先序序列和中序序列**或**由二叉树的后序序列和中序序列**
>
> 可以**确定唯一的一棵二叉树**。
>
> 只有先后是不可以确定一颗二叉树的

##### 要掌握的技巧

根据先序或者后续得到根

然后根据中序得到简单的字树分布

> 根据先序和后序可以得到
>
> 1. 谁是根？
> 2. 根的左右子树是？
> 3. 逐渐确定二叉树

##### 例题

![image-20240419130301074](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419130301074.png) 

![image-20240419130228410](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419130228410.png) 

---

![image-20240419130424971](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419130424971.png) 



#### 递归遍历算法的实现

##### 先序遍历

![image-20240419142651673](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419142651673.png)

![image-20240419143122616](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419143122616.png)  

> 递归！
>
> 1. 访问根节点。
> 2. 递归地对左子树进行先序遍历。
> 3. 递归地对右子树进行先序遍历。

```c
// 定义二叉树节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;
// 先序遍历函数
void preorderTraversal(TreeNode* root) {
    if (root == NULL) {
        return;
    }
    // 访问根节点
    printf("%d ", root->val);
    // 递归遍历左子树
    preorderTraversal(root->left);
    // 递归遍历右子树
    preorderTraversal(root->right);
}
```

> 先序的遍历序列:ABDC

![image-20240419143536420](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419143536420.png) 

##### 中序遍历

> 若二叉树为空，则空操作
>
> 否则：中序遍历左子树（L）访问根结点（D）中序遍历右子树对（R）

![image-20240419144041192](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419144041192.png)

![image-20240419144156214](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419144156214.png)  

```c
// 定义二叉树节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
} TreeNode;

// 中序遍历函数
void inorderTraversal(TreeNode* root) {
    if (root == NULL) {
        return;
    }
    // 递归遍历左子树
    inorderTraversal(root->left);
    // 访问根节点
    printf("%d ", root->val);
    // 递归遍历右子树
    inorderTraversal(root->right);
}
```

##### 后续遍历

> 若二叉树为空，则空操作否则
>
> 后序遍历左子树
>
> 后序遍历右子树汇(R)
>
> 访问根结点(D)

![image-20240419144301682](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419144301682.png) 

##### 区别

![image-20240419144350672](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419144350672.png) 

![image-20240419144540381](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419144540381.png) 

##### 复杂度分析

> 算法复杂度分析如下：
>
> 1. 时间复杂度：**每个节点都只会被访问一次，所以时间复杂度为 O(n)**，其中 **n 是二叉树中的节点数**。
>
> 2. 空间复杂度：**递归调用的栈空间是关键**。由于**每次递归调用都会压入栈中**，最坏情况下，**栈的深度等于二叉树的高度**。
>
>    对于平衡二叉树来说，树的高度为 log(n)，其中 n 是节点数。因此，空间复杂度为 **O(log(n))。**
>
>    而对于不平衡的二叉树，最坏情况下栈的深度为 n，此时空间复杂度为 **O(n)。**
>
> 总的来说，先序、中序和后序遍历算法的时间复杂度均为 O(n)，空间复杂度在平衡情况下为 O(log(n))，在最坏情况下为 O(n)。

#### 非递归遍历算法的实现

以中序遍历为例

> 用栈来实现

![image-20240419145245769](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419145245769.png) 

![PixPin04-19_14-55-54](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/PixPin04-19_14-55-54.gif) 

```c
// 中序遍历
void InOrderTraverse(BiTree T) {
    BiTree p = T;
    Stack S;
    InitStack(&S);
    while (p || !StackEmpty(S)) {
        if (p) {
            Push(&S, p);
            p = p->lchild;
        } else {
            Pop(&S, &p);
            printf("%c ", p->data);
            p = p->rchild;
        }
    }
}
```

难理解，理解每一次执行是谁入栈了，谁出栈了

#### 层次遍历算法

> 一层一层访问，每一层从左到右访问。

![image-20240419150249797](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419150249797.png) 

##### 算法实现

![image-20240419150328102](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419150328102.png) 

![PixPin04-19_15-11-42](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/PixPin04-19_15-11-42.gif)

##### 代码实现

![image-20240419151314745](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419151314745.png) 

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
} TreeNode;

// 定义队列结构
typedef struct QueueNode {
    TreeNode *data;
    struct QueueNode *next;
} QueueNode;

typedef struct {
    QueueNode *front;
    QueueNode *rear;
} Queue;

// 初始化队列
void initQueue(Queue *q) {
    q->front = NULL;
    q->rear = NULL;
}

// 入队
void enqueue(Queue *q, TreeNode *node) {
    QueueNode *newNode = (QueueNode *)malloc(sizeof(QueueNode));
    if (!newNode) {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(EXIT_FAILURE);
    }
    newNode->data = node;
    newNode->next = NULL;
    if (q->rear == NULL) {
        q->front = newNode;
        q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
}

// 出队
TreeNode *dequeue(Queue *q) {
    if (q->front == NULL) {
        return NULL;
    }
    QueueNode *temp = q->front;
    TreeNode *node = temp->data;
    q->front = q->front->next;
    if (q->front == NULL) {
        q->rear = NULL;
    }
    free(temp);
    return node;
}

// 层次遍历函数
void levelOrderTraversal(TreeNode *root) {
    if (root == NULL) {
        return;
    }

    Queue q;
    initQueue(&q);
    enqueue(&q, root);

    while (q.front != NULL) {
        TreeNode *node = dequeue(&q);
        printf("%d ", node->val);

        if (node->left != NULL) {
            enqueue(&q, node->left);
        }
        if (node->right != NULL) {
            enqueue(&q, node->right);
        }
    }
}

// 创建新节点的函数
TreeNode *createNode(int val) {
    TreeNode *newNode = (TreeNode *)malloc(sizeof(TreeNode));
    if (!newNode) {
        fprintf(stderr, "Memory allocation failed.\n");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

int main() {
    // 创建一棵示例二叉树
    TreeNode *root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);

    // 层次遍历二叉树
    printf("Level order traversal: ");
    levelOrderTraversal(root);
    printf("\n");

    // 释放内存
    free(root->left->right);
    free(root->left->left);
    free(root->right);
    free(root->left);
    free(root);

    return 0;
}

```

### ==遍历算法的应用==

#### 建立二叉树

> 先序遍历序列建立二叉链表

因为，仅仅根据先序序列，构造出来的二叉树不唯一

所以要改进,想要哪一种，然后补充对应的空节点，然后更新先序序列，然后键入

![image-20240419151913558](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419151913558.png) 

##### 代码实现

![image-20240419152623617](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419152623617.png)  

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct BiTNode {
    char data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 创建二叉树
int CreateBiTree(BiTree *T) {
    char ch;
    scanf("%c", &ch);
    getchar(); // 吸收输入缓冲区中的换行符

    if (ch == '#') {
        *T = NULL;
    } else {
        *T = (BiTNode *)malloc(sizeof(BiTNode));
        if (!*T) {
            exit(EXIT_FAILURE);
        }
        (*T)->data = ch;
        // 递归构造左子树
        if (CreateBiTree(&(*T)->lchild) == -1) {
            return -1;
        }
        // 递归构造右子树
        if (CreateBiTree(&(*T)->rchild) == -1) {
            return -1;
        }
    }
    return 0;
}

// 销毁二叉树
void DestroyBiTree(BiTree *T) {
    if (*T) {
        DestroyBiTree(&(*T)->lchild);
        DestroyBiTree(&(*T)->rchild);
        free(*T);
        *T = NULL;
    }
}

int main() {
    BiTree T;
    printf("请输入二叉树的先序序列（以“#”表示空节点）：\n");
    if (CreateBiTree(&T) == -1) {
        printf("二叉树构建失败。\n");
        return -1;
    }

    printf("二叉树构建成功。\n");

    // 销毁二叉树释放内存
    DestroyBiTree(&T);

    return 0;
}

```

#### 复制二叉树

以先序遍历

> 如果是空树，递归结束;
>
> 否则，申请新结点空间，复制根结点
>
>  + 递归复制左子树
> 	+ 递归复制右子树

```c
// 复制二叉树
int Copy(BiTree T, BiTree *NewT) {
    if (T == NULL) { // 如果是空树返回0
        *NewT = NULL;
        return 0;
    } else {
        *NewT = (BiTNode *)malloc(sizeof(BiTNode));
        if (!*NewT) {
            exit(EXIT_FAILURE);
        }
        (*NewT)->data = T->data;
        // 复制左子树
        Copy(T->lchild, &(*NewT)->lchild);
        // 复制右子树
        Copy(T->rchild, &(*NewT)->rchild);
    }
    return 0;
}
```



##### 代码实现

![image-20240419154145996](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419154145996.png) 

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct BiTNode {
    char data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 复制二叉树
int Copy(BiTree T, BiTree *NewT) {
    if (T == NULL) { // 如果是空树返回0
        *NewT = NULL;
        return 0;
    } else {
        *NewT = (BiTNode *)malloc(sizeof(BiTNode));
        if (!*NewT) {
            exit(EXIT_FAILURE);
        }
        (*NewT)->data = T->data;
        // 复制左子树
        Copy(T->lchild, &(*NewT)->lchild);
        // 复制右子树
        Copy(T->rchild, &(*NewT)->rchild);
    }
    return 0;
}

// 销毁二叉树
void DestroyBiTree(BiTree *T) {
    if (*T) {
        DestroyBiTree(&(*T)->lchild);
        DestroyBiTree(&(*T)->rchild);
        free(*T);
        *T = NULL;
    }
}

// 中序遍历二叉树
void InOrderTraversal(BiTree T) {
    if (T) {
        InOrderTraversal(T->lchild);
        printf("%c ", T->data);
        InOrderTraversal(T->rchild);
    }
}

int main() {
    BiTree T = NULL;
    // 创建一棵示例二叉树
    T = (BiTNode *)malloc(sizeof(BiTNode));
    T->data = 'A';
    T->lchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->lchild->data = 'B';
    T->lchild->lchild = NULL;
    T->lchild->rchild =(BiTNode *)malloc(sizeof(BiTNode));
    T->lchild->rchild->data = 'D'; // 将 'D' 作为 'B' 的右孩子
    
    T->lchild->rchild->lchild = NULL;
    T->lchild->rchild->rchild = NULL;
    
    T->rchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->rchild->data = 'C';
    T->rchild->lchild = NULL;
    T->rchild->rchild = NULL;

    // 复制二叉树
    BiTree NewT = NULL;
    Copy(T, &NewT);

    printf("原二叉树中序遍历结果：");
    InOrderTraversal(T);
    printf("\n");

    printf("复制的二叉树中序遍历结果：");
    InOrderTraversal(NewT);
    printf("\n");

    // 销毁原二叉树释放内存
    DestroyBiTree(&T);

    // 销毁复制的二叉树释放内存
    DestroyBiTree(&NewT);

    return 0;
}

```

![image-20240419153944602](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419153944602.png) 







#### 计算二叉树的深度

> 递归地计算左右子树的深度，并返回较大值加上根节点的深度。
>
> 1. 如果树为空，则深度为0。
> 2. 否则，递归地计算左子树的深度（左子树为空时深度为0），并将其存储在变量 `leftDepth` 中。
> 3. 递归地计算右子树的深度（右子树为空时深度为0），并将其存储在变量 `rightDepth` 中。
> 4. 返回左右子树深度的较大值加上1（因为根节点也算一层）作为树的深度。
>
> 这样的递归过程会不断地向下探索树的每个分支，直到遇到空节点为止。通过不断向上返回深度信息，并不断比较左右子树的深度，最终得到整棵树的深度。

```c
// 计算二叉树的深度
int TreeDepth(BiTree T) {
    if (T == NULL) {
        return 0;
    } else {
        // 递归计算左子树的深度
        int leftDepth = TreeDepth(T->lchild);
        // 递归计算右子树的深度
        int rightDepth = TreeDepth(T->rchild);
        // 返回左右子树深度的较大值加上根节点的深度（1）
        return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
    }
}
```



##### 代码实现

![image-20240419154531580](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419154531580.png) 

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct BiTNode {
    char data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 计算二叉树的深度
int TreeDepth(BiTree T) {
    if (T == NULL) {
        return 0;
    } else {
        // 递归计算左子树的深度
        int leftDepth = TreeDepth(T->lchild);
        // 递归计算右子树的深度
        int rightDepth = TreeDepth(T->rchild);
        // 返回左右子树深度的较大值加上根节点的深度（1）
        return (leftDepth > rightDepth ? leftDepth : rightDepth) + 1;
    }
}

int main() {
    // 创建一棵示例二叉树
    BiTree T = (BiTNode *)malloc(sizeof(BiTNode));
    T->data = 'A';
    T->lchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->lchild->data = 'B';
    T->lchild->lchild = NULL;
    T->lchild->rchild = NULL;
    T->rchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->rchild->data = 'C';
    T->rchild->lchild = NULL;
    T->rchild->rchild = NULL;

    // 计算二叉树的深度并输出结果
    printf("二叉树的深度为：%d\n", TreeDepth(T));

    // 释放二叉树的内存
    free(T->lchild);
    free(T->rchild);
    free(T);

    return 0;
}

```

![image-20240419154345990](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419154345990.png) 







#### 计算节点的总数

> 计算二叉树节点总数的方法也可以使用递归。
>
> 1. 如果树为空，则节点总数为0。
> 2. 否则，**节点总数为根节点的值**加上**左子树的节点总数**和**右子树的节点总数之和**。
> 3. **递归地计算左子树和右子树的节点总数，直到遇到空节点为止。**
>
> 通过这样的递归过程，我们可以依次计算出二叉树中所有节点的总数。这种方法会递归地向下探索每个分支，并将节点总数不断累加，直到遇到空节点为止。

```c
// 计算二叉树节点总数
int CountNodes(BiTree T) {
    if (T == NULL) {
        return 0; // 如果树为空，则节点总数为0
    } else {
        // 节点总数为根节点的值加上左子树的节点总数和右子树的节点总数之和
        return 1 + CountNodes(T->lchild) + CountNodes(T->rchild);
    }
}
```



##### 代码实现

![image-20240419154918844](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419154918844.png) 

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct BiTNode {
    char data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 计算二叉树节点总数
int CountNodes(BiTree T) {
    if (T == NULL) {
        return 0; // 如果树为空，则节点总数为0
    } else {
        // 节点总数为根节点的值加上左子树的节点总数和右子树的节点总数之和
        return 1 + CountNodes(T->lchild) + CountNodes(T->rchild);
    }
}

int main() {
    // 创建一棵示例二叉树
    BiTree T = (BiTNode *)malloc(sizeof(BiTNode));
    T->data = 'A';
    T->lchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->lchild->data = 'B';
    T->lchild->lchild = NULL;
    T->lchild->rchild = NULL;
    T->rchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->rchild->data = 'C';
    T->rchild->lchild = NULL;
    T->rchild->rchild = NULL;

    // 计算二叉树节点总数并输出结果
    printf("二叉树节点总数为：%d\n", CountNodes(T));

    // 释放二叉树的内存
    free(T->lchild);
    free(T->rchild);
    free(T);

    return 0;
}

```

![image-20240419154854929](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419154854929.png) 





#### 计算叶子节点的总数

> 计算二叉树叶子节点总数的思路也可以使用递归。
>
> 1. **如果树为空，则叶子节点总数为0。**
> 2. 如果树只有一个节点，则叶子节点总数为1（因为根节点是叶子节点）。
> 3. 否则，**叶子节点总数**为**左子树的叶子节点总数**加上**右子树的叶子节点总数**之和。
> 4. 递归地计算左子树和右子树的叶子节点总数，直到遇到叶子节点为止。
>
> 通过这样的递归过程，我们可以依次计算出二叉树中所有叶子节点的总数。这种方法会递归地向下探索每个分支，并将叶子节点总数不断累加，直到遇到叶子节点为止。

```c
// 计算二叉树叶子节点总数
int CountLeaves(BiTree T) {
    if (T == NULL) {
        return 0; // 1. 如果树为空，则叶子节点总数为0。这是递归的终止条件之一，因为空树没有叶子节点。
    } else if (T->lchild == NULL && T->rchild == NULL) {
        return 1; // 如果树只有一个节点，则叶子节点总数为1（根节点是叶子节点）
    } else {
        // 叶子节点总数为左子树的叶子节点总数加上右子树的叶子节点总数之和
        return CountLeaves(T->lchild) + CountLeaves(T->rchild);
    }
}
```



##### 算法实现

![image-20240419155444348](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240419155444348.png) 

```c
#include <stdio.h>
#include <stdlib.h>

// 定义二叉树节点结构
typedef struct BiTNode {
    char data;
    struct BiTNode *lchild, *rchild;
} BiTNode, *BiTree;

// 计算二叉树叶子节点总数
int CountLeaves(BiTree T) {
    if (T == NULL) {
        return 0; // 如果树为空，则叶子节点总数为0
    } else if (T->lchild == NULL && T->rchild == NULL) {
        return 1; // 如果树只有一个节点，则叶子节点总数为1（根节点是叶子节点）
    } else {
        // 叶子节点总数为左子树的叶子节点总数加上右子树的叶子节点总数之和
        return CountLeaves(T->lchild) + CountLeaves(T->rchild);
    }
}

int main() {
    // 创建一棵示例二叉树
    BiTree T = (BiTNode *)malloc(sizeof(BiTNode));
    T->data = 'A';
    T->lchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->lchild->data = 'B';
    T->lchild->lchild = NULL;
    T->lchild->rchild = NULL;
    T->rchild = (BiTNode *)malloc(sizeof(BiTNode));
    T->rchild->data = 'C';
    T->rchild->lchild = NULL;
    T->rchild->rchild = NULL;

    // 计算二叉树叶子节点总数并输出结果
    printf("二叉树叶子节点总数为：%d\n", CountLeaves(T));

    // 释放二叉树的内存
    free(T->lchild);
    free(T->rchild);
    free(T);

    return 0;
}

```

#### 忠告

> 要求:实现能自己写出
>
> 眼高手低不可取





### 线索二叉树

#### 为什么需要线索二叉树？

![image-20240421153436480](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421153436480.png) 

#### 线索二叉树的引入

解决的方法：**通过遍历 寻找费时间**

**再增设前驱、后继指针域增加了存储负担**

**利用二叉链表中的空指针域**

![image-20240421153651854](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421153651854.png) 

> 利用二叉链表中的空指针域
>
> 如果某个节点的左孩子为空，则将空的左孩子指针域改为指向其前驱；
>
> 如果某节点的右孩子为空，则将空的右孩子指针域改为指向其后继。
>
> 这种改变指向的指针称为“线索”。加上了线索的二叉树称为线索二叉树（Threaded Binary Tree）。
>
> 对二叉树按某种遍历次序使其变为线索二叉树的过程叫做线索化。

#### 例子

> 画箭头，一般配合什么序遍历的线索二叉树,根据序列来对应前驱后继。。

![image-20240421154109218](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421154109218.png) 

#### 线索二叉树的节点的结构

但是一个节点只有lchild和rchild，如何区分是指向前驱还是左孩子呢？

> 为了区分 `lchild` 和 `rchild` 指针到底是指向孩子的指针还是指向前驱或后继的指针，对七叉链表中的每个节点增设两个标志域 `Itag` 和 `rtag`，并约定：
>
> - 当 `ltag=0` 时，`lchild` 指向该节点的左孩子；当 `ltag=1` 时，`lchild` 指向该节点的前驱。
> - 当 `rtag=0` 时，`rchild` 指向该节点的右孩子；当 `rtag=1` 时，`rchild` 指向该节点的后继。

##### 线索二叉树的结构

![image-20240421154403117](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421154403117.png) 

```c
typedef struct BiThrNode {
    int data;
    int Itag, rtag;
    struct BiThrNode *lchild, *rchild;
} BiThrNode, *BiThrTree;

```

#### 三种线索二叉树

##### 先序线索二叉树 

![image-20240421154541216](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421154541216.png) 

##### 中序线索二叉树

![image-20240421154604240](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421154604240.png) 

##### 后续线索二叉树

![image-20240421154729740](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421154729740.png) 

#### 引入头节点的线索二叉树

![image-20240421155125405](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421155125405.png) 

>  悬空了两个指针，空着也ok但是
>
> 可以增加一个头节点啊

![image-20240421155158632](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421155158632.png) 





## 树和森林

### 树的存储结构

#### 双亲表示法

> 双亲表示法是一种树的存储结构，用于表示树中节点之间的父子关系。
>
> 树中的每个节点，都有**一个指向其父节点的指针或索引**。
>
> 通常情况下，可以使用**一个数组来表示树的各个节点**，**数组中的每个元素存储一个节点的信息**，其中包括**节点的数据**以及**指向父节点的指针**或**父节点在数组中的索引**。

![image-20240421155952648](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421155952648.png) 

##### 实现

![image-20240421160254535](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421160254535.png) 

```c
// 树的节点结构
typedef struct TreeNode {
    int data; // 节点数据
    int parentIndex; // 父节点在数组中的索引
} TreeNode;

#define MAX_TREE_SIZE  100
// 树结构
typedef struct {
    TreeNode nodes[MAX_TREE_SIZE]; // 存储树中所有节点的数组
    int r,n; // 根节点的位置和树中节点的数量
} Tree;

```



##### 特点

> 1. **查找父节点方便：** 由于每个节点都知道其父节点的位置或索引，因此在双亲表示法中查找父节点非常方便和高效。
> 2. **查找兄弟节点需要遍历：** 虽然查找父节点方便，但是如果要查找兄弟节点，通常需要遍历父节点的子节点列表，相对而言效率略低。

#### 孩子链表

> **每个节点的孩子节点排列起来**，被视为一个**线性表**，**使用单链表存储**，因此对于**树中的每个节点**，都有一个孩子链表。
>
> 假设树中有 n 个节点，则有 n 个孩子链表（叶子节点的孩子链表为空表）。
>
> **孩子链表的头指针被组织成一个线性表**，使用顺序表（包含 n 个元素的结构数组）存储。

![image-20240421160749348](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421160749348.png) 

##### 实现

![image-20240421161221723](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421161221723.png) 

```c

typedef struct CTNode {
    int child;
    struct CTNode *next;
} *ChildPtr; // 孩子链表头指针

typedef struct {
    TElemType data;
    ChildPtr firstchild; // 孩子链表头指针
} CTBox; // 孩子结点结构

typedef struct {
    CTBox nodes[MAX_TREE_SIZE];
    int n, r; // 结点数和根结点的位置
} CTree; // 树结构

```

##### 特点

> 找孩子容易，找双亲难。



##### 结合双亲表示法

> 带双亲的孩子链表

![image-20240421161531880](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421161531880.png) 



#### ==孩子兄弟表示法==

> 二叉树表示法，二叉链表表示法;

实现：用二叉链表作树的存储结构，链表中每个结点的**两个指针域**分别指向其**第一个孩子结点**和下一个兄弟结点

![image-20240421162232557](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421162232557.png) 







##### 实现

```c
typedef struct CSNode {
    TElemType data;
    struct CSNode *firstchild;  // 指向第一个孩子节点
    struct CSNode *nextsibling; // 指向下一个兄弟节点
} CSNode, *CSTree;

```

##### 特点

> 找双亲比较困难，找孩子和兄弟方便
>
> 或者再增加指针域来解决





### 树和二叉树的转换

将树转化为二叉树进行处理，利用二叉树的算法来实现对树的操作

由于树和二叉树都可以用二叉链表作存储结构，则以**二叉链表作媒介**可以导出树与二叉树之间的一个对应关系。

![image-20240421163742101](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421163742101.png)  

#### 树转化为二叉树

==兄弟相连留长子==

> 1. 加线(兄弟连)
> 2. 抹线（摸出除了左孩子的线）也就是去除其与其他孩子之间的线条）
> 3. 靠地球引力就能看到二叉树了

树-》》》》》》》》》》》》》》》》》》》》》》》》》》》》》二叉树
![image-20240421164201774](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421164201774.png) 

##### 例子

![image-20240421164339643](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421164339643.png) 





#### 二叉树转换为树

==二叉树变树:左孩右右连双亲去掉原来右孩线==

> 1. 加线：若p结点是双亲结点的**左孩子**，则将p的右孩子，右孩子的右孩子....**沿分支找到的所有右孩子**，都与p的双亲用线连起来（找左孩子）
> 2. 抹线：抹掉原二叉树中双亲与右孩子之间的连线）
> 3. 调整：万有引力调整



##### 例子

![image-20240421164852992](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421164852992.png) 

### 森林和二叉树的转换

#### 森林转换二叉树

==森林变二叉树 树变二叉根相连==

> 森林转换成二叉树（二叉树与多棵树之间的关系）
>
> ①将各棵树分别转换成二叉树
>
> ②将每棵树的根结点用线相连
>
> ③以第一棵树根结点为二叉树的根再以根结点为轴心，顺时针旋转，构成二叉树型结构 

![image-20240421165719827](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421165719827.png) 

##### 例子

![image-20240421165735830](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421165735830.png) 





#### 二叉树转换为森林

①抹线：**将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树**

②还原：将孤立的二叉树还原成树

![image-20240421170722313](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421170722313.png) 

##### 例子

![image-20240421170757034](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421170757034.png) 





### 树和森林的遍历

与二叉树不同的是只有三种，树没中序，因为树可以有多个子树，根放哪里是中呢？

#### 树的遍历

##### 先根遍历

> 若树不空,则先访问根结点，然后依次先根遍历各棵子树。

##### 后根遍历

> 若树不空，则先依次后根遍历各棵子树，然后访问根结点。

##### 层次遍历

> 若树不空，贝则自上而下自左至右访问树中每个结点

![image-20240421172724892](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421172724892.png) 





#### 森林的遍历

将森林看作由三部分构成：

1.森林中第一棵树的根结点

2.柔森林中第一棵树的子树森林

3.柔森林中其它树构成的森林。

  ![image-20240421173609876](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421173609876.png) 

##### 先序遍历

> 若森林不空，则
>
> 1.访问**森林中第一棵树的根结点**；
>
> 2**先序遍历**森林中**第一棵树的子树森林**；
>
> 3.**先序遍历**森林中（除第一棵树之外）**其余树构成的森林**

##### 中序遍历

> 若森林不空，则
>
> 1.**中序遍历**森林中第一棵树的子树森林
>
> 2**.访问森林中第一棵树的根结点**;
>
> 3.**中序遍历**森林中(除第一棵树之外)其余树构成的森林即：
>
> **依次从左至右对森林中的每一棵树进行后根遍历。**

![image-20240421173853818](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240421173853818.png) 









## 哈夫曼树

### 哈夫曼树的概念

> 判断树：描述分类过程的二叉树

学生分数问题

![image-20240422101121813](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422101121813.png) 

> 哈夫曼树=最优二叉树

---

#### 相关术语

**路径**：从树中一个结点到另一个结点之间的分支构成这两个结点间的路径。

**结点的路径长度**：**两结点**间路径上的分支数

![image-20240422101501750](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422101501750.png) 

**树的路径长度**:从**树根**到每一个结点的路径长度之和记作：TL

![image-20240422101602465](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422101602465.png) 

> 结点树木相同的二叉树中，**完全二叉树**是**路径长度最短**的二叉树

> 但是路径长度最短的二叉树不一定是完全二叉树！

**权(weight)**：将树中结点赋给一个**有着某种含义的数值**则这个数值称为该**结点的权**

**结点的带权路径长度**：从**根结点**到**该结点之间的路径长度与该结点的权的乘积**。

**树的带权路径长度WPL：**树中**所有叶子结点**的**带权路径长度之和**



例子5

![image-20240422102936896](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422102936896.png) 



#### 哈夫曼树

> 哈夫曼树:**最优树**: **带权路径长度**最短的树
>
> ---
>
> **带权路径长度最短**”是在“**度相同**”的树中比较而得的结果，因此有最优二叉树、最优三叉树之称等等。

> 哈夫曼树:**最优二叉树**   :带权路径长度最短的二叉树
>
> ---
>
> 因为构造这种树的算法是由哈夫曼教授于1952年提出的,所以被称为哈夫曼树，相应的算法称为哈夫曼算法

![image-20240422103413590](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422103413590.png) 

> 权值小的距离根比较远，大的距离根近

### 哈夫曼树的构造算法

> 贪心算法：构造哈夫曼树时优先选择权值小的叶子节点



哈夫曼算法(构造哈夫曼树的方法

> （1）根据n个给定的权值{W1，W2，，Wn}构成 n棵二叉树的森林F={T1， T2, ……，Tn}其中 Ti **只有一个带权为 Wi的根结点。**
>
> + 构造森林全是根
>
> （2）**在F中选取两棵根结点的权值最小的树**作为**左右子树**，构造一棵新的二叉树，且设置**新的二叉树的根结点的权值**为其**左右子树上根结点的权值之和**。
>
> + 选用两小造新树
>
> （3）在F中删除这两棵树，同时将新得到的二叉树加入森林中。
>
> + 删除两小添新人
>
> （4）重复 (2)和(3)，直到森林中只有一棵树为止，这棵树即为哈夫曼树。
>
> + 重复2，3剩单根

![image-20240422120653452](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422120653452.png) 

> 哈夫曼树中的结点：度数只为0或者2    没有度为1的
>
> 包含n个叶子节点的哈夫曼树共有2*n-1个结点
>
> 
>
> 度为0的节点是n个
>
> 度为1的节点有0个
>
> 度为2的节点有n-1个

#### 例子

有5 个结点 a, b, c, d, e, 权值分别为 7,5, 5, 2, 4,构造哈夫曼树。

![image-20240422122308407](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240422122308407.png) 

#### 小结

> 1、在哈夫曼算法中，**初始时有n棵二叉树**，要**经过n-1次**合并**最终形成哈夫曼树。**
>
> 2、**经过 n-1 次合并产生 n-1 个新结点(度为2)**，且这n-1 个新结点都是具有两个孩子的分支结点。
>
> 可见：哈夫曼树中共有有 n(原来那n个度为0)+n-1(新产生的度为2的) = 2n-1个结点，且其所有的分支结点的**度均不为1。**



### 哈夫曼树构造算法的实现

> 采用顺序存储结构-----一维结构数组
>
> 节点类型定义

![image-20240423132457118](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423132457118.png) 

```c
// 节点类型定义
struct HuffmanNode {
    char data; // 存储字符数据
    int weight; // 权重，即字符出现的频率
    int parent; // 父节点在数组中的下标
    int lch; // 左孩子在数组中的下标
    int rch; // 右孩子在数组中的下标
};
```

#### 例子

![image-20240423132722385](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423132722385.png) 



#### 算法实现

> 1. 初始化哈夫曼树数组 `HT[1....2n-1]`：设置 `lch`、`rch`、`parent` 初始值为 0。
> 2. 输入初始的 `n` 个叶子结点：给 `HT[1...n]` 设置权重值。
> 3. 进行以下 `n-1` 次合并，依次产生 `n-1` 个结点 `HT[i]`，其中 `i=n+1....2n-1`：
>    - 在 `HT[1,i-1]` 中选择**两个未被选过（即 `parent == 0` 的结点）且权重最小的两个结点** `HT[s1]` 和 `HT[s2]`，其中 `s1`、`s2` 为两个最小结点的下标。
>    - 修改 `HT[s1]` 和 `HT[s2]` 的 `parent` 值为 `i`，即 `HT[s1].parent=i` 和 `HT[s2].parent=i`。
>    - 修改新产生的 `HT[i]`：
>      - 设置 `HT[i].weight=HT[s1].weight + HT[s2].weight`。
>      - 设置 `HT[i].lch=s1`。
>      - 设置 `HT[i].rch=s2`。
>

```c
// 续算法5.10
for (i = n + 1; i <= m; i++) {
    // 合并产生 n-1 个结点，构造 Huffman 树
    Select(HT, i - 1, s1, s2); // 在 HT[k] (1≤k≤i-1) 中选择两个其双亲域为 0，
                                // 且权值最小的结点，并返回它们在 HT 中的序号 s1 和 s2
    HT[s1].parent = i;
    HT[s2].parent = i; // 表示从 F 中删除 s1, s2
    HT[i].lch = s1;
    HT[i].rch = s2; // s1, s2 分别作为 i 的左右孩子
    HT[i].weight = HT[s1].weight + HT[s2].weight; // i 的权值为左右孩子权值之和
}

```

#### 练习

给出

![image-20240423133027807](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423133027807.png) 

写出

![image-20240423133051385](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423133051385.png) 





### 哈夫曼编码



#### 问题引入

![image-20240423133257400](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423133257400.png) 

##### 解决问题

> 若将编码设计为**长度不等的二进制编码**，即让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符串便可能减少。

![image-20240423133420997](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423133420997.png) 

##### 前缀编码

> 修正后的方法描述如下：
>
> 1. **统计字符集**中每个字符在电文中出**现的平均概率**，即每个字符出现的频率除以总字符数。**概率越大，要求编码越短。**
>
> 2. 利用哈夫曼树的特点：**权值越大的叶子离根越近**。将每个字符的概率值作为权值，构造哈夫曼树。这样概率越大的结点，路径越短。
>
> 3. 在哈夫曼树的每个分支上**标上0或1**：**结点的左分支标0，右分支标1**。将**从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码**。
>
> 利用哈夫曼树的特性，将字符的编码设计得更加高效，以实现数据的压缩。

##### 例子

![image-20240423133705428](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423133705428.png) 

![image-20240423133821256](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423133821256.png) 



【例】设组成电文的字符集D及其概率分布W为：D={A, B, C, D, E, F, G}

W={0.400.300.150.050.040.030.03}

![image-20240423134011200](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423134011200.png) 

> 虽然哈夫曼树在某些情况下可能**不唯一**，但是**它们都满足了哈夫曼编码的特性**，即**没有任何一个字符的编码是另一个字符编码的前缀**，因此在**解码时仍然能够正确还原原始数据**。

![image-20240423134030703](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423134030703.png)

#### 哈夫曼编码的算法实现

> n个结点
>
> 结束条件：双亲为空，也就是到根节点了
>
> 哈夫曼树的最长路径长度等于树中叶子节点的个数减一n-1
>
> 哈夫曼编码是一种前缀编码 频率高的字符编码较短，频率低的字符编码较长。
>
> 频率越高的字符放置得越接近根节点时，哈夫曼树的形态会更加平衡

![image-20240423134631270](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423134631270.png) 

倒着放，或者用栈来实现

```c
void CreatHuffmanCode(HuffmanTree HT, HuffmanCode &HC, int n) {
    HC = new char*[n + 1]; // 分配 n 个字符编码的头指针矢量
    char *cd = new char[n]; // 分配临时存放编码的动态数组空间
    cd[n - 1] = '\0'; // 编码结束符

    for (int i = 1; i <= n; i++) {
        int start = n - 1;
        int c = i;
        int f = HT[i].parent;
        while (f != 0) {
            --start; // 回溯一次，start 向前指一个位置
            if (HT[f].lchild == c)
                cd[start] = '0'; // 结点 c 是 f 的左孩子，则生成代码 '0'
            else
                cd[start] = '1'; // 结点 c 是 f 的右孩子，则生成代码 '1'
            c = f;
            f = HT[f].parent; // 继续向上回溯
        }
        // 求出第 i 个字符的编码
        HC[i] = new char[n - start]; // 为第 i 个字符串编码分配空间
        strcpy(HC[i], &cd[start]); // 将求得的编码从临时空间 cd 复制到 HC 的当前行中
    }

    delete[] cd; // 释放临时空间
}

```

#### 数组实现

```c
#include <iostream>
#include <cstring>
#include <unordered_map>
using namespace std;

// 定义哈夫曼树的结点结构体
typedef struct {
    char data; // 字符数据
    int weight; // 权重
    int parent, lchild, rchild; // 双亲、左孩子、右孩子的下标
} HuffmanNode, *HuffmanTree;

// 创建哈夫曼树
void CreateHuffmanTree(HuffmanTree &HT, unordered_map<char, int> &freq_map) {
    int n = freq_map.size();
    if (n <= 1) return;

    int m = 2 * n - 1; // 哈夫曼树的总结点数
    HT = new HuffmanNode[m + 1]; // 分配存储空间

    // 初始化叶子结点
    int i = 1;
    for (auto &entry : freq_map) {
        HT[i].data = entry.first;
        HT[i].weight = entry.second;
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
        i++;
    }

    // 初始化非叶子结点
    for (; i <= m; i++) {
        HT[i].weight = 0;
        HT[i].parent = 0;
        HT[i].lchild = 0;
        HT[i].rchild = 0;
    }

    // 构建哈夫曼树
    for (int i = n + 1; i <= m; i++) {
        int s1, s2;
        int min1 = INT_MAX, min2 = INT_MAX; // 寻找权重最小的两个结点
        for (int j = 1; j < i; j++) {
            if (HT[j].parent == 0 && HT[j].weight < min1) {
                min2 = min1;
                s2 = s1;
                min1 = HT[j].weight;
                s1 = j;
            } else if (HT[j].parent == 0 && HT[j].weight < min2) {
                min2 = HT[j].weight;
                s2 = j;
            }
        }
        HT[s1].parent = i;
        HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = min1 + min2;
    }
}

// 创建哈夫曼编码
void CreateHuffmanCode(HuffmanTree HT, char **&HC, unordered_map<char, string> &code_map, int n) {
    HC = new char*[n + 1]; // 分配 n 个字符编码的头指针矢量
    char *cd = new char[n]; // 分配临时存放编码的动态数组空间
    cd[n - 1] = '\0'; // 编码结束符

    for (int i = 1; i <= n; i++) {
        int start = n - 1;
        int c = i;
        int f = HT[i].parent;
        while (f != 0) {
            --start; // 回溯一次，start 向前指一个位置
            if (HT[f].lchild == c)
                cd[start] = '0'; // 结点 c 是 f 的左孩子，则生成代码 '0'
            else
                cd[start] = '1'; // 结点 c 是 f 的右孩子，则生成代码 '1'
            c = f;
            f = HT[f].parent; // 继续向上回溯
        }
        // 求出第 i 个字符的编码
        HC[i] = new char[n - start]; // 为第 i 个字符串编码分配空间
        strcpy(HC[i], &cd[start]); // 将求得的编码从临时空间 cd 复制到 HC 的当前行中

        // 将编码存入哈希表中
        code_map[HT[i].data] = string(HC[i]);
    }

    delete[] cd; // 释放临时空间
}

// 获取字符串中每个字符的频率
unordered_map<char, int> getFrequency(const string &str) {
    unordered_map<char, int> freq_map;
    for (char c : str) {
        freq_map[c]++;
    }
    return freq_map;
}

// 将字符串编码为哈夫曼编码
string encodeString(const string &str, unordered_map<char, string> &code_map) {
    string encoded_str;
    for (char c : str) {
        encoded_str += code_map[c];
    }
    return encoded_str;
}

int main() {
    string str = "hello";
    unordered_map<char, int> freq_map = getFrequency(str);

    HuffmanTree HT;
    CreateHuffmanTree(HT, freq_map);

    char **HC;
    unordered_map<char, string> code_map;
    CreateHuffmanCode(HT, HC, code_map, freq_map.size());

    // 输出哈夫曼编码
    cout << "Huffman Codes:" << endl;
    for (auto &entry : code_map) {
        cout << "Character " << entry.first << ": " << entry.second << endl;
    }

    // 将字符串编码为哈夫曼编码
    string encoded_str = encodeString(str, code_map);
    cout << "Encoded String: " << encoded_str << endl;

    // 释放内存
    for (int i = 1; i <= freq_map.size(); i++) {
        delete[] HC[i];
    }
    delete[] HC;
    delete[] HT;

    return 0;
}

```

![image-20240423140611797](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423140611797.png) 

#### 栈实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 结点定义
struct Node {
    char data;
    int frequency;
    struct Node* left;
    struct Node* right;
};

// 栈定义
struct StackNode {
    struct Node* node;
    struct StackNode* next;
};

struct Stack {
    struct StackNode* top;
};

// 创建新结点
struct Node* create_node(char data, int frequency) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->frequency = frequency;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 初始化栈
struct Stack* init_stack() {
    struct Stack* stack = (struct Stack*)malloc(sizeof(struct Stack));
    stack->top = NULL;
    return stack;
}

// 判断栈是否为空
int is_empty(struct Stack* stack) {
    return stack->top == NULL;
}

// 入栈
void push(struct Stack* stack, struct Node* node) {
    struct StackNode* newNode = (struct StackNode*)malloc(sizeof(struct StackNode));
    newNode->node = node;
    newNode->next = stack->top;
    stack->top = newNode;
}

// 出栈
struct Node* pop(struct Stack* stack) {
    if (is_empty(stack)) {
        return NULL;
    }
    struct StackNode* temp = stack->top;
    struct Node* node = temp->node;
    stack->top = temp->next;
    free(temp);
    return node;
}

// 哈夫曼编码
void huffman_encoding(struct Node* root, char* code, char** codes) {
    if (root) {
        if (!root->left && !root->right) {
            codes[root->data] = strdup(code);
        }
        char left_code[100], right_code[100];
        strcpy(left_code, code);
        strcpy(right_code, code);
        strcat(left_code, "0");
        strcat(right_code, "1");
        huffman_encoding(root->left, left_code, codes);
        huffman_encoding(root->right, right_code, codes);
    }
}

// 编码文本
char* encode_text(char* text, char** codes) {
    int len = strlen(text);
    char* encoded_text = (char*)malloc(len * 100); // 预留足够大的空间
    encoded_text[0] = '\0';
    for (int i = 0; i < len; i++) {
        strcat(encoded_text, codes[text[i]]);
    }
    return encoded_text;
}

int main() {
    char text[] = "hello";
    int frequencies[256] = {0}; // 假设字符集为 ASCII 码，共 256 个字符
    for (int i = 0; i < strlen(text); i++) {
        frequencies[text[i]]++;
    }

    // 构建哈夫曼树并获取编码
    struct Node* root = NULL;
    struct Stack* stack = init_stack();
    for (int i = 0; i < 256; i++) {
        if (frequencies[i] > 0) {
            struct Node* node = create_node(i, frequencies[i]);
            push(stack, node);
        }
    }
    while (stack->top->next) {
        struct Node* node1 = pop(stack);
        struct Node* node2 = pop(stack);
        struct Node* merged_node = create_node('\0', node1->frequency + node2->frequency);
        merged_node->left = node1;
        merged_node->right = node2;
        push(stack, merged_node);
    }
    root = pop(stack);

    // 获取编码
    char* codes[256] = {NULL};
    huffman_encoding(root, "", codes);

    // 编码文本
    char* encoded_text = encode_text(text, codes);

    // 输出结果
    printf("Huffman Codes:\n");
    for (int i = 0; i < 256; i++) {
        if (codes[i]) {
            printf("%c: %s\n", i, codes[i]);
        }
    }
    printf("Encoded Text: %s\n", encoded_text);

    // 释放内存
    free(encoded_text);
    return 0;
}

```

![image-20240423140813236](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423140813236.png) 

#### 文件的编码和解码

编码:

1. 输入各字符及其权值
2. **构造哈夫曼树HT[i]**
3. 进行哈夫曼编码-HC[i]
4. 查HC[j]，得到各字符的哈夫曼编码

解码:

1. **构造哈夫曼树**
2. 依次读入二进制码读入0，则走向左孩子；
3. 读入1，则走向右孩子
4. 一旦到达某叶子时，即可译出字符
5. 然后再从根出发继续译码，指导结束



![image-20240423140046827](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC5%E5%91%A8/image-20240423140046827.png) 
