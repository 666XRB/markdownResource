# 正则表达式

## 正则表达式概念

正则表达式（Regular Expression，简称Regex或RegExp）是一种用来**描述字符串模式**的工具

它提供了一种强大、灵活的方式来**匹配**、**搜索**和操作文本。

正则表达式是**由字符和特殊字符组成的字符串**，用于定义搜索模式。

正则表达式的主要用途包括：

1. **模式匹配（Pattern Matching）：** 正则表达式可以用来检查字符串是否符合某种模式。例如，可以使用正则表达式检查一个字符串是否是一个有效的邮箱地址或电话号码。
2. **文本搜索和替换：** 正则表达式允许你在文本中搜索特定的模式，并且可以用其他的文本替换匹配到的部分。这对于批量处理文本非常有用。
3. **数据验证：** 可以用正则表达式验证用户输入的数据是否符合特定的格式要求，比如密码强度检查。
4. **数据提取：** 正则表达式可以帮助你从文本中提取出需要的信息。例如，从一组文本中提取所有的链接或日期。
5. **语法分析：** 在一些编程语言和工具中，正则表达式被用来进行简单的语法分析，例如在词法分析器中。

## 快速使用

在JavaScript中，你可以使用正则表达式的直接量（regex literal）或者通过RegExp对象来创建正则表达式。

### 直接量

在JavaScript中，你可以使用斜杠（`/`）来定义正则表达式直接量。语法如下：

```javascript
let regexLiteral = /pattern/flags;
```

其中，`pattern`是你的正则表达式模式，`flags`是可选的标志，可以包括以下值：

- `i`: 不区分大小写匹配（case-insensitive）
- `g`: 全局匹配，匹配所有出现的模式而不仅仅是第一个
- `m`: 多行匹配

例如：

```javascript
let pattern = /abc/i; // 不区分大小写匹配"abc"
let globalPattern = /abc/g; // 全局匹配"abc"
let multiLinePattern = /abc/m; // 多行匹配"abc"
```

### RegExp对象

你也可以使用RegExp构造函数来创建正则表达式对象，语法如下：

```javascript
let regexObject = new RegExp("pattern", "flags");
```

同样，`pattern`是正则表达式模式，`flags`是可选的标志。需要注意的是，在使用RegExp对象时，**模式字符串需要以字符串的形式传递，所以需要使用双引号或单引号**。

例如：

```javascript
let pattern = "abc";
let flags = "i";
let regexObject = new RegExp(pattern, flags); // 不区分大小写匹配"abc"
```

### 使用正则表达式：

无论是直接量还是RegExp对象，创建后的正则表达式**都可以用于字符串的匹配、搜索和其他操作**。例如：

```javascript
let regex = /abc/i; // 或者 new RegExp("abc", "i");
//创建了一个正则表达式对象 `regex`。正则表达式的模式是 `abc`，并且使用了标志 `i`，表示不区分大小写匹配。
let testString = "AbC is case insensitive";

if (regex.test(testString)) {
  console.log("Match found!");
} else {
  console.log("No match found.");
}
```

> 涉及的知识：
>
> 
>
> 正则表达式对象的 `test` 方法来测试字符串是否匹配正则表达式的模式。`test` 方法**返回一个布尔值**，如果字符串中存在匹配项，则返回 `true`，否则返回 `false`。



## 语法汇总

》》》

> 正则表达式的语法包含一些基本元字符和模式，这些元字符和模式用于定义匹配规则。以下是一些常见的元字符和模式：
>
> 1. **字符匹配：**
>    - `abc`: 匹配字符串中的 "abc"。
>
> 2. **元字符：**
>    - `.`: 匹配**任意单个字符**，**除了换行符**。
>    - `^`: 匹配**字符串的开始**。
>    - `$`: 匹配**字符串的结束**。
>
> 3. **字符类别：**
>    - `[]`: **匹配方括号内的任一字符**。
>      - 例如，`[aeiou]` 匹配**任何一个元音字母**。
>      - `[^0-9]` 匹配除了数字以外的任何字符。
>
> 4. **预定义字符类别：**
>    - `\d`: 匹配**任意数字字符**（相当于 `[0-9]`）。
>    - `\D`: 匹配**任意非数字字符**。
>    - `\w`: 匹配**任意字母、数字、下划线字符**（相当于 `[a-zA-Z0-9_]`）。
>    - `\W`: 匹配任意非字母、数字、下划线字符。
>    - `\s`: 匹配**任意空白字符，包括空格、制表符等**。
>    - `\S`: 匹配任意非空白字符。
>
> 5. **量词：**
>    - `*`: 匹配前一个字符**零次或多次**。
>    - `+`: 匹配前一个字符**一次或多次**。
>    - `?`: 匹配前一个字符**零次或一次**。==
>    - `{n}`: 匹配前一个字符**恰好 n 次**。
>    - `{n,}`: 匹配前一个字符**至少 n 次**。
>    - `{n,m}`: 匹配前一个字符**至少 n 次，最多 m 次**。
>
> 6. **分组和捕获：**
>    - `()`: 用于创建分组。
>    - `(pattern)`: 匹配 pattern 并捕获匹配的文本。
>
> 7. **转义字符：**
>    - `\`: 用于**转义特殊字符，使其失去特殊意义**。
>
> 8. **选择符：**
>    - `|`: 表示逻辑或，**匹配两者之一**。
>      - 例如，`cat|dog` 匹配 "cat" 或 "dog"。
>
> 9. **边界匹配：**
>    - `\b`: **匹配单词边界。**
>    - `\B`: 匹配非单词边界。
>
> ---
>
> 在正则表达式中，`^` 用在字符集合中时表示**取反**
>
> 在表达式 `[^0-9]` 中：
>
> - `[]`: 表示一个字符集合。
> - `0-9`: 表示数字范围，即所有数字字符。
> - `^`: 放在字符集合的开始，表示取反，即匹配除了数字字符（0到9）以外的任何字符。
>
> 所以，`[^0-9]` 匹配的是任意一个不是数字的字符。这对于在正则表达式中排除某些字符很有用。其他例子包括：
>
> - `[^a-z]`: 匹配除了小写字母之外的任意字符。
> - `[^A-Z]`: 匹配除了大写字母之外的任意字符。
> - `[^a-zA-Z]`: 匹配除了字母之外的任意字符。
>
> 在字符集合内，**==`^` 只有在放在开头时才表示取反，如果 `^` 在字符集合的其他位置，它就只是普通字符==**。例如，`[a^b]` 匹配字符 'a'、'^' 或 'b' 中的任意一个。



## 快速上手

### 1. 验证邮箱地址

```javascript
let emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;

let email = "user@example.com";

if (emailRegex.test(email)) {
  console.log("Valid email address!");
} else {
  console.log("Invalid email address!");
}
```

这个例子中，`emailRegex` 是用于验证邮箱地址的正则表达式。它匹配常见的邮箱地址格式，包括用户名、@ 符号、域名等。`test` 方法用于检查邮箱地址是否符合正则表达式模式。

> `^                 // 开始匹配字符串的起始位置`
> `[a-zA-Z0-9._-]+   // 匹配至少一个字母、数字、点（.）、下划线（_）或短横线（-）`
> `@                 // 匹配邮箱地址中的@`
> `[a-zA-Z0-9.-]+    // 匹配至少一个字母、数字、点（.）或短横线（-）`
> `\.                // 匹配邮箱地址中的点（.），需要使用转义字符\ `
> `[a-zA-Z]{2,4}    // 匹配两到四个字母，通常表示顶级域名（如com、edu、org等）`
> `$                 // 匹配字符串的结束位置`

### 2. 验证密码强度

```javascript
let passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;

let password = "SecurePwd123";

if (passwordRegex.test(password)) {
  console.log("Strong password!");
} else {
  console.log("Weak password! Please include lowercase, uppercase, and digits.");
}
```

这个例子中，`passwordRegex` 用于验证密码强度。它要求密码至少包含一个小写字母、一个大写字母和一个数字，且长度至少为8位。

> `^                   // 开始匹配字符串的起始位置`
> `(?=.*[a-z])         // 至少包含一个小写字母`
> `(?=.*[A-Z])         // 至少包含一个大写字母`
> `(?=.*\d)            // 至少包含一个数字`
> `.{8,}               // 匹配至少包含8个字符`
> `$                   // 结束匹配字符串的位置`
>
> ---
>
> - `(?= ... )`: **正向预查**，表示**在匹配的位置之后必须满足某种条件**。
> - `.*`: 匹配任意字符（除了换行符）零次或多次。
> - `[a-z]`: 匹配一个小写字母。
>
> 将这三部分组合起来，`(?=.*[a-z])` 的意思是：
>
> 在当前位置之后，**字符串中必须存在至少一个小写字母**。

### 3. 提取文本中的日期

```javascript
let text = "Meeting scheduled on 2023-01-15";

let dateRegex = /\d{4}-\d{2}-\d{2}/;

let extractedDate = text.match(dateRegex);

console.log("Extracted date:", extractedDate[0]);
```

在这个例子中，`dateRegex` 用于匹配文本中的日期模式（YYYY-MM-DD）。`match` 方法用于提取匹配的部分，然后打印出提取到的日期。

这些简单的例子涵盖了正则表达式的基础用法，包括验证、搜索和提取。