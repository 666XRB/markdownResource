# 数据结构



![image-20231024194153074](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024194153074.png)

## 导言

### 关于数据组织

- 数据结构是一个**没有统一标准答案的概念**
- **数据结构和算法**是经常挨在一起的东西
- 数据结构的定义与**数据的规模和用途**有关

#### 放置图书问题

1. 乱放

   把人找s

2. 按照拼音字母顺序

   找用二分，但是插入也不方便

> - 空间分配和书籍分类的问题，如何合理分配书架和分类细度。
> - 分类分得太细会增加工作量，分得太粗会使书籍难以找到



==**解决问题的小绿跟数据的组织方式有关**==



 

### 关于空间使用

#### scanf_s的使用

```
int scanf_s(const char *format, ...);
```

> `format` 是一个字符串，指定了要读取的数据的格式。`...` 表示可变参数，用来接收读取的数据。
>
> ---
>
> `scanf_s` 函数的工作方式与 `scanf` 函数类似，但有一些差异和额外的安全性检查。主要的差异包括：
>
> 1. 在 `scanf_s` 中，**需要在格式字符串中指定每个输入项的最大字段宽度。这样可以防止缓冲区溢出。**
>
>    ```c++
>    int a=scanf_s("%d",&a,sizeof(a));
>    ```
>
> 2. ==`scanf_s` 函数返回成功读取的参数个数。==
>
> 3. ```c++
>    int a=scanf_s("%d",&a,sizeof(a));
>    返回的a是1
>    ```
>
> 4. ```c++
>    int n;
>    if(scanf_s("%d",&n,sizeof(n)!=1)
>    说明读取失败了
>    ```
>
>    



==迭代函数和非迭代函数是两种不同的函数类型，它们的主要区别在于**实现算法的方式**。==

#### 输出1-n的数

##### Func1

```c++
void P(int n)
{
    for (int i = 1; i <= n; i++)
    {
        printf("%d ", i);
    }
}

```

100,1000000都是可以拿下的

> `void P(int n)` 是一个迭代函数，使用 for 循环来实现。它从 1 开始遍历到 n，依次打印每个数字。这种实现方式简单直观，易于理解和实现。
>
> 它的时间复杂度为 O(n)，空间复杂度为 O(1)，因为只需要一个循环变量 i 来存储当前数字。

##### Func2

```c++
void newP(int n)
{
    if (n)
    {
        newP(n - 1);
        printf("%d ", n);
    }
}
```

100，1000，太大了就爆炸啦.

![image-20231024204253034](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231024204253034.png)

> `void newP(int n)` 是一个非迭代函数**使用递归来实现**。它先递归调用 `newP(n - 1)`，然后再打印当前数字 n。
>
> 这种实现方式通过将问题分解成更小的子问题来解决，直到达到基本情况（n = 0）为止。
>
> 这种递归实现方式更加灵活，可以处理更复杂的问题。
>
> 但是在大规模的递归调用中可能会导致**栈溢出的问题**。它的时间复杂度也为 O(n)，空间复杂度为 O(n)，因为在递归调用过程中需要保存每次函数调用的栈帧。

### 关于算法效率

计算多项式:

![image-20231025193043077](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025193043077.png) 

> ```c++
> #include <stdio.h>
> #include <math.h>
> #define maxk 1e7
> #include <time.h>
> double func(int n, double a[], double x)
> {
>     double sum = a[0];
>     for (int i = 1; i <=n; i++)
>     {
>         sum += (a[i] * pow(x, i));
>     }
>     return sum;
> }
> double func2(int n, double a[], double x)
> {
>     double sum = a[n];
>     for (int i = n; i > 0; i--)
>     {
>         sum = a[i - 1] + x * sum;
>     }
>     return sum;
> }
> int main()
> {
>     const int max = 10;
> 
>     clock_t start, end;
>     double array[max];
>     for (int i = 0; i < max;i++)
>     {
>         array[i] = (double)i;
>     }
>     start = clock();
>     for (int i = 0; i < maxk; i++)
>     {
> 
>         func(max-1, array, 1);
>     }
>     end = clock();
>     printf("%6.2e",((double)(end-start))/CLK_TCK/maxk);
> 
> 
> 
>     return 0;
> }
> ```
>
> 

==平均时长==

#### func

```c++
double func(int n, double a[], double x)
{
    double sum = a[0];
    for (int i = 1; i <= n; i++)
    {
        sum += (a[i] * pow(x, i));
    }
    return sum;
}
```

 ![image-20231025200646002](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025200646002.png)

func2

```c++
double func2(int n, double a[], double x)
{
    double sum = a[n];
    for (int i = n; i > 0; i--)
    {
        sum = a[i - 1] + x * sum;
    }
    return sum;
}
```

![image-20231025200626951](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025200626951.png)

第一个慢

==解决问题方法的效率，跟算法的巧妙程度有关。==

### 抽象数据类型

什么是数据结构？

数据对象在计算机中的组织方式

数据对象必定与一系列 的操作相结合

---

图书放一排，除了头和尾的书，都有前面的书和后面的书，如果给每个书都编一个号。

那么这就是线性结构

如果给这些书分成好多类，而且每个类下面又有好多书，这就是一对多，就是树

![image-20231025203920701](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025203920701.png) 

### 什么是算法？

> 有限指令集
>
> 产生输出
>
> 一定在有限步骤之后终止

![image-20231025204521496](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025204521496.png) 

==不依赖于任何一种计算机语言以及具体的实现手段==

![image-20231025205023720](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025205023720.png)

### 什么是好的算法？



#### 空间复杂度

S(n)

Space

算法写成的程序在执行，占用存储单元的长度。

空间太复杂，导致内存超限

函数，在执行下一次之前，需要保存上一次的程序，当前状态

再执行PRint（n-1）



![image-20231025205649858](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025205649858.png)

#### 时间复杂度

空间占用是固定的，因为没有调用别的程序。

T(n)

Time	

算法写成的程序在执行，耗费时间的长度。

时间太长，等不到。







![image-20231025210032049](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025210032049.png) 

> 因为计算机的+-的速度很快，一般看*/对速度造成的影响
>
> 看做了多少次乘法除法

上：每一次循环做了i次，总：1+2+3+...n=(n<sup>2</sup>+n)/2

**T(n)=C1n<sup>2</sup>+C2n**

下: 每一次循环做了一次乘法，总:n次乘法

**T(n)=Cn**

---



如何判断好算法   T<sub>worst</sub>

最坏情况复杂度  T<sub>avg</sub>

 ==T<sub>avg</sub>   <=   T<sub>worst</sub>==

先分析最坏情况的复杂度Worst



### 复杂度的渐进表示法

![image-20231025212121261](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025212121261.png) 

==S(n)同理==

> 复杂度的渐进表示法
>
> 用来描述算法**时间复杂度**或**空间复杂度**的方法。
>
> ==表示算法的运行时间或空间需求与输入规模的增长关系。==
>
> 渐进表示法通常使用大O符号来表示。
>
> 大O表示法描述了算法的最坏情况下的运行时间或空间需求。它表示了算法的上界，即算法在最坏情况下的运行时间或空间需求不会超过O(f(n))，其中f(n)是输入规模n的某个函数。
>
> ---
>
> 上界（Upper Bound）是指==**算法在最坏情况下的运行时间或空间需求的一个上限**==。如果一个算法的运行时间或空间需求是O(f(n))，那么f(n)就是该算法的一个上界。
>
> 下界（Lower Bound）是指==**算法在最好情况下的运行时间或空间需求的一个下限**==。下界表示了算法的最佳情况下的运行时间或空间需求不会低于某个值。
>
> ---
>
> 渐进表示法==**描述算法的运行时间或空间需求与输入规模的增长关系**==，**而不是精确地描述算法的具体运行时间或空间需求**。渐进表示法可以帮助我们比较不同算法的效率，并选择最优的算法来解决问题。



上界和下届有无限多个，但是要最可能的贴近真实情况，==最小的上界，最大的下届..==

![image-20231025211512754](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025211512754.png) 

==**n<sup>2</sup>转化位logn将会有很大的提升**==

![image-20231025211827544](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025211827544.png)

### 复杂度分析的小窍门

![image-20231025212154930](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025212154930.png)

**有两段算法，简单的加起来，那么时间复杂度就是二者之和，上界就是二者最大的那个**

**如果他们嵌套起来，那么复杂度就是二者的乘积，那么上界就是二者上界的乘积**



![image-20231025212456870](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231025212456870.png)

### 案例

#### 实际案例-找子数组

三层嵌套循环来考虑**所有可能的子数组**，并在这些子数组中找到具有最大和的那一个。它的时间复杂度为 O(n^3)，因为它需要考虑所有可能的子数组，因此不是一个高效的算法，

```c++
int func(int a[], int n)
{
    int sum,max=0;
    for (int i = 0; i < n; i++)
    {
        for (int j = i; j < n; j++)
        {
            sum = 0;
            for (int l = i; l <=j; l++)
            {
                sum += a[l];
            }
            if (sum > max)
                max = sum;
        }
    }
    return max;
}
```

T(n)=O(n<sup>3</sup>)

```c++
int func(int a[], int n)
{
    int sum,max=0;
    for (int i = 0; i < n; i++)
    {
        sum = 0;
        for (int j = i; j < n; j++)
        {
            sum += a[j];
            if (sum > max)
                max = sum;
        }
    }
   
```

T(n)=O(n<sup>2</sup>)

#### 分而治之算法

![image-20231026161657856](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231026161657856.png)

```c++
#include <stdio.h>
#include <limits.h>

// 辅助函数，计算跨越中点的最大子列和
int findMaxCrossingSubarray(int arr[], int low, int mid, int high) {
    int leftSum = INT_MIN;
    int sum = 0;

    for (int i = mid; i >= low; i--) {
        sum += arr[i];
        if (sum > leftSum) {
            leftSum = sum;
        }
    }

    int rightSum = INT_MIN;
    sum = 0;

    for (int i = mid + 1; i <= high; i++) {
        sum += arr[i];
        if (sum > rightSum) {
            rightSum = sum;
        }
    }

    return leftSum + rightSum;
}

// 主函数，使用分而治之算法找到最大子列和
int findMaxSubarray(int arr[], int low, int high) {
    if (low == high) {
        return arr[low];
    }

    int mid = (low + high) / 2;
   // 1 2 3 4   =1
// 1 2 3 4 5   =2
    // 递归地求解左半部分、右半部分和跨越中点的最大子列和
    int leftMax = findMaxSubarray(arr, low, mid);
    int rightMax = findMaxSubarray(arr, mid + 1, high);
    int crossMax = findMaxCrossingSubarray(arr, low, mid, high);

    // 返回三者中的最大值
    if (leftMax >= rightMax && leftMax >= crossMax) {
        return leftMax;
    }
    else if (rightMax >= leftMax && rightMax >= crossMax) {
        return rightMax;
    }
    else {
        return crossMax;
    }
}

int main() {
    int arr[] = { 4, -3, 5, -2, -1, 2, 6, -2 };

    int n = sizeof(arr) / sizeof(arr[0]);

    int maxSubarraySum = findMaxSubarray(arr, 0, n - 1);

    printf("最大连续子列和为: %d\n", maxSubarraySum);

    return 0;
}

```

算法复杂度:

> ![image-20231026161638165](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231026161638165.png)

![image-20231026154728233](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20231026154728233.png)

`{ 9, -3, -4, 3, -1, 2, -1, -2 }`，我们可以使用分而治之算法来找到最大连续子列和。让我们通过步骤来计算它：

1. **分解（Divide）**：我们将数组划分为两半，即左半部分和右半部分。

   左半部分： `{ 9, -3, -4, 3 }`

   右半部分： `{ -1, 2, -1, -2 }`

2. **征服（Conquer）**：现在，我们递归地处理左半部分和右半部分。

   对于左半部分，最大连续子列和是 `9`。

   对于右半部分，最大连续子列和是 `2`。

3. **合并（Combine）**：接下来，我们考虑包含中间元素的子列和。在这种情况下，我们需要考虑跨越中点的子列和。

   跨越中点的子列是 `{ 3, -1, 2 }`，它的和是 `4`。

4. **返回最大子列和**：最后，我们比较左半部分的最大子列和、右半部分的最大子列和和跨越中点的最大子列和。

   - 左半部分的最大子列和：`9`
   - 右半部分的最大子列和：`2`
   - 跨越中点的最大子列和：`4`

最大连续子列和是这三个值中的最大值，即 `9`。