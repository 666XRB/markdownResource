# Python程序设计

### 2.1语法特点

###### python没有花括号，需要严格的缩进格式。就是空格数是相同的

###### 单行注释#

```python
a=0
b=0
c="你好"
# 允许同时为多个变量赋值
p=l=k=5
# 可以变量之间相互赋值
# 同一个变量可以反复赋值
d="12.3"
# 弱语言类型，根据赋予的值来决定具体的数据类型
a=input("请输入a")
b=input("请输入b")
if a>b:
    print("你好啊")
else:
    print("你好吗")
```



###### 多行注释用"""或'''抱起来

###### 字面量

> 在代码中固定不变的值

###### 语句换行 书写换行，实际一行

***反斜杠后面没有跟任何字符，因此它被视为一个续行符***

```python
x=" 窗前明月光\
  dsadasdas\
 dsadasdas"
print(x)
#结果是
#  窗前明月光  dsadasdas dsadasdas
```

###### 同一行写多个语句用分号隔开

```python
m=10;n=11
# 但可读性大大降低
```

###### 导入模块 

###### import 模块名

```python
import math
print(math.PI)
```

### **2.2标准输入/输出**

###### 标准输入函数

返回的是字符出类型

注意类型转换

```python
input([prompt])
#prompt可选参数
#返回一个字符串对象
name=input("请输入你的大名")
#如果需要其他类型的数据就需要强制转换
```

###### 标准输出函数

==默认自动换行==

==print("%dx%d=%d"%(i,j,sum),end='\t')==

```python
# print(value,……,sep=;'',end='')
# value代表输出对象，可以有多个，用逗号隔开
# sep用于设置输出信息的分隔符 默认为一个空格
# end表示print语句的结束负号，默认为换行符
print("你","好","啊",sep="-",end="a")
# 你-好-啊a
```

##### ***如何格式化表达式?***

***●f"{表达式}"***
***●"%s\%d\%f" % (表达式、表达式、表达式)***

### **2.3变量和常量**

###### 在python中可以直接声明变量，不必声明变量的类型，也就是弱语言类型.

###### 虽然不需要声明但是在使用前一定要赋值

```python
b=0
c="你好"
# 允许同时为多个变量赋值
p=l=k=5
# 可以变量之间相互赋值
# 同一个变量可以反复赋值
d="12.3"
# 弱语言类型，根据赋予的值来决定具体的数据类型
```

###### 常量就是值不改变的，通常用全部大写的变量名表示常量

python*没有机制保护产量不会被改变*

### **2.4标识符和关键字**

1. 可以有==大小写字母，数字，下划线==
2. 要求第一个字符不能是数字
3. 区分大小写就是joke和JOKE不一样
4. 在python3中汉字也可以出现在标识符里



### **2.5简单数据类型**

#### ==type()查数据类型==

```python
a=[1,4,9,3,6,7,2]
b="你好"
print(type(a))
print(type(b))
# <class 'list'>
# <class 'str'>
```



#### 数字类型

整形int特点

1. 不带小数点，分正负

2. 在python中没有大小限制，只要内存许可就可以无限大

3. 二进制0B开头，八进制0O开头，十六进制0X开头

   ```python
   print(0b1010)
   print(0x81)
   # 结果是10
   # 结果是129
   ```

4. 进制之间的转十进制转为二进制bin(十进制数)

5. 十进制转为八进制oct(十进制数)

6. 十进制转为十六进制hex(十进制数)

   ```python
   print(bin(21))
   print(oct(21))
   print(hex(21))
   # 0b10101
   # 0o25
   # 0x15
   ```

#### 浮点类型特点

1. 整形转为float用float（整数150）=>150.0
2. 1.2e2=>1.2*10^2^

#### 布尔类型特点

1. True和False
2. 为0的数字0 0.0
3. 空字符串'' ""
4. 空集合(){}[]
5. false
5. None
6. 以上全为false

#### 复数类型特点

1. 数学上是a+bi
2. 这里是real+imag
3. 对应a=1.5+2j/J
4. 获取实部和虚部，a.real，a.imag
5. 把两个数转换为一个复数complex(a,b)=>a+bj

#### 字符串类型特点

###### 标识字符串

1. 标识字符串用 单引号'' 双引号"" 三单引号''' '''三双""" """
2. ‘你好啊’ , ”你好啊“,     """你好啊""" ,   '''你好啊'''
3. ==特殊的三引号抱起来，能原封不动的表示字符串，保留换行和缩进。。==

#### encode

`encode()` 是字符串对象的一个方法，用于将字符串转换为指定的字节序列（即编码）。该方法接受一个参数，即表示所需编码的字符集（如 UTF-8、ASCII 等）。

```python
string.encode(encoding)
```

`string` 为要进行编码的字符串，`encoding` 为指定的字符集名称。

在编码过程中，可能会发生字符无法映射到指定编码的情况，可以通过指定 `errors` 参数来处理这种情况。常见的错误处理方式有 `'strict'`、`'ignore'` 和 `'replace'` 等。

```python
text = "你好😊"

# 将字符串以 UTF-8 编码转换为字节序列，并忽略无法编码的字符
encoded_text = text.encode('utf-8', errors='ignore')
print(encoded_text)  # 输出：b'\xe4\xbd\xa0\xe5\xa5\xbd'
```



#### 转义字符

1. 用\开头

2. ‘let's go'=>'let\\'s go'

3. \n换行

4. \t横向制表符

5. \r是回车符，==它的作用是将光标移到当前行的开头==，覆盖之前的内容。

6. \b是退格符，==它的作用是将光标向左移动一格==，可以用来删除之前输入的字符。

   ```python
   print("dsadasdadsadasd\r我在这")
   print("dasdasdsav\b我")
   # 我在这
   # dasdasdsa我
   ```

#### ==字符串基本操作==

1. ##### 正索引/负索引(但不可修改)

   ```python
   a="python"
   # a[1]=9???不可以
   for i in a:
       print(i)!
   # p 0 -6
   # y 1 -5
   # t 2 -4
   # h 3 -3
   # o 4 -2
   # n 5 -1
   ```

3. **==python不允许以任何方式改变字符串对象的值，否则会出错==**

4. ==可以用+号连接两个字符串，可以用*生成重复的字符串==

   ```python
   a="比你好"
   b="比是的"
   print(a*6)
   print(a+b)
   # 比你好比你好比你好比你好比你好比你好
   # 比你好比是的
   ```

5. ##### 字符串切片操作

   ```python
   a="python"
   # [b,c]
   # b代表起点，c代表下标加1，左闭右开 [start，end)
   print(a[0:2])
   # py
   # 左边不写的话默认为0
   # 右边不写的话默认为字符串长度
   ```
   
5. 字符串逆转

   ```python
   a="你好啊"
   a=a[::-1]
   ```

   

##### 字符串的常用方法：

==这些操作都没有真正改变原来的字符串，而是返回了一个新的字符串。原来的字符串仍然保持不变。如果要改变原来的字符串，可以将新的字符串赋值给原来的变量。例如：==

> 1. str.capitalize()  把字符串的首字母变成大写
>
> 2. str.find(x)   找到字符串中x的下标
>
> 3. str.index(x)   找到字符串中x的下标
>
> 4. str.lower()   把字符串中的大写变成小写
>
> 5. str.upper()  把字符串中的小写变成大写
>
> 6. str.split(x),用x把字符串给分割开，==得到一个list 列表==，**默认是以空格分开。**
>
> 7. ##### 在Python中，字符串对象有一个 `strip()` 方法，用于去除字符串两端的空白字符（包括空格、制表符和换行符）。
>
>    ##### `strip()` 方法不会修改原始字符串，而是返回一个新的字符串。如果指定参数,就清除字符串两端的指定字符

a = a.replace("python","蟒蛇")==

1. ```python
   a="python"
   # capitalize(a)
   print(a.capitalize())
   print(a.find('o'))
   print(a.lower())
   print(a.upper())
   print(a.count('p'))
   print(a.split('p'))
   #得到一个列表对象
   # 默认是['python']
   # ['', 'ython']
   print(a)
   print(a.replace("python","蟒蛇"))
   print(a)
   # Python
   # 4
   # python
   # PYTHON
   # 1
   # ['', 'ython']
   # python
   # 蟒蛇
   # python
   ```

##### 字符串拼接

> 1==printf("%d+%d=%d"%(a,b,c))==
>
> ----------------------------------------------------------------
>
> 2 ***==f"内容{变量}"==***
>
> 注意里面只能是变量，表达式不可以sum-=1000
>
> ---
>
> Traceback (most recent call last):
>   File "e:\Bluecode\python\learn\learn\review.py", line 7, in <module>
>     print(f"{aa1}+{bb1+1}={aa1+bb1}")
>                    ~~~^~
> TypeError: can only concatenate str (not "int") to str
>                    ~~~
>
> ```python
> aa=int(input("请输入aa"))
> bb=int(input("请输入bb"))
> print(f"{aa}+{bb}={aa+bb}")
> aa1=(input("请输入aa1"))
> bb1=(input("请输入bb1"))
> print(f"{aa1}+{bb1}={aa1+bb1}")
> # 请输入aa7
> # 请输入bb8
> # 7+8=15
> # 请输入aa17
> # 请输入bb18
> # 7+8=78
> ```
>
> `input默认得到的是字符串对象`



##### **格式化的精度控制**

特殊在设置宽度后==，是补空格==，==而且还是四舍五入==

```python
c=11.39
print("%d"%c)
print("%.2f"%c)
print("%5.1f"%c)
# 11
# 11.39
#  11.4
```



###### 综合案例

```python
a="it it dsasdasd it"
print(a.count('it'))
a=a.replace(' ','|')
print(a)
a=a.split('|')
print(a)
# 3
# it|it|dsasdasd|it
# ['it', 'it', 'dsasdasd', 'it']
```




### 2.6==类型转换==

##### 类型转换函数

1. ##### int(x) 得到整肃

2. ##### float(x) 得到浮点数

3. ##### complex(a,b) 得到对应的复数

4. ##### ==str(x) 将对象转化为人容读取的字符串==

5. ##### repr(x) 将对象转化为编辑器容读取的字符串

6. ##### eval(str) 

7. ##### chr(x) 得到ancil对应的字符

8. ##### ord(x) 得到l对应的ancil马

9. ##### bin(),oct(),hex()

   ```python
   print(int(1.2))
   print(float(1))
   print(complex(1,2))
   # str,repr
   # print(eval("sdasd"+"xrb"))
   print(chr(77))
   print(bin(18))
   print(oct(18))
   print(hex(18))
   # 1
   # 1.0
   # (1+2j)
   # M
   # 0b10010
   # 0o22
   # 0x12
   ```

10. 各种进制转换为10进制

   使用int的强制转换的第二个参数

   ```python
   num_two=int(bin(16),2)
   num_eight=int(oct(16),8)
   num_16=int("aB234",16);
   #int 的第二个参数代表前面字符串的进制数
   print(f"{num_two}+++++++{num_eight}++++{num_16}")
   #16+++++++16++++700980
   ```

   

##### ==运算符和表达式==

对数据进行加工处理的过程叫运算

表示运算的符号成为运算符

参加运算的数据叫做操作数

###### 2.71算数运算符

1. +  
2. -
3. *
4. /
5. %
6. **
7. //

```python
a=5;b=2;c=3
print(a+b)
print(a**b)
#a的b次方
print(c//b)
#c整除b，商的整数部分
```

###### 2.72比较运算符

1. ==
2. !=
3. <>类似!= ==在Python中，`<>` 运算符已经被弃用，因此不再被支持。==
4. \>
5. \<
6. \>=
7. \<=

```python
a=2;b=2;c=3
print(a>b)
print(a==b)
# False
# True
```

###### 2.73逻辑运算符-与或非-

==默认从左到右==

1. 与and   **==第一个为0就返回0，第一个为1就返回第二个操作数==**

2. ###### 或or   ==第一个为1就返回1，第一个为0就返回第二个操作数==

3. 根据第一个操作数的真假来确定是否返回第二个操作数

4. 非not

5. ==注意逻辑运算符左右不能直接与操作数直接接触==

```python
a=1
b=1
c=1
if a==b and b==c:
    print("asddassd")

```

###### 2.74赋值运算符

=

x=x+1

>1. +=
>2. -=
>3. /=
>4. *=
>5. %=
>6. **=
>7. //=



==计算后并且赋值==

###### 2.75位运算符（5）

Python里面没有&&//||

对八位二进制数进行运算，&有假就0，|有真就1,异或==同1异0==

~1变-，0变1

左移整体左移，超出去的保留符号（1代表负，0代表正）右边补0

​	

>1. 按位与&
>2. 按位或|
>3. 按位异位~
>4. 左移<<
>5. 右移>>

```python
# a=3
# 0 0 0 0 0 0 1 1
# a<<2
# 0 0 0 0 1 1 0 0
# 12=3*2的2次方
```

###### 2.76成员运算符

==用来判断序列中是否存在某个成员==

>1. in
>2. not in

```python
arry=["电视","冰箱","电脑","女盆友"]
print("电视"in arry)
print('电视'in arry)
print('男朋友' not in arry)
True
True
True
```

###### 2.77标识运算符

==判断两个变量是否引用同一个对象==

>1. is
>2. is not

```python
a="电视"
b="冰箱"
if a is b:
    print("a和b引用同一个对象")
else:
    print("a和b引用不同的对象")
    a=b
    if a is b:
        print("a和b引用同一个对象")
# a和b引用不同的对象
# a和b引用同一个对象
```

##### 2.8运算符优先级

> 1. 括号：()
> 2. 幂运算：**
> 3. 正负号：+x, -x
> 4. 乘除取模运算：*, /, %
> 5. 加减运算：+, -
> 6. 比较运算：<, >, <=, >=, ==, !=
> 7. 逻辑运算：not, and, or
> 8. 赋值运算：=, +=, -=, *=, /=, %=, **=, //=

==使用括号：如果有任何疑问，可以使用括号明确指定运算的顺序。==

```python
a=3
b=0
d=a and b
e=a or b

print(a and b)
print(a or b)
print(d)
print(e)
#0
#3
#0
#3
```

### 3.1python控制语句

==不成文结论 ：相当于()==

##### 3.123选择语句

1. 简单if语句
2. if-else语句
3. if-elif-else语句

```python
aa=10;bb=7
if aa<bb:
    print("你好啊")
else:
    print("我好啊")

if 1<=aa<=4:
    print("hello")
elif 5<=aa<=7:
    print("hello1")
else:
    print("hello3")
```

**注意形式**

python中是这样写的不同于C/C++

==5<=aa<=7:==

##### 3.14if嵌套语句

```python
if aa>bb:
    print("helo")
    if aa>2:
        print("heloowos")
    else:
        print("阿三大苏打")
else:
    print("十大大苏打实打实")
```

### 3.2循环语句

##### For循环语句

>for 循环变量 in 循环对象（可迭代对象）
>
>循环体

```python
a="abc"
for k in a:
    print(k)
# a
# b
# c
```

###### ==整数序列range==

range（start，end）

[start,end-1]

###### for循环嵌套

```python
sum=0
a1=range(1,10)
b1=range(1,10)
for i in a1:
    for j in b1:
        if i>=j:
            sum=i*j
            print("%dx%d=%d"%(i,j,sum),end='\t')
    print("\n")
```

>1x1=1	
>
>2x1=2	2x2=4	
>
>3x1=3	3x2=6	3x3=9	
>
>4x1=4	4x2=8	4x3=12	4x4=16	
>
>5x1=5	5x2=10	5x3=15	5x4=20	5x5=25	
>
>6x1=6	6x2=12	6x3=18	6x4=24	6x5=30	6x6=36	
>
>7x1=7	7x2=14	7x3=21	7x4=28	7x5=35	7x6=42	7x7=49	
>
>8x1=8	8x2=16	8x3=24	8x4=32	8x5=40	8x6=48	8x7=56	8x8=64	
>
>9x1=9	9x2=18	9x3=27	9x4=36	9x5=45	9x6=54	9x7=63	9x8=72	9x9=81	

==print("%dx%d=%d"%(i,j,sum),end='\t')==

##### while循环语句

>###### while 条件表达式：
>
>循环体

```python
while k<=10:
    sum1+=k
    k+=1
    print(sum1)
# 0
# 1
# 3
# 6
# 10
# 15
# 21
# 28
# 36
# 45
# 55
```

###### while for混合嵌套 while while 互相嵌套

```python
pp=0
sum2=0
while pp<=10:
    pp+=1
    print(pp)
    for o in range(1,11):
        sum2=pp+o
        # print(o)
        if pp>=o:
            print("%d+%d=%d"%(pp,o,sum2),end='\\')

```

>运行结果:
>
>1
>1+1=2\2
>2+1=3\2+2=4\3
>3+1=4\3+2=5\3+3=6\4
>4+1=5\4+2=6\4+3=7\4+4=8\5
>5+1=6\5+2=7\5+3=8\5+4=9\5+5=10\6
>6+1=7\6+2=8\6+3=9\6+4=10\6+5=11\6+6=12\7
>7+1=8\7+2=9\7+3=10\7+4=11\7+5=12\7+6=13\7+7=14\8
>8+1=9\8+2=10\8+3=11\8+4=12\8+5=13\8+6=14\8+7=15\8+8=16\9
>9+1=10\9+2=11\9+3=12\9+4=13\9+5=14\9+6=15\9+7=16\9+8=17\9+9=18\10
>10+1=11\10+2=12\10+3=13\10+4=14\10+5=15\10+6=16\10+7=17\10+8=18\10+9=19\10+10=20\11
>11+1=12\11+2=13\11+3=14\11+4=15\11+5=16\11+6=17\11+7=18\11+8=19\11+9=20\11+10=21\



##### while循环和for循环的对比

while循环和for循环，都是循环语句，但细节不同:
在循环控制上:
while循环可以**自定循环条件，并自行控制**
for循环不可以自定循环条件,只可以一个个从容器内取出数据
●
在无限循环上:
while循环可以通过条件控制做到无限循环
●
for循环理论上不可以,因为被遍历的容器容量不是无限的
在使用场景上:
while循环适用于任何想要循环的场景
for循环适用于，遍历数据容器的场景或简单的固定次数循环场景

### 3.3跳转语句

##### break语句

> 跳出当前层的循环。****

##### continue语句

> 这次循环到这里结束下面的不要执行了，然后进入下一次循环

##### ==pass语句==

> 空代码块，占位符作用。

##### ==else但配合循环使用==

> ==循环正常结束或者while条件判断为False执行else后面的语句==
>
> 如果循环break提前结束了，那么不执行else后面的语句

```python
for l in range(1,11):
    print(l)
else:
    print("循环正常结束捏")
# 1
# 2
# 3
# 4
# 5
# 6
# 7
# 8
# 9
# 10
# 循环正常结束捏
```

#### 循环综合案例

```python
sum=10000
for i in range(1,21):
    if sum!=0:
        num = random.randint(1, 10)
        if num < 5:
            print(f"员工{i},绩效分{num},不发工资，下一位")
        else:
            sum=sum-1000
            print(f"向员工{i}发放工资1000元，账户余额还剩{sum}元")
    else:
        print("工资发完了醉了")
        break
# 向员工1发放工资1000元，账户余额还剩9000元
# 向员工2发放工资1000元，账户余额还剩8000元
# 员工3,绩效分4,不发工资，下一位
# 向员工4发放工资1000元，账户余额还剩7000元
# 向员工5发放工资1000元，账户余额还剩6000元
# 员工6,绩效分2,不发工资，下一位
# 员工7,绩效分4,不发工资，下一位
# 员工8,绩效分1,不发工资，下一位
# 向员工9发放工资1000元，账户余额还剩5000元
# 向员工10发放工资1000元，账户余额还剩4000元
# 向员工11发放工资1000元，账户余额还剩3000元
# 向员工12发放工资1000元，账户余额还剩2000元
# 向员工13发放工资1000元，账户余额还剩1000元
# 员工14,绩效分3,不发工资，下一位
# 员工15,绩效分4,不发工资，下一位
# 向员工16发放工资1000元，账户余额还剩0元
# 工资发完了醉了

```



****

### 4.0数据结构

#### 大纲

|       类型       | 描述                                                         | 说明                                             |
| :--------------: | ------------------------------------------------------------ | ------------------------------------------------ |
|       整数       | 整数(int)，如: 10、-10                                       | 整数(int)，如: 10、-10                           |
|  浮点数(float)   | 浮点数(float)                                                | ,如: 13.14、 -13.14                              |
|  复数(complex)   | 复数(complex)，                                              | 如: 4+3j,以j结尾表示复数                         |
|    布尔(bool)    | 布尔(bool) 表达现实生活中的逻辑，即真和假，True表示真,False表示假 | True本质上是一个数字记作1,  False记作0           |
|  字符串(String)  | 描述文本的一种数据类型                                       | 字符串(string) 由任意数量的字符组成              |
|    列表(List)    | **有序的可变序列**                                           | Python中使用最频繁的数据类型，可有序记录一堆数据 |
|   元组(Tuple)    | **有序的不可变序列.**                                        | 可有序记录一堆不可变的Python数据集合             |
|    集合(Set)     | **无序不重复集合**                                           | 可无序记录一堆不重复的Python数据集合             |
| 字典(Dictionary) | 无序Key-Value集合                                            | 可无序记录-堆Key-Value型的Python数据集合         |

#### 4.1列表(有序可变序列)

##### 创建列表

> 列表用来存储任意大小的数据集合，可以有任意个数据，可以是不同的数据类型，也可以是列表（嵌套）

1. 使用方括号创建列表

2. 使用构造函数创建列表

3. 使用列表推导式创建

   ```python
   list=list("我喜欢你")
   list1=[1,23,4,"我","喜欢",True]
   list2=[x for x in range(1,11) if x>2]
   print(list)
   print(list1)
   print(list2)
   # <class 'list'>
   ```

>在Python中，可以使用构造函数来创建列表。构造函数是一种特殊的方法，用于在创建对象时进行初始化操作。
>
>使用构造函数创建列表的方式是通过调用list()函数，并将一个可迭代对象作为参数传递给它。可迭代对象可以是一个字符串、元组、集合、字典等。
>
>下面是一些使用构造函数创建列表的示例：
>
>1. 使用字符串创建列表：
>```python
>my_list = list("abc") 
># ['a', 'b', 'c']
>```
>
>2. 使用元组创建列表：
>```python
>my_list = list((1, 2, 3)) 
># [1, 2, 3]
>```
>
>3. 使用集合创建列表：
>```python
>my_list = list({1, 2, 3}) 
># [1, 2, 3]
>```
>
>4. 使用字典创建列表（只包含键）：
>```python
>my_list = list({"a": 1, "b": 2, "c": 3})  
># ['a', 'b', 'c']
>```
>
>需要注意的是，==构造函数创建的列表是一个新的对象，与原始的可迭代对象是独立的。修改原始的可迭代对象不会影响到使用构造函数创建的列表。==
>
>此外，还可以使用列表推导式来创建列表，它提供了一种更简洁的语法。例如：
>```python
>my_list = [x for x in range(5)]  
># [0, 1, 2, 3, 4]
>```

***还可以加一些判断条件***

> ```python
> ddd=list(x for x in range(1,11) if(x>5))
> # [6, 7, 8, 9, 10]
> ```

##### **列表的访问**

**下标[0，len-1]**

##### 列表的遍历

```python
a=[1,2,4]
print(a)
for i in a:
    print(i)
# [1, 2, 4]
# 1
# 2
# 4
```

##### 列表的操作和常见的方法

| 编号  | 使用方式                |                             作用                             |
| :---: | :---------------------- | :----------------------------------------------------------: |
|   1   | 列表.append(元素)       |                     向列表中追加一个元素                     |
|   2   | 列表.extend(容器)       |           将数据容器的内容依次取出，追加到列表尾部           |
|   3   | 列表.insert(下标，元素) |                 在指定下标处，插入指定的元素                 |
| **4** | **del列表[下标]**       |                   **删除列表指定下标元素**                   |
|   5   | 列表.pop(下标)          | 删除列表指定下标元素并且返回,如果指定了index就把他给删除了默认是-1下标 |
|   6   | 列表.remove(元素)       |               从前向后，删除此元素第一个匹配项               |
| **7** | **列表.clear()**        |                         **清空列表**                         |
|   8   | 列表.count(元素)        |                 统计此元素在列表中出现的次数                 |
|   9   | 列表.index(元素)        |        查找指定元素在列表的下标  找不到报错ValueError        |
|  10   | len(列表)               |                     统计容器内有多少元素                     |

```python
ddd=list(x for x in range(1,11) if(x>5))
# [6, 7, 8, 9, 10]
print(ddd)
for ppp in ddd:
    print(ppp)
    # 6
    # 7
    # 8
    # 9
    # 10
```

1. **列表名.append在列表的==屁股==加新成员**

   ```python
   a=list(x for x in range(1,11))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a.append(11)
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
   ```

2. 列表名.**inset(i,x)在下标为i的地方加入一个新的x,也就是说新来的在a[i]，其他的往后去**

   ```python
   a=list(x for x in range(1,11))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a.insert(1,'x')
   print(a)
   # [1, 'x', 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
   ```

3. 列表名.**extend（新的 列表）把新的列表==续==在操作对象的后面**

   ```python
   a=list(x for x in range(1,11))
   b=list(t for t in range(11,15))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a.extend(b)
   print(a)
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
   ```

4. **列表名.remove(x)移除列表里的x**

   ```python
   a=list(x for x in range(1,11))
   b=list(t for t in range(11,15))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a.remove(1)
   print(a)
   # [2, 3, 4, 5, 6, 7, 8, 9, 10]
   ```

5. **列表名.pop（obj）==删除obj指定的下标==*****==并返回删除的对象==**

   ```python
   a=list(x for x in range(1,11))
   b=list(t for t in range(11,15))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   
   c=a.pop(8)
   print(c)
   print(a)
   # 9
   # [1, 2, 3, 4, 5, 6, 7, 8, 10]
   ```

5. del 列表名[下标]

   ```00python
   del a[2]
   print(a)
   # [1, 2, 3, 4]
   # [1, 2, 4]
   ```
   
5. 列表名.clear() 清空列表

   ```python
   a.clear()
   print(a)
   # [1, 2, 4]
   # []
   ```
   
6. 列表名.index(x)方法，查x在列表中的下标

   ```python
   a=list(x for x in range(1,11))
   b=list(t for t in range(11,15))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   
   print(a.index(8))
   #7
   ```

7. 列表名.count(x)，查x在列表中出现的次数

   ```python
   a=list(x for x in range(1,11))
   b=list(t for t in range(11,15))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a.append(6)
   print(a)
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 6]
   print(a.count(6))
   #2
   ```

10. 列表名.reverse()将列表顺序反转---------------------==不需要传入任何参数==而且也没有返回值相当于返回none

   ```python
   a=list(x for x in range(1,11))
   b=list(t for t in range(11,15))
   # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   a.reverse()
   print(a)
   # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
   ```

11. len(列表名)得到列表的元素个数

    ```python
    a=[1,2,4]
    print(len(a))
    # [1, 2, 4]
    # 3
    ```

    

9. **列表名.sort（key,reverse）三个参数，key比较时的关键字，reverse比较完是否逆序** 

   > 1. ###### 在Python 3中，cmp参数已被移除，所以无法直接使用cmp函数进行排序。==取而代之的是使用key参数来指定一个函数==
   >
   > 3. ###### ==默认是排序后不进行逆序的，默认升序》==
   >
   > 3. ###### 可以单独使用并排序真身，返回值是个none，可以自定义key，默认升序》
   >
   >    k.sort(*key***=lambda** *a*:a[1])有三个参数，不能默认指定，要指定对应的参数==k.sort(*key***=lambda** *a*:a[1])==注意使用
   >
   >    ```python
   >    l=[1,5,2,4,9,2,3]
   >    print(sorted(l))
   >    print(sorted(l,reverse=True))
   >    print(type(sorted(l)))
   >       # [1, 2, 2, 3, 4, 5, 9]
   >    # [9, 5, 4, 3, 2, 2, 1]
   >    
   >    l.sort()
   >    print(l)
   >    l.sort(reverse=True)
   >    print(l)
   >    print(l.sort())
   >    # None
   >       # [1, 2, 2, 3, 4, 5, 9]
   >    # [9, 5, 4, 3, 2, 2, 1]
   >    
   >    k=[["a",15],["b",12],["c",13]]
   >    def cmp(x):
   >        return x[1]
   >    k.sort(key=cmp)
   >    print(k)
   >    # [['b', 12], ['c', 13], ['a', 15]]
   >       k=[["a",15],["b",12],["c",13]]
   >    
   >          k.sort(key=lambda y :y[1])
   >       print(k)
   >    
   >          # [['b', 12], ['c', 13], ['a', 15]]
   >    ```
   >    
   > 4. ```python
   >    l=[1,5,4,3,8,9]
   >             
   >    l.sort(key=lambda x :x)
   >    for i in l:
   >        print(i)
   >    ```
   >
   >    

**python内置的len作为关键字（函数）使用**

```python
b=['apple','dasdasdas','h1']
print(a)
# [1, 4, 9, 3, 6, 7, 2]
b.sort(key=len)
print(b)
# ['h1', 'apple', 'dasdasdas']
```

==在Python中，默认的排序函数`sort()`需要接受一个返回值为布尔类型的比较函数作为参数，而不是返回值为整数类型的比较函数。==

```python
k=[1,2,5,3,2,4]
print(k)
k.sort(key=lambda x:x)
print(f"默认升序的排序{k}")
k.sort(key=lambda x:-x)
print(f"稍微修改降序的排序{k}")
# 默认升序的排序[1, 2, 2, 3, 4, 5]
# 稍微修改降序的排序[5, 4, 3, 2, 2, 1]


```

最简单的降序排列-----因为默认是升序，==排序再逆转==一下就🆗了

```python
a=[1,4,9,3,6,7,2]
print("原状态")
print(a)
a.sort()
print("默认升序")
print(a)
print("逆转后的降序")
a.sort(reverse=True)
print(a)
# 原状态
# [1, 4, 9, 3, 6, 7, 2]
# 默认升序
# [1, 2, 3, 4, 6, 7, 9]
# 逆转后的降序
# [9, 7, 6, 4, 3, 2, 1]
```

---



#### 4.2元组（有序的不可变序列）

##### 元组的创建(有两个带turple的	)

**==元组用来存储任意大小的数据集合，可以有任意个数据，可以是不同的数据类型，也可以是元组（嵌套）==**

> 1. 括号创建----注意区别==-创建只含有一个元素的元组要在元素的后面加上,==            不加逗号的时候会被理解为优先级的（）而不是元组的括号,就被理解为字符串而非元组
>
>    ```python
>    a=(1)
>    b=(1,)
>    print(type(a))
>    print(type(b))
>    # <class 'int'>
>    # <class 'tuple'>
>    ```
>
> 2. 使用构造函数 和列表非常的相似
>
>    ```python
>    print("元组的三种创建")
>    t1=("dsadsa",)
>    print(t1)
>    print(type(t1))
>    /////////
>     t1=tuple("dsadsad")
>    print(t1)
>     print(type(t1))
>    //////////
>    t1=(x for x in range(1,11))
>    //默认是生成器对象
>    t1=tuple(x for x in range(1,11) if x>1)
>    print(t1)
>    print(type(t1))
>    ```

##### 元组的访问和遍历

> 1. **下标[0，len-1]**
>
> 1. ==可以像列表一样访问但是不可以修改，别说什么删除 了==
>
> 2. ```python
>    d=tuple(x*2 for x in range(1,6) if x>=3)
>    print(d)
>    (6, 8, 10)
>    for i in d:
>        print(i)
>        # 6
>        # 8
>        # 10
>    ```
>
> 

##### 元组与列表的区别

> ==唯一就是可修改与不可修改的区别，元组是不可以通过元素的下标修改的，列表是可以的。==

##### 元组的相关操作

> 1. 由于元组的数据不可以被修改
>
> 2. ###### 元组名.count(x),查询x出现的次数
>
> 3. ###### 元组名.index(x)查询x的下标
>
> 4. len(元素名)查询元组的元素个数
>
>    ```python
>    p=tuple(f)
>    print(p)
>    # ('张', '三', '李四', '王五', '李六')
>    print(p.index("李四"))
>    print(p.count("王五"))
>    # 2
>    # 1
>    ```

----

##### 元组的注意事项/总结

虽然元组的元素不能修改

==但是如果元组里面放了一个list的时候，可以修改==

```python
m=(1,2,3,[4,5,6])
print(m)
# (1, 2, 3, [4, 5, 6])
m[3][0]=5
print(m[3])
# [5, 5, 6]
```

> 经过.上述对元组的学习，可以总结出列表有如下特点:
>
> 1. 可以容纳多个数据
> 2. 可以容纳不同类型的数据(混装)
> 3. 数据是有序存储的(下标索引)
> 4. 允许重复数据存在
> 5. 不可以修改( 增加或删除元素等)
> 6. 支持for循环
> 7. ==多数特性和list-致，不同点在于不可修改的特性。==

#### 4.3序列

**序列是最基本的数据结构，序列中的每一个元素都分配一个下标，[0,n-1],[-n,-1],n是元素个数=len(序列)**

***常见的序列，字符串，元组，列表***

##### 序列和通用操作（切片操作）

###### 切片操作

> 序列名[i:j:k]
>
> `根据ij索引切除片，并返回对应类型的对象`
>
> ==i表示起始位置，j代表索引结束位置，k代表步长，默认是1。[i,j-1]==
>
> ==这些操作都没有真正改变原来的序列，而是返回了一个新的序列。原来的序列仍然保持不变。如果要改变原来的字符串，可以将新的字符串赋值给原来的变量。例如：==
>
> ```python
> str="0123456789"
> 
> print(str[1:3])
> print(type(str[1:3]))
> # 12
> # <class 'str'>
> ```
>
> 切片的注意事项
>
> 1. 如果切片的索引i=0，那么从第一个到j-1的元素
>
> 2. 如果切片的索引j=0，那么会从i切到以后的元素
>
> 3. 如果开始和结束都为空，那么得到整个序列
>
> 4. ==如果i>j且步长>0，得到一个空的序列=='''';;如果步长为<0且就理解为反向走
>
> 4. 
>
>    ```python
>    print(d)
>    d=d[2:1]
>    print(d)
>    # (6, 8, 10)
>    # ()
>    ```
>
> 5. 如果步长为负数，就逆序获取元素
>
>    ```python
>    d=tuple(x for x in range(1,6))
>    print(d)
>    # ///////
>    d=d[0:len(d)]
>    # 等价于
>    d=d[::]
>    # ///////
>    print(d)
>                      
>    d=d[4:0:-1]
>    #理解为从4到0反向走一次走1
>    # 而且最终的个数等于绝对值这两个差
>    print(d)
>    ```
>    
>    ---
>    
>    ==综合案例，[::-1]常用来倒把序列给倒序==
>    
>    ```python
>    c="万过薪月，员序程马牛来，nohtyP学"
>    c=c[::-1][9:14]
>    print(c)
>    c="万过薪月，员序程马牛来，nohtyP学"
>    c=c[5:10][::-1]
>    print(c)
>    c="万过薪月，员序程马牛来，nohtyP学"
>    c=c.split('，')[1][:5][::-1]
>    print(c)
>    # 牛马程序员
>    # 牛马程序员
>    # 牛马程序员
>    ```
>
> 

###### 连接和复制

[去字典](#字典)

> 1. 连接
>
>    ```python
>    d=tuple(x for x in range(1,6))
>    e=tuple(x for x in range(6,11))
>    print(d)
>    print(e)
>    f=d+e
>    print(f)
>    # (1, 2, 3, 4, 5)
>    # (6, 7, 8, 9, 10)
>    # (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
>    ```
>
> 2. 复制
>
>    ```python
>    d=tuple(x for x in range(1,6))
>    print(d)
>    print(d*3)
>    # (1, 2, 3, 4, 5)
>    # (1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5)
>    ```

###### 成员检查（成员运算符in not in）

> ```python
> d=tuple(x for x in range(1,6))
> print(d)
> # (1, 2, 3, 4, 5)
> print(3 in d)
> print(11 in d)
> # True
> # False
> ```

###### 内置函数max,min,len

> 1. len()计算序列的长度，也就是元素/字符的个数
>
> 2. max()寻找序列中的最大值
>
> 3. min()寻找序列中的最小值
>
>    ```python
>    d=tuple(x for x in range(1,7))
>    print(d)
>    print(len(d))
>    print(max(d))
>    print(min(d))
>    # (1, 2, 3, 4, 5, 6)
>    # 6
>    # 6
>    # 1
>    ```

##### ==序列的相互转换==（字符串，列表，元组之间的转换）

**并没有改变真身，但可以赋值给真身**

> 1. 字符串转为列表和元组-----list(),tuple()
>
>    ```python
>    d='你好啊小盆友'
>    print(d)
>    print(list(d))
>    print(tuple(d))
>    # 你好啊小盆友
>    # ['你', '好', '啊', '小', '盆', '友']
>    # ('你', '好', '啊', '小', '盆', '友')
>    ```
>
> 2. 列表与元组的相互转换-----------------list(),tuple()，只不过里面放的不是字符串了
>
>    ```python
>    d=[1,"我",2,'取']
>    print(d)
>    print(tuple(d))
>    # [1, '我', 2, '取']
>    # (1, '我', 2, '取')
>
>    e=(3,"你",5,'曲')
>    print(e)
>    print(list(e))
>    # (3, '你', 5, '曲')
>    # [3, '你', 5, '曲']
>    ```
>
> 3. ==列表和元组转换为字符串==--------用到了字符串的join方法。需要一个字符串来把新的序列转换为字符串并连接到已有的字符串上面。 ------------==前提是列表里面都是字符串类型或者字符类型==，“ ” ‘ ’，纯数字不可以
>
>    ```python
>    f=['张','三','李四','王五','李六']
>    e=''
>    print(type(e))
>    print(e.join(f))
>    # <class 'str'>
>    # 张三李四王五李六
>    str()只是把对象转化为人容易看懂的字符串
>    ```

#### Str()函数

> `str()`函数是Python内置的一个函数，用于将对象转换为字符串形式。
>
> `str()`函数的语法如下：
>
> ```python
> str(object)
> ```
>
> 其中，`object`是要转换为字符串的对象。`object`可以是数字、字符串、列表、元组、字典、集合等等。
>
> `str()`函数的工作原理如下：
>
> - 如果`object`是字符串类型，则返回该字符串本身。
>
> - 如果`object`是数字类型（整数、浮点数等），则返回对应的字符串表示。
>
> - 如果`object`是列表、元组、字典、集合等可迭代对象，则返回一个包含各个元素的字符串表示。
>
> - 如果`object`是自定义的对象，则根据对象的`__str__()`方法返回字符串表示。
>
> - 以下是一些示例：
>
>   ```python
>   print(str(10))  # 将整数转换为字符串 '10'
>   print(str(3.14) ) # 将浮点数转换为字符串 '3.14'
>   print(str([1, 2, 3]))  # 将列表转换为字符串 '[1, 2, 3]'
>   print(str(('a', 'b', 'c')))  # 将元组转换为字符串 "('a', 'b', 'c')"
>   print(str({'name': 'John', 'age': 25}))  # 将字典转换为字符串 "{'name': 'John', 'age': 25}"
>   ```

---

<a name="字典"></a>

#### 4.4字典（无序Key-Value集合）

##### 字典的创建

> 1. #### 使用花括号{}创建字典
>
>    ```python
>    a={"key1":1,"key2":2}
>    print(a)
>    # {'key1': 1, 'key2': 2}
>                                                                                                          
>    a["key1"]=2
>    print(a
>    # {'key1': 2, 'key2': 2}
>                                                                                                          
>    b={}
>    print(b)
>    # {}
>    ```
>
> 
>
> 2. #### 使用函数创建字典
>
>    ```python
>    c=dict()
>    print(c)
>    # {}
>    c=dict(red=1,blue=2)
>    print(c)
>    # {'red': 1, 'blue': 2}
>    l=[("red",1),("green",3)]
>    c=dict(l)
>    print(c)
>    # {'red': 1, 'green': 3}
>    ```
>
> 
>
> 3. #### 使用推导式创建字典-----==p={x: x for x in range(1,6)} 严格按照格式，不带dict（）==
>
>    ```python
>    p={x: x*2 for x in range(1,6)}
>    print(p)
>    # {1: 2, 2: 4, 3: 6, 4: 8, 5: 10}
>    p={x: x*2 for x in range(1,6) if x>=2}
>    print(p)
>    # {2: 4, 3: 6, 4: 8, 5: 10}
>    #=----------------
>    l=[("red",1),("green",3)]
>    ll={x:j for x,j in l}
>    print(ll)
>    # {'red': 1, 'green': 3}
>    ```

##### 字典的使用场景

> ```python
> zd={"王力宏":{"语文":60,"数学":22,"英语":50},"周杰伦":{"语文":20,"数学":42,"英语":60}}
> print(zd)
> print(zd["王力宏"]["语文"])
> # {'王力宏': {'语文': 60, '数学': 22, '英语': 50}, '周杰伦': {'语文': 20, '数学': 42, '英语': 60}}
> # 60
> ```

##### 字典的访问/更新

> 字典名[键]=新的值
>
> 1. 如果新增的key原来字典不存在，那么就新增一个键值对,==加在字典的后面==
>
> 2. 如果新增的key原来存在，那么就会覆盖原来的键值对（更新）
>
>    ```python
>                                                                                                          
>    zd={"王力宏":{"语文":60,"数学":22,"英语":50},"周杰伦":{"语文":20,"数学":42,"英语":60}}
>    zd["许闰博"]={"语文":100,"数学":98}
>    print(zd)
>    # {'王力宏': {'语文': 60, '数学': 22, '英语': 50}, '周杰伦': {'语文': 20, '数学': 42, '英语': 60}, '许闰博': {'语文': 100, '数学': 98}}
>    zd["王力宏"]["语文"]=0
>    print(zd["王力宏"]["语文"])
>    # 0
>    ```

##### 字典的遍历

```python

zd={'王力宏': {'语文': 60, '数学': 22, '英语': 50}, '周杰伦': {'语文': 20, '数学': 42, '英语': 60}, '许闰博': {'语文': 100, '数学': 98}}
key=zd.keys()
value=zd.values()
print(key)
print(value)
for k in key:
    print(f"键是{k},对应的值是{zd[k]}")
# dict_keys(['王力宏', '周杰伦', '许闰博'])
# dict_values([{'语文': 60, '数学': 22, '英语': 50}, {'语文': 20, '数学': 42, '英语': 60}, {'语文': 100, '数学': 98}])
# 键是王力宏, 对应的值是
# {'语文': 60, '数学': 22, '英语': 50}
# 键是周杰伦, 对应的值是
# {'语文': 20, '数学': 42, '英语': 60}
# 键是许闰博, 对应的值是
# {'语文': 100, '数学': 98}
```

---

> ##### 其实是等价的

```python
j={x:x*2 for x in range(1,6) if x>=2}

# {2: 4, 3: 6, 4: 8, 5: 10}
for i in j:
    print(i,j[i])
# 2 4
# 3 6
# 4 8
# 5 10
```

##### 删除字典元素和删除字典和清空字典

```python
# pop(key[, default])
d={"key1":1,"key2":2}
print(d)
d.pop("key1",1)
print(d)
d.pop("key3",1)
print(d)

del d["key2"]
print(d)
```

##### 字典的常用方法

| 编号 | 操作             | 说明                                                         |
| ---- | ---------------- | ------------------------------------------------------------ |
| 1    | 字典[Key]        | 获取指定Key对应的Value值                                     |
| 2    | 字典[Key]= Value | 添加或更新键值对  ，原来有的就覆盖，原来没有就添加           |
| 3    | 字典.pop(Key)    | # pop(key[, default])取出Key对应的Value并在字典内删除此Key的键值对 |
| 4    | 字典.clear()     | 清空字典,主要看第一个参数就算第二个喝第一个对应不住也是ok的  |
| 5    | 字典.keys()      | 获取字典的全部Key,可用于for循环遍历字典                      |
| 6    | len(字典)        | 计算字典内的元素数量                                         |

> 1. #### keys（）方法||==以列表的形式==返回字典的所有键
>
>    ```python
>    aaa={"k1":1,"k2":9}
>    print(aaa)
>    print(aaa.keys())
>    # {'k1': 1, 'k2': 9}
>    # dict_keys(['k1', 'k2'])
>    ```
>
> 2. #### values()方法||==以列表的形式==返回字典的所有值
>
>    ```python
>    aaa={"k1":1,"k2":9}
>    print(aaa)
>    print(aaa.values())
>    # {'k1': 1, 'k2': 9}
>    # dict_values([1, 9])
>    ```
>
> 3. #### items()方法||==以列表的形式==返回字典键值对==对应的元组的可视对象==
>
>    使用下标运算符`[]`来访问一个`dict_items`对象。`dict_items`对象是由字典的`items()`方法返回的一个视图对象，==它不支持下标运算符。==
>
>    要访问`dict_items`对象中的元素，您可以使用==迭代器==或将其==转换为列表==后再进行访问。
>
>    ```python
>    aaa={"k1":1,"k2":9}
>    print(aaa)
>    print(aaa.items())
>    # {'k1': 1, 'k2': 9}
>    # dict_items([('k1', 1), ('k2', 9)])
>    一般强制转换为list使用
>    ```
>
> 4. #### ==get(键,default)方法==||返回指定键对应的值，如果没有就返回default，默认是none
>
>    ```python
>    aaa={"k1":1,"k2":9}
>    print(aaa)
>    print(aaa.get("k1","该键不存在啊"))
>    print(aaa.get("k3"))
>
>    print(aaa.get("k3","该键不存在啊"))
>    # {'k1': 1, 'k2': 9}
>    # 1
>    # None
>    # 该键不存在啊
>    ```
>
> 5. #### copy()方法||返回一个新的字典，新开辟的
>
>    1. ###### copy与直接赋值一份字典的区别  --二者公用同一份。也就是后者指向前者。
>
>       ```python
>       aaa={"k1":1,"k2":9}
>       print(aaa)
>       bbb=aaa
>       print(bbb)
>       aaa["k1"]=2
>       print(aaa)
>       print(bbb)
>       # {'k1': 1, 'k2': 9}
>       # {'k1': 1, 'k2': 9}
>       # {'k1': 2, 'k2': 9}
>       # {'k1': 2, 'k2': 9}
>       ```
>
>    2. ###### copy就不一样了，直接开辟一个新的字典
>
>       ```python
>       aaa={"k1":1,"k2":9}
>       bbb=aaa.copy();
>       print(aaa)
>       print(bbb)
>       aaa["k1"]=100
>       print(aaa)
>       print(bbb)
>       # {'k1': 1, 'k2': 9}
>       # {'k1': 1, 'k2': 9}
>       # {'k1': 100, 'k2': 9}
>       # {'k1': 1, 'k2': 9}
>       ```
>
> 6. #### clear()方||清空字典，删除字典的全部元素，得到空字典 与del 字典名不同，区别在于是否完全删除字典
>
>    ```python
>    aaa={"k1":1,"k2":9}
>    print(aaa)
>    aaa.clear()
>    print(aaa)
>    # {}
>    ```
>
> 7. #### ==pop（键，default）==方法||返回指定的 键对应的值，并在字典中将其移除. 如果没有就直接报错或者default对应的值
>
>    ```python
>    aaa={"k1":1,"k2":9}
>    print(aaa)
>    print(aaa.pop("k1"))
>    print(aaa)
>    print(aaa.pop("k4",101))
>    # {'k1': 1, 'k2': 9}
>    # 1
>    # {'k2': 9}
>    # 101
>    ```
>
> 8. ##### popitem()方法，随机删除字典中的一组键值对，默认是最后一对，==并且以元组的形式返回这一对==

##### 字典的注意事项

> ##### ==key不可以重复，类比生活中的字典==
>
> ##### 没有下标索引，但可以使用key来查找对应的value

#### 4.5==集合（**无序不重复集合**）==

> 集合与列表相似，可以放多个数据，并且元素的存放是无序的，----==集合元素不可以是列表，字典，集合等可变对象不能有重复数据==，

##### 集合的创建

***集合的创建与字典的创建类似，但是又有区别。无序，元素的位置跟集合创建的位置无关，每次打印的顺序也不同,不能出现重复的元素，可以用来消除重复元素***

1. ##### 使用花括号创建集合

   ```python
   print("-s---------------------------------------")
   s1={'黑色',"白色","蓝色","蓝色",'1'}
   print(s1)
   print(type(s1))
   # {'白色', '蓝色', '黑色', '1'}
   # <class 'set'>
   ```

2. ##### 使用set（）函数创建

   ```python
   s1=set("hellword")
   print(s1)
   m1=['1',2,3,4]
   m2=(1,2,3,"2")
   print(type(m1))
   print(type(m2))
   s1=set(m1)
   print(s1)
   s1=set(m2)
   print(s1)
   s1=set()
   print(s1)
   # {'r', 'h', 'e', 'o', 'w', 'd', 'l'}
   # <class 'list'>
   # <class 'tuple'>
   # {'1', 2, 3, 4}
   # {'2', 1, 2, 3}
   # set()
   ```

3. ##### 使用推导式创建

   > 与列表的推导式相同只不过用的是{}
   >
   > s1={x for x in 可迭代对象 判断语句}
   >
   > ```python
   > se={1,2,3,1}
   > se=set("helloworld")
   > se={i for i in range(1,11)}
   > for i in se:
   >     print(i)
   > ```

##### 访问集合 的元素

> ##### 因为集合是无序的，所以无法使用下标来操作
>
> ##### 但可以通过for循环来访问集合的元素
>
> ```python
> s1={x for x in range(1,6) if x>=3}
> for x in s1:
>     print(x)
>     # 
>     # 3
>     # 4
>     # 5
> ```

##### 集合添加元素

> ##### 使用add（）方法，因为集合是无序的，只把新的元素添加进去。不考虑位置，
>
> ```python
> s1={x for x in range(1,6) if x>=3}
> 
> print(s1)
> # {3, 4, 5}
> s1.add(8)
> print(s1)
> # {3, 4, 5}
> # {8, 3, 4, 5}
> ```

##### 集合中常用的方法

| 编号 | 操作                                  | 说明                                                         |
| :--: | ------------------------------------- | ------------------------------------------------------------ |
|  1   | 集合.add(元素)                        | 集合内添加一个元素  不管位置，只管添加进去                   |
|  2   | 集合.remove(元素)                     | 移除集合内指定的元素  没有的话就报错                         |
|  3   | 集合.pop()                            | ==从集合中随机取出一个元素,并且返回她==                      |
|  4   | 集合.clear()                          | 将集合清空                                                   |
|  5   | 集合1.difference(集合2)   集合1>集合2 | ==得到一个新集合==，集合的差集   原有的2个集合内容不变,,,1-2 |
|  6   | 集合1.difference_update(集合2)  对称  | 在集合1中，求差集 不反悔新的集合而是把结果保存再集合1中,,,1-2 |
|  7   | 集合1.union(集合2)   并集             | ==得到1个新集合，内含2个集合的全部元素==   原有的2个集合内容不变,,,1+2 |
|  8   | len(集合)                             | 得到一个整数，记录了集合的元素数量                           |

> 1. ##### remove(x),删除集合中的x元素，2.如果不存在就报错
>
>    ```python
>    s1={x for x in range(1,6) if x>=3}
>                                                                                                          
>    print(s1)
>    # {3, 4, 5}
>    s1.remove(4)
>    print(s1)
>    # {3, 4, 5}
>    # {3, 5}
>    ```
>
>    ```python
>    s1={x for x in range(1,6) if x>=3}
>                                                                                                          
>    print(s1)
>    # {3, 4, 5}
>    s1.remove(6)
>    print(s1)
>    # Traceback (most recent call last):
>    #   File "E:\PYTHON\字典.py", line 247, in <module>
>    #     s1.remove(6)
>    # KeyError: 6
>    ```
>
> 
>
> 2. ##### discard（x），删除集合中的x元素，如果不存在，程序不做任何操作-★★★★★★★★推荐且默认返回none
>
>    ```python
>    s1={x for x in range(1,6) if x>=3}
>                                                                                                          
>    print(s1)
>    s1.discard(3)
>    print(s1)
>    # {3, 4, 5}
>    # {4, 5}
>    ```
>
> 
>
> 3. ##### pop（）方法，删除集合中的==任意一个元==素，并且返回该元素的值。因为集合没有下标操作，所以随机删
>
>    ```python
>    s1={x for x in range(1,6) if x>=3}
>                                                                                                          
>    print(s1)
>    print(s1.pop())
>    print(s1)
>    # {3, 4, 5}
>    # 3
>    # {4, 5}
>    ```
>
> 
>
> 4. ##### clear（）方法，清空集合，删除集合中的所有元素。
>
>    ```python
>    s1={x for x in range(1,6) if x>=3}
>    
>    print(s1)
>    s1.clear()
>    print(s1)
>    # {3, 4, 5}
>    # set()
>    ```
>    
> 5. ##### union()方法  联合起来，相当于并集
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    print(s1.union((s2)))
>    # {1, 2, 3, 4, 5, 6}
>    ```
>
> 6. ##### difference()方法 得到差集，注意顺序
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6,7}
>    print(s2.difference(s1))
>    print(s1.difference(s2))
>    # {4, 5, 6, 7}
>    # set()
>    ```
>
>    



##### **删除集合本身del**

> #### 直接不存在整个数据结构了

```python
s1={x for x in range(1,6) if x>=3}

print(s1)
del s1
print(s1)
# Traceback (most recent call last):
#   File "E:\PYTHON\字典.py", line 272, in <module>
#     print(s1)
#           ^^
# NameError: name 's1' is not defined. Did you mean: 'm1'?
```

##### 成员操作同于序列

```python
s1={x for x in range(1,6) if x>=3}

print(s1)
print(1 in s1)
print(3 in s1)
# {3, 4, 5}
# False
# True
```

##### 集合比较运算

| 比较运算符 | 相关描述                               |
| ---------- | -------------------------------------- |
| ==         | 比较两个集合是否相等，相等返回True     |
| ！=        | 比较两个集合是否不相等，不相等返回True |
| <          | 判断一个集合是否是另一个集合的严格子集 |
| <=         | 判断一个集合是否是另一个集合的子集     |
| >          | 判断一个集合是否是另一个集合的严格超集 |
| >=         | 判断一个集合是否是另一个集合的超集     |

> 1. ##### a是b的子集=》a<=b    意思就是a的元素b都有，且b的元素个数大于a的元素个数，但b没有a没有的
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,3}
>    print(s1<s2)
>    print(s1<=s2)
>    # False
>    # True
>    ```
>
> 2. ##### a是b的严格子集，a<b.意思就是a的元素b都有，且b的元素个数大于a的元素个数，但b有a没有的
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    print(s1<s2)
>    print(s1<=s2)
>    # True
>    # True
>    ```

##### 集合运算

> 1. ##### 交集运算 & 得到==两个集合共有的部分==，类型还是集合
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    s3=s1 & s2
>    print(s1 & s2)
>    print(s3)
>    # {1, 2, 3}
>    # {1, 2, 3}
>    ```
>
> 2. ##### 并集运算 | 得到两个集合并起来的整体，类型还是集合
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    print(s1 | s2)
>    # {1, 2, 3, 4, 5, 6}
>    ```
>
> 3. ##### 差集运算 - 得到两个集合元素的减法，类型还是集合
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    print(s2-s1)
>    # {4, 5, 6}
>    ```
>
> 4. ##### ==对称差集运算== ^ 得到两个集合的并集挖去交集，类型还是集合
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    print(s1|s2)
>    print(s1&s2)
>    print((s1|s2)-(s1&s2))
>    print(s1^s2)
>    # {1, 2, 3, 4, 5, 6}
>    # {1, 2, 3}
>    # {4, 5, 6}
>    # {4, 5, 6}
>    ```
>    
> 5. ##### union运算，==相当于并集==
>
>    ```python
>    s1={1,2,3}
>    s2={1,2,3,4,5,6}
>    print(s1.union((s2)))
>    # {1, 2, 3, 4, 5, 6}
>    ```

---

**经过.上述对集合的学习，可以总结出集合有如下特点:**
**可以容纳多个数据**
**●**
**可以容纳不同类型的数据(混装)**
**●**
**数据是无序存储的(不支持下标索引)**
**不允许重复数据存在**
**●**
**可以修改(增加或删除元素等)**
**●**
**支持for循环**

**不可以用while循环，因为不支持下标索引**

---

---

---

#### 综合回顾

###### 数据容器分类

> ###### 数据容器可以从以下视角进行简单的分类:
>
> ---
>
> ###### 是否支持下标索引
>
> ###### 支持:列表、元组、字符串一序列类型
>
> ###### 不支持:集合、字典-非序列类型
>
> ---
>
> ###### 是否支持重复元素:
>
> ###### 支持:列表、元组、字符串-序列类型,
>
> ###### 不支持:集合、字典-非序列类型
>
> ---
>
> ###### 是否可以修改
>
> ###### 支持:列表、集合、字典
>
> ###### 不支持:元组、字符串

###### 数据特点对比

|          | 列表                     | 元组                         | 字符串         | 集合           | 字典                                             |
| -------- | ------------------------ | ---------------------------- | -------------- | -------------- | ------------------------------------------------ |
| 元素数量 | 支持多个                 | 支持多个                     | 支持多个       | 支持多个       | 支持多个                                         |
| 元素类型 | 任意                     | 任意                         | 仅字符         | 任意           | Key: Value  Key:除字典外任意类型  Value:任意类型 |
| 下标索引 | 支持                     | 支持                         | 支持           | 不支持         | 不支持                                           |
| 重复元素 | 支持                     | 支持                         | 支持           | 不支持         | 不支持                                           |
| 可修改性 | 支持                     | 不支持                       | 不支持         | 支持           | 支持                                             |
| 数据有序 | 是                       | 是                           | 是             | 否             | 否                                               |
| 使用场景 | 可修改、可重复的一批数据 | 不可修改、可重复的一批数据记 | 一串字符的记录 | 不可重复的数据 | 以Key检索Value                                   |

```python
a=list("dasdasd")
print(a)#['d', 'a', 's', 'd', 'a', 's', 'd']
a=[x for x in range(1,11)]
print(a)#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(type(a))#<class 'list'>
a=[1,2,3,4]
print(a)#[1, 2, 3, 4]
print("----------------------------")
b=(1,2,3,5)
print(b)#(1, 2, 3, 5)
b=tuple("sdadasd")
print(b)#('s', 'd', 'a', 'd', 'a', 's', 'd')
b=(x for x in range(1,11))#
#生成器对象默认是
print(type(b))#<class 'generator'>
b=tuple(x for x in range(1,11))
print(b)#(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
print("----------------------------")
c=dict(a=1,b=3,c=2)#{'a': 1, 'b': 3, 'c': 2}
print(c)
c={"1":1,"key2":2}
print(c)
l=[(1,2),(3,4)];
c={x:j for x,j in l}
print(c)#{'1': 1, 'key2': 2}

c={x:y for x in range(1,6) for y in range(6,11)}
print(c)#{1: 10, 2: 10, 3: 10, 4: 10, 5: 10}
```

#### 数据结构的通用操作

| 功能                       | 描述                                                         |
| -------------------------- | ------------------------------------------------------------ |
| 通用for循环                | 遍历容器( 字典是遍历key)                                     |
| max                        | 容器内最大元素                                               |
| min()                      | 容器内最小元素                                               |
| len()                      | 容器元素个数                                                 |
| list()                     | 转换为列表                                                   |
| tuple()                    | 转换为元组                                                   |
| str()                      | 转换为字符串                                                 |
| set()                      | 转换为集合                                                   |
| 排序，reverse=True表示降序 | sorted(序列，[reverse=True])  得到一个排好序的列表  默认是从小到大  没有改变真身 |

---

> 1. ###### 都支持遍历操作
>
>    > 首先，在遍历上:
>    > ●
>    > 5类数据容器都支持for循环遍历
>    > ●
>    > ==列表、元组、字符串支持while循环，集合、字典不支持(无法下标索引)==
>    > 尽管遍历的形式各有不同，但是，它们都支持遍历操作。
>
> 2. ###### 通用内置函数
>
>    > 1. **len()计算数据容器的长度，也就是元素/字符的个数**
>    >
>    > 2. **max()寻找数据容器中的最大值**
>    >
>    > 3. **min()寻找数据容器中的最小值**
>    >
>    > 4. ##### 特殊的字典,返回的是键而不是值
>    >
>    > 5. ```
>    >    b=(1,2,4,6)
>    >    l=[1,3,5,7,9]
>    >    k={"key1":1,"key2":3}
>    >    e={1,23,4,5,6}
>    >    print(max(b),max(l),max(k),max(e))
>    >    # 6 9 key2 23
>    >    ```
>    >
>    >    
>
> 3. 通用转换
>
>    > ##### list(容器)
>    >
>    > ##### 将给定容器转换为列表
>    >
>    > ##### str(容器)
>    >
>    > ##### 将给定容器转换为字符串
>    >
>    > ##### tuple(容器)
>    >
>    > ##### 将给定容器转换为元组
>    >
>    > ##### set(容器)
>    >
>    > ##### 将给定容器转换为集合
>    >
>    > ---
>    >
>    > 字典转化为列表，元组，集合都会忽略掉他的value,转为字符串的时候不省略
>    >
>    > ```python
>    > p={"k1":1,"k2":2,"k3":3}
>    > print(list(p))
>    > print(tuple(p))
>    > print(set(p))
>    > print(f"转为人容易读的字符串{str(p)}")
>    > print("转为真正的字符串","".join(p))
>    > # ['k1', 'k2', 'k3']
>    > # ('k1', 'k2', 'k3')
>    > # {'k3', 'k1', 'k2'}
>    > # 转为人容易读的字符串{'k1': 1, 'k2': 2, 'k3': 3}
>    > # 转为真正的字符串 k1k2k3
>    > ```
>    >
>    > ##### 但是将他们转换为真正的字符串的时候要用一个空串的join函数哦
>    >
>    > ###### 转化成集合的时候，1去重操作，2顺序打乱
>
> 4. ###### 通用排序功能
>
>    > sorted(容器，reverse=false)
>    >
>    > 默认是从小到大,==但没有真正改变原本的数据==
>    >
>    > ```python
>    > p=[5,2,7,1]
>    > print(sorted(p))
>    > # [1, 2, 5, 7]
>    > print(sorted(p,reverse=True))
>    > 
>    > # [1, 2, 5, 7]
>    > # [7, 5, 2, 1]
>    > print(p)
>    > # [5, 2, 7, 1]
>    > ```

##### 字符串的比较

---

按位比较，一位一位的比较，例如ab>aa,ab>a,比较对应的ancii码

从头到尾一位一位的比较，其中一位大，后面就不用比较了。

```python
print("abc">"abd")
```

---

---



### Python函数

#### 函数和方法的区别

> 函数直接传入参数就可以使用
>
> 方法需要用.来引用，例如num=student.pop(1)

#### 内置函数

**==`random.randint(x, y)`函数返回一个在闭区间`[x, y]`内的随机整数，包括`x`和`y`在内。==**

> 1. 提前写好的
> 2. 可以重复使用的
> 3. 把重复性的工作给封装起来 了
> 4. 针对特定功能
> 4. **len()计算数据容器的长度，也就是元素/字符的个数**
> 6. **max()寻找数据容器中的最大值**
>
> 7. **min()寻找数据容器中的最小值**

自定义函数

#### 函数的基础定义语法

> def 函数名字(参数1，参数.....):
>
> ​	函数体
>
> return 返回值
>
> 函数定义里面的x，y是==形参==，函数调用时候传入的为==实参==
>
> 多个参数用，隔开

```python
def myf1(x,y):
    return x*2+y*3

print(myf1(1,2))
# 8
```

```python
def myf():
    print("我是大帅逼")

for k in range(1,11):
    myf()
    
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
# 我是大帅逼
```

> ###### ==注意事项==
>
> 1. 如果没有参数就省略
> 2. 返回值不需要也可以省略
> 3. 函数必须先定义再使用

#### 函数的返回值

***没有返回值的函数实际上返回了NONE***

```python
result=myf()
print(result)
result=myf1(1,2)
print(result)
# None
# 8
```



> 1. ###### 函数可以返回一个值或多个值。在函数中使用`return`语句后，==函数将会立即停止执行==，并将指定的值返回给调用者。如果没有使用`return`语句，函数将默认返回`None`。
>
> 2. **函数==可以返回任意类型的值==，包括整数、浮点数、字符串、列表、字典、元组等。**
>
> 3. 如果函数返回多个值，可以使用元组、列表或字典等数据结构来存储这些值，并一起返回。
>
> 4. 可以使用函数的返回值来赋值给一个变量，或者作为另一个函数的参数。
>
> 5. 如果函数没有返回值，即没有使用`return`语句，或者`return`语句没有指定返回值，则函数默认返回`None`。
>
> 6. 可以使用`return`语句提前结束函数的执行，并返回指定的值。
>
> 7. 如果函数没有返回值，可以省略`return`语句。

#### 函数的说明文档（帮助理解自己的函数）

> 1. ‘’‘回车自动弹出
>
> 2. 用于解释函数
>
> 3. 鼠标放在函数上的时候会现实相关的说明
>
>    ```python
>    def myf1(x,y):
>        '''
>        第一个参数*2+第二个参数*3 的和
>        :param x:第一额加的数
>        :param y:第二个加的数
>        :return:返回值是运算结果
>        '''
>        return x*2+y*3
>    ```

#### 函数的嵌套

一个函数里用另一个函数的方法

直接运用

```python
def fun1():
    print("------1------")
def fun2():
    print("--------2-------")
    fun1()
    print("--------3---------")
fun2()
# --------2-------
# ------1------
# --------3---------
```

#### ==变量的作用域==

> ###### ==python中并不是所有的语句块都会产生作用域，只有在函数，类中定义的语句块，才会产生作用域。==
>
> ###### ==在if-else，for，while，等关键字里面定义的语句块并不会擦还是你哼作用域，仍然创建的是全局变量==

##### 局部变量

在函数内部定义的，只能在函数返回内使用

函数执行完毕后局部变量就被销毁了

全局变量，在函数体内体外都可以使用的变量

就算同名也不一样

##### 全局变量

***==global关键字把在函数内部声明的变量变成全局变量==***，外面没有的话就创建一个全局变量，外边有的话，二者就为同一个全局变量。

在Python中，==函数内部默认情况下只能访问局部范围内的变量==。要在函数内部使用外部变量，需要使用`global`关键字将其声明为全局变量。

```python
a=100
def fun3():
    a+=100
    print(f"我现在是{a}")

fun3()
#直接报错
# Traceback (most recent call last):
#   File "E:\PYTHON\函数.py", line 62, in <module>
#     fun3()
#   File "E:\PYTHON\函数.py", line 59, in fun3
#     a+=100
#     ^
# UnboundLocalError: cannot access local variable 'a' where it is not associated with a value
```

用了global关键字后

```python
def fun3():
    global a
    #==global使用的时候不能初始化，也就是说只能声明==
    a+=100
    print(f"我现在是{a}")

fun3()
# 我现在是200
```

> 注意事项
>
> 1. ==global使用的时候不能初始化，也就是说只能声明==
> 2. 定义：==定义是指在程序中为变量分配内存空间==，并为其分配一个唯一的标识符（即变量名）。定义变量时，编译器会为其分配内存空间，以便在程序执行期间存储和操作数据。
> 3. 声明：==声明是指在程序中引入变量的标识符，以便在后续的代码中使用该变量==。声明变量时，编译器会告诉程序变量的数据类型和名称，但不会为其分配内存空间。因此，在声明变量之后，变量是不可用的。
> 4. 初始化：==初始化是指在声明变量的同时为其赋予一个初始值。==初始化变量时，编译器会为其分配内存空间，并将初始值存储在该内存空间中。初始化变量可以在声明时进行，也可以在稍后的代码中进行。

#### 综合案例

```python
money=120
name="猫饼"
def menu():
    print("1\t查询余额函数\n""2\t存款函数\n""3\t取款函数\n""4\t主菜单函数")
def funcsearch():
    print(f"您现在的余额为{money}元")
def funccunkuan():
    global money
    a=int(input("你要存多少？"))
    money+=a
def funcqukuan():
    global money
    a=int(input("你要取多少？"))
    if a<=money:
        money-=a
    else:
        print(f"{name}你特么有多少你没点b数？")
name=input("请输入你姓名")
# menu()
while True:
    menu()
    p=int(input("您要干神马？"))
    # print(p)
    if p==1:
        funcsearch()
    elif p==2:
        funccunkuan()
        funcsearch()
    elif p==3:
        funcqukuan()
        funcsearch()
    elif p==4:
        print(" 1 查询余额函数\n", "2 存款函数\n", "3 取款函数\n", "4 主菜单函数")
    elif p==0:
        print("谢谢你使用牛马ATM自助存取一体机")
        break

```



### python函数进阶

##### 函数有多个返回值,

> ##### 函数有多个返回值,---对应多个变量来接受它。变量之间用，隔开，而且可以是不同的数据类型.。==如果直接返回的话，得到对应的元组==
>
> ```python
> def func1():
>        return 1,"牛马",3
> 
> x,y,z=func1()
> 
> print(x,y,z)
>    print(func1())
> print(type(func1))
> ```

##### ==位置参数和关键字参数==

**位置参数就默认的，需要严格的对应。**

==**关键字参数键值对的形式==，更加清晰。原始的情况需要严格对应。混合使用的时候，位置参数必须在前面。**

```python
print("----------位置参数----------------")
def func3(x,y,z):
    return x+y+z
print(func3(1,2,3))
print("----------关键字参数----------------")
print(func3(x=1,y=2,z=3))
# 6
# 6

print(func3(x=1,2,z=3))
error
```

##### 默认参数

> ##### 在函数定义的时候就给形参一个默认的赋值，以后调用函数的时候，如果不给默认参数对应的实参，就用默认参数，如果给了就用实参。
>
> ---
>
> ##### 默认参数需要写在形参的最后
>
> ###### 否则就会报错
>
> ##### SyntaxError: non-default argument follows default argument

```python
def func3(x,y,z=9):
    return x+y+z
print(func3(x=1,y=2,z=3))
print(func3(x=1,y=2))
# 6
# 12
```

##### 位置不定长---元组

传入时候的参数数量是不受限制的

***标记一个形参， 以元组的形式接受实参**

```python
def funccc(*kwargs):
    print(f"kwargs的类型是{type(kwargs)},值是{kwargs}")
funccc(1,2,3,4,5,6)
# kwargs的类型是<class 'tuple'>,值是(1, 2, 3, 4, 5, 6)



def add(*args):
    result = 0
    for num in args:
        result += num
    return result

numbers = (1, 2, 3, 4)  # 打包成元组

result = add(*numbers)  # 解包，相当于 add(1, 2, 3, 4)
print(result)  # 输出：10

```

##### 关键字不定长---字典

传入时候的参数数量是不受限制的

**标记一个形参，以字典的形式接受实参**

```python
def funccc(**kwargs):
    print(f"kwargs的类型是{type(kwargs)},值是{kwargs}")
funccc(key1=1,key2=2)
# kwargs的类型是<class 'dict'>,值是{'key1': 1, 'key2': 2}

def add(**args):
    result = 0
    for num in args:
        result += args[num]
    return result

numbers =dict(key1=1,key2=2,key3=3)# 打包成字典

result = add(**numbers)  # 解包，相当于 add(1, 2, 3, 4)
print(result)  # 输出：10

```

##### 函数作为参数传递（计算逻辑的传递）

##### 函数参数

**形参和实参没有强制一致**

*数据是确定的，计算逻辑是可变的。*

```python

def compute(x,y):
    return x+y

a=19;b=20
def text(computee):
    result=compute(a,b)+1
    return result
print(compute(a,b))
print(text(compute(9,3)))
# 39
# 40
```

二者的区别

> ##### 普通的函数def add(x,y):
>
> #####  						return x+y
>
> ##### 传入的是数据，确定的是代码的执行逻辑，不确定的是数据
>
> ##### 函数作为函数的参数  def func(add):
>
> ##### 											result=add(1,2)
>
> ##### 											return result
>
> ##### 传入的是函数的代码执行 逻辑，确定的是数据，不确定的是代码的执行逻辑



##### 匿名函数

def定义带有名称的函数

lambda定义匿名函数

```
lambda 参数列表: 表达式
```

**有名称的可以基于名称重复使用**

**匿名函数，只可以临时使用一次**

==**自带返回return功能**==

**匿名函数的函数体只能写一行，无法写多行代码，且参数不带括号**

```python
def compute(x,y):
    return x+y

a=19;b=20
def text(computee):
    result=compute(a,b)
    return result
print(text(lambda x,y:x+y))
# 39
```

### 文件的操作

##### 文件的编码

> ##### 翻译的规则，如何将内容翻译为二进制，然后电脑使用的时候再翻译为文本就ok了
>
> ###### utf-8,逐渐通用
>
> gbk
>
> big5等等
>
> 不同的编码格式会翻译不同的结果
>
> ##### 我喜欢你->我讨厌你.......

---

##### 文件的打开-读取操作

默认都把\n也读进来了

**没有这个文件的时候就报错**

==如果没有这个文件在异常捕获的时候会返回一个none，if语句会把none当作false看作==★★★★★★★★

```python
def print_file_info(file_name):
    f=None
    try:
        f=open(file_name,"r",encoding="utf-8")
    except Exception as reason:
        print("文件tm打不开啊")
    else:
        print(f.read())
    finally:
        # print(f)
        if f:
            f.close()
```

---



```python
print("打开文件")
f=open("./1.txt","r",encoding="UTF-8")
print(type(f))
# 打开文件
# <class '_io.TextIOWrapper'>


```

> 1. ##### 文件对象.read（num）方法,num代表的是要读取的长度单位是字节,==没有传入就默认读取全部数据==，==以字符串返回==
>
>    ```python
>    print("打开文件")
>    f=open("./1.txt","r",encoding="UTF-8")
>    print(type(f))
>    # 打开文件
>    # <class '_io.TextIOWrapper'>
>    # print(f.read())
>    print(f.read(10))
>    # 哈利大苏打阿达阿松大 |第一次读到这里，第二次继续读
>    # 啊啊
>    print(f.read())
>    ```
>
> 2. ###### 文件对象.readlines（）方法，==读取全部行==并且封装到列表中返回  ==以列表返回==
>
>    ```
>    print("打开文件")
>    f=open("./1.txt","r",encoding="UTF-8")
>    print(type(f))
>    # 打开文件
>    # <class '_io.TextIOWrapper'>
>    print(f.readlines())
>    # ['哈利大苏打阿达阿松大啊啊\n', 'dadasdasdasdsad']
>    ```
>
> 3. ###### 文件对象.readline（num）方法，读取一行的内容，返回字符串   ==以字符串返回==
>
>    ```python
>    print("打开文件")
>    f=open("./1.txt","r",encoding="UTF-8")
>    print(type(f))
>    # 打开文件
>    # <class '_io.TextIOWrapper'>
>    print(f.readline())
>    # 哈利大苏打阿达阿松大啊啊
>    ```
>
> 4. ##### for循环方法读取   ==以字符串返回==
>
>    ```python
>    print("打开文件")
>    f=open("./1.txt","r",encoding="UTF-8")
>    print(type(f))
>    # 打开文件
>    # <class '_io.TextIOWrapper'>
>    for i in f:
>        print(i)
>    # 哈利大苏打阿达阿松大啊啊
>    #
>    # dadasdasdasdsad
>    #
>    ```
>    
> 5. ==使用默认的 GBK 编码解码文件时，遇到了无法解析的字节序列，导致解码错误。==
>
>    ```python
>    f=open("./1.txt", "r",errors="ignore")
>    print(f.read())
>    # 鍝堝搱鍝堝搱鍝堝搱
>    # 鍛滃憸鍛滃憸鍛
>    # 鍣㈠櫌鍣㈠櫌
>    ```
>
>    

---

> #####  文件对象.close(),关闭文件，取消对文件的占用。
>
> ```python
> f.close()
> ```

##### with-open语法★★★★★

> ##### 对文件的操作完成后，会自动的把文件给close掉
>
> ```python
> print("打开文件")
> # f=open("./1.txt","r",encoding="UTF-8")
> 
> with open ("./1.txt","r",encoding="utf=8") as f:
>     print(f.readlines())
> print(f.read())
> #关闭后的文件是不能再读取的
> # ['哈利大苏打阿达阿松大啊啊\n', 'dadasdasdasdsad']
> # Traceback (most recent call last):
> #   File "e:\Bluecode\code\python\code\文件的操作.py", line 6, in <module>
> #     print(f.read())
> #           ^^^^^^^^
> # ValueError: I/O operation on closed file.
> ```

##### 文件的写操作

> write()方法，文件写入，并没有真正的写入硬盘上，仅写在内存的某一个区域中，也就是缓冲区。
>
> ###### 直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中
>
> ###### 避免频繁的操作硬盘
>
> flush（）方法，内容刷新，
>
> ---
>
> ###### 使用w操作，如果这个文件存在，就覆盖原来的内容，如果文件不存在，就创建一个
>
> ```python
> f=open("./2.txt","w",encoding="utf-8")
> f.write("我去")
> f.flush()
> # 我去
> ```
>
> ###### 直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中
>
> ```python
> with open("./2.txt","w",encoding="utf-8") as f:
>     f.write("你好啊")
> # 你好啊
> ```
>
> 

##### 文件的追加

和文件的w操作类似，==只不过如果文件存在的话会在后面追加内容，不会覆盖。==

**直到调用flush或者close方法文件，才会把缓冲区的内容真正写到硬盘中**

==如果要换行加\n==

```python
#运行三次后
with open("./3.txt","a",encoding="utf-8") as f:
    f.write("这是追加模式")
# 这是追加模式这是追加模式这是追加模式


```

---

##### 文件操作综合案例

> ##### 1读取文件并查单词个数

```python
count=0
with open("./1.txt","r",encoding="utf-8") as f:
    for line in f:
        k=line.strip()
        w=k.split(" ")
        print(w)

        # print(k,end=" ")
        # print(w)
        for i in w:
            if i=="the":
                count+=1
print(f"the出现的次数是{count}")


with open("./1.txt","r",encoding="UTF-8") as f:
    # print(f.readlines())
    k=f.read()
# print(k)
p=k.split(" ")
# print(p)
# print(type(k))    
print(p.count("the"))
```

> ##### 2 读取文件，筛选部分写入文件
>
> ```python
> with open("./bill.txt","r",encoding="utf-8") as f:
>  for line in f:
>      # print(line)
>      line.strip()
>      # print(line,end="")
>      if "测试" not in line:
>          g=open("./bill副本.txt","a",encoding="utf-8")
>          g.write(f"{line}")
> # name,date,money,type,remarks
> # 周杰轮,2022-01-01,100000,消费,正式
> # 周杰轮,2022-01-02,300000,收入,正式
> # 林俊节,2022-01-01,300000,收入,正式
> # 林俊节,2022-01-03,100000,消费,正式
> # 林俊节,2022-01-05,500000,收入,正式
> # 张学油,2022-01-01,100000,消费,正式
> # 张学油,2022-01-02,500000,收入,正式
> # 王力鸿,2022-01-01,500000,消费,正式
> # 王力鸿,2022-01-03,950000,收入,正式
> # 刘德滑,2022-01-02,100000,消费,正式
> # 刘德滑,2022-01-03,300000,消费,正式
> ```
>
> ###### 3删除目标数据，切片操作
>
> ```python
> f=open("E:\PYTHON\code\啊.tax","r",encoding="UTF-8")
> data=f.read()
> data=data.replace("删掉我，",'')
> data=data[:-2]
> print(data)
> # 删掉我，
> #
> #
> # 大撒大撒
> #
> # 
> # dsadasdasdasdasdasd)}
> # 大撒大撒
> #
> #
> # dsadasdasdasdasdasd
> ```
>
> 

---

### 异常BUG

#### 了解异常

> ###### python解释器遇到一个错误，就会停止程序的执行，并演示一些错误信息。通过了解常见的异常类型，方便检查错误。

#### 为什么要捕获异常

**当程序遇到了bug，有两种选择**，后者才是想要的 

> 1. ###### 整个程序直接停止运行
>
> 2. ###### ==对bug进行提醒，整个程序继续运行==
>
>    ```python
>    try:
>        a=int(input("请输入一个数"))
>        result=8/a
>        print(result)
>    except ValueError as reason:
>        print("出错了草",str(reason))
>    except Exception as reason:
>        print("未知错误%s"%str(reason))
>    print("哎嘿")
>    # 请输入一个数0
>    # 未知错误division by zero
>    # 哎嘿
>    ```
>
>    

#### 常见的异常

> 1. assertionError assert后面的条件为假的时候就会抛出异常
> 2. attributeError 尝试访问未知的对象属性
> 3. indexError 索引超出序列范围
> 4. keyError 字典中找一个不存在的关键字
> 5. osError 操作系统产生的异常
> 6. nameError 尝试访问一个不存在的变量
> 7. syntaxError python语法错误
> 8. typeError 不同类型之间的无效操作
> 9. zerodivisionError 除数为0的时候

#### 捕获异常

###### ***捕获指定的异常***

```
try:
	检测范围
except Exception[as reason]
	出现异常后的处理代码
```

```python
try:
    with open("./4.txt","r",encoding="utf-8") as f:
        print(f.read())
except OSError as reason:
    print("出错了草",str(reason))
    
#出错了草 [Errno 2] No such file or directory: './4.txt'
```

###### 捕获多种类型异常

```
try:
	检测范围
except Exception1[as reason]
	出现异常后的处理代码
except Exception2[as reason]
	出现异常后的处理代码
except Exception3[as reason]
	出现异常后的处理代码
...

except (NameError,zerodivisionerroe) as e:
```

```python
try:
    with open("./4.txt","r",encoding="utf-8") as f:
        print(f.read())
except OSError as reason:
    print("出错了草",str(reason))
```

```python
#顶级的捕获方式-----1
try:
    a=int(input("请输入一个数"))
    result=8/a
    print(result)
except:
    print("好像出错了啊")
print("哎嘿")


#等价于------捕获全部的异常------2  顶级异常
except Exception as result:
    print("未知错误%s"%result)
# 请输入一个数0
# 好像出错了啊
# 哎嘿
```

#### 配合else使用--(可选)

**也就是没有异常就执行else后面的语句**

```python
try:
    a=int(input("请输入一个数"))
    result=8/a
    print(result)
except Exception:
    print("好像出错了啊")
else:
    print("没有异常啊")
print("哎嘿")
# 请输入一个数9
# 0.8888888888888888
# 没有异常啊
# 哎嘿
```

#### 异常的finally--(可选)

**就是有没有异常，都要执行这句话了。**

```python
try:
    a=int(input("请输入一个数"))
    result=8/a
    print(result)
except Exception:
    print("好像出错了啊")
else:
    print("没有异常啊")
finally:
    print("无所谓，有没有异常我都要执行")
print("哎嘿")
# 请输入一个数0
# 好像出错了啊
# 无所谓，有没有异常我都要执行
# 哎嘿
```

#### 异常的传递

一层一层的向上传递，如果最高层级调用了异常就抛出。

> ##### 没有捕获的时候，从出现异常的位置开始往外冒

```python
def func1():
    print("func1开始")
    1/0
    print("func1结束")
def func2():
    print("func2开始")
    func1()
    print("func2结束")
def main():
     func2()
main()


# func2开始
# func1开始
# Traceback (most recent call last):
#   File "e:\Bluecode\code\python\code\异常的传递.py", line 13, in <module>
#     func2()
#   File "e:\Bluecode\code\python\code\异常的传递.py", line 7, in func2
#     func1()
#   File "e:\Bluecode\code\python\code\异常的传递.py", line 3, in func1
#     1/0
#     ~^~
# ZeroDivisionError: division by zero
```

> ##### 当最高级有捕获的时候

```python
def func1():
    print("func1开始")
    1/0
    print("func1结束")
def func2():
    print("func2开始")
    func1()
    print("func2结束")
def main():
    try:
        func2()
    except Exception as op:
        print(op)

main()

# func2开始
# func1开始
# division by zero
```

==在最顶级就可以捕获到低级出发生的异常==

### Python模块和包

#### 什么是模块

> ###### python文件
>
> ###### 提供的现成的变量，函数，来使用

#### 如何导入模块

***写在开头***

> 1. ###### [from 模块名]  import [模块 |类|变量|函数|*] [as 别名]
>
>    ---
>
>    ##### 基本语法:
>
>    import 模块名
>
>    import 模块1，模块2
>
>    ##### 用法,==通过.==就可以使用模块的全部功能了。确定层级关系
>
>    模块.功能名()
>
>    ```python
>    import time
>    print("开始")
>    time.sleep(10)
>    print("结束")
>    # 开始
>    10s后
>    # 结束
>    ```
>
>    ##### 直接引入模块对应的功能,只需要模块的部分功能
>
>    ```python
>    from time import sleep
>    print("开始")
>    sleep(3)
>    print("结束")
>    # 开始
>    # 3s后
>    # 结束
>    ```
>
>    ###### 引入模块全部的功能，直接使用
>
>    ```python
>    from time import *
>    print("开始")
>    sleep(3)
>    print("结束")
>    # 开始
>    # 3s后
>    # 结束
>    ```
>
>    ###### 用别名来代替对应的功能,相当于改名，对于那些难听的，臭长臭长的功能
>
>    ```python
>    from time import sleep as op
>    print("开始")
>    op(3)
>    print("结束")
>    # 开始
>    # 3s后
>    # 结束
>    ```
>
>    ```python
>    import time as t
>    print("开始")
>    t.sleep(3)
>    print("结束")
>    # 开始
>    # 3s后
>    # 结束
>    ```

#### 自定义模块(\_\_main\_\_ \_\_all\_\_)

> ##### import 自定义模块的python文件名字
>
> ---
>
> ##### 自定义模块 mymodul
>
> ```python
> def add(x,y):
>     return x+y
> ```
>
> ##### 导入自定义模块
>
> ```python
> import mymolul as a
> print(a.add(1,3))
> #4
> ```
>
> ---
>
> ##### 注意事项
>
> ##### 自定义模块mymodul1
>
> ```python
> def add(x,y):
>     return x-y
> ```
>
> ##### 引用两个具有相同名字但不同功能的模块
>
> ```python
> from mymolul import add
> from mymolul1 import add
> print(add(1,3))
> # -2
> ```
>
> ##### 后者会覆盖前者
>
> ---
>
> ##### 自定义模块(_\_main\_\_)
>
> ```python
> def add(x,y):
>     print(x-y)
>     return x-y
> add(1,5)
> ```
>
> ##### 导入自定义模块 但没有任何操作
>
> ```python
> from mymolul1 import add
> #-4
> ```
>
> from 模块的时候就直接把模块给执行了
>
> ###### 在模块中用\_\_main\_\_实现在模块中可以测试，import引入模块的时候不立刻执行测试的语句
>
> ```python
> def add(x,y):
>     print(x-y)
>     return x-y
> if __name__=='__main__':
>     add(1,5)
> ```
>
> ###### 就实现导入模块的时候不执行模块的测试语句
>
> ```python
> from mymolul1 import add
> ```
>
> ---
>
> 自定义模块的\_\_all\_\_
>
> ```python
> def add(x,y):
>     print(x-y)
>     return x-y
> def add1(x,y):
>     print(x+y)
>     return x-y
> __all__=['add']
> 
> ```
>
> ```python
> from mymolul1 import *
> print(add(1,2))
> print(add1(1,2)) add1为被定义。手动导入是可以的，仅限制导入*的时候
> ```
>
> ###### 这样导入模块的时候尽管使用from 模块名 import *也只能限制all里面的可使用功能

---

###### 总结

> ##### 1.如何自定义模块并导入?
>
> 在Python代码文件中正常写代码即可,通过import、from关键字和导
> 入Python内置模块一样导入即可使用。
>
> 2. main_ 变量的功能是?
> if__ main__ == "_ \_\_main_\__\_"
>
>  ==测试语句里面的相对路径是对包的文件夹而言的不是模块文件==
>
> ###### 4.txt是在包的外面的文件
>
> ```python
> def append_to_file(file_name,data):
>     p=open(file_name,"a",encoding="UTF-8")
>     p.write(data)
> 
> if __name__=="__main__":
>     append_to_file("./4.txt","卧槽")
> 
> ```
>
> 
>
> ###### 表示，只有当程序是直接执行的才会进入
>
> ###### ==if内部，如果是被导入的，则if无法进入==
>
> 3. 注意事项
>     ●
>     不同模块，同名的功能，如果都被导入，那么后导入的会覆盖先导
>     入的
>     ●
>     _all_ 变量可以控制import *的时候哪些功能可以被导入



#### 自定义Python包

> 如果导入的模块太多，就需要一个包来管理大部分模块。相当于一个文件夹，文件夹里面一大堆模块.py
>
> 还有一个额外的 \_\_init\_\_.py
>
> ##### ==和普通的文件夹区分主要是看有无 \_\_init\_\_.py文件==

##### 自定义包

##### 导入包

> import 包名.模块名字
> 使用相关的功能
> 包.模块.功能
>
> 导入包里的具体模块，导入具体模块的时候，用对应功能的时候，模块名字.功能
>
> ```python
> import mypython包.mk
> print(mypython包.mk.add(1,3))
> #4
> ```
>
> 导入包里的具体模块
>
> ```python
> from mypython包 import mk
> print(mk.add(2,5))
> #7
> ```
>
> 导入具体包模块的功能
>
> ```python
> from mypython包.mk import add as a
> print(a(1,3))
> ```
>
> \_\_all\_\_写在init文件里可以控制*导入的范围
>
> ```
> from mypython包 import *
> 把包里所有模块都导入了，直接用模块的名和对应的功能
> mk1不存在
> ```
>
> ----
>
> > 1.什么是Python的包?
> > 包就是一个文件夹，里面可以存放许多Python的模块(代码文件)，通
> > 过包，在逻辑上将一批模块归为一类，方便使用。
> >
> > 2. _ init_ .py文件的作用 ?
> >     创建包会默认自动创建的文件，通过这个文件来表示一-个文件夹是;
> >     Python的包，而非普通的文件夹。
> > 2. \_\_all\_\_ 变量的作用?
> > 同模块中学习到的是一个作用，控制import *能够导入的内容

#### 第三方包

**安装第三方python包**

**一个包就是一堆同类型功能的集合体**

###### 如何安装第三方包

> ###### 利用python内置的pipi程序
>
> ###### win+r cmd 输入命令
>
> ###### pip install 第三方包名 国外
>
> ###### pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 包名  国内
>
> ##### 在pychrm里去解释器的设置安装

#### 案例

##### json**文件**

> ###### 轻量级的数据交互格式
>
> ###### ==相当于字符串==
>
> ###### 带有特定格式的字符串
>
> ###### 按照json指定的格式去组织和封装数据
>
> ###### json相当于国际语言，在各个编程语言中流通的数据格式，负责不同编程语言中的数据传递和交互
>
> 
>
> ###### 普通话，英语
>
> ---
>
> python格式数据------json格式数据-----C语言接受json格式数据并转换为python格式数据继续使用
>
> - `json.loads()`: 该方法用于将JSON格式的字符串转换为Python对象。它接受一个JSON字符串作为参数，并返回一个对应的Python对象。
> - `json.dumps()`: 该方法用于将Python对象==转换为JSON格式的字符串==。它接受一个Python对象作为参数，并返回一个对应的JSON字符串。
>
> ###### json格式数据化 、、、字典
>
> ```json
> import json
> 
> data = '{"name": "John", "age": 30, "city": "New York"}'
> obj = json.loads(data)
> 
> print(obj)  # 输出：{'name': 'John', 'age': 30, 'city': 'New York'}
> print(type(obj))  # 输出：dict
> ```
>
> python->json
>
> ```python
> import json
> 
> obj = {'name': 'John', 'age': 30, 'city': 'New York'}
> data = json.dumps(obj)
> 
> print(data)  # 输出：{"name": "John", "age": 30, "city": "New York"}
> print(type(data))  # 输出：str
> ```
>
> `json.dumps()`方法默认使用ASCII编码来生成JSON字符串，如果需要使用其他编码，可以通过`ensure_ascii`参数进行设置。此外，还可以通过`indent`参数设置缩进空格数，以使生成的JSON字符串更易读。

`json.dump()`和`json.dumps()`都是Python中用于将数据对象转换为JSON格式的方法，但它们之间有一些区别。

- `json.dump()`: 这个方法用于将数据对象转换为JSON格式，并将其写入文件对象中。它接受两个参数：第一个参数是要转换为JSON的数据对象，第二个参数是要写入的文件对象。示例代码如下：

  ```python
  import json

  data = {"name": "John", "age": 30}
  with open("data.json", "w") as file:
      json.dump(data, file)
  ```

  在上述代码中，`data`是一个字典对象，我们使用`json.dump()`方法将其转换为JSON格式，并将结果写入名为"data.json"的文件中。

- `json.dumps()`: 这个方法用于将数据对象转换为JSON格式，并返回一个字符串。它只接受一个参数，即要转换为JSON的数据对象。示例代码如下：

  ```python
  import json
  
  data = {"name": "John", "age": 30}
  json_str = json.dumps(data)
  ```

  在上述代码中，`data`是一个字典对象，我们使用`json.dumps()`方法将其转换为JSON格式，并将结果赋值给`json_str`变量。

总结来说，`json.dump()`用于将数据对象转换为JSON格式，并将其写入文件对象中，而`json.dumps()`用于将数据对象转换为JSON格式，并返回一个字符串。你可以根据具体的需求选择使用哪个方法。

---

##### python内置的json模块，数据相互转换

###### ==把json的数据转为python的形式，不一定是json文件==

```python
import json
data={"key1":2,"key2":2}
print("python数据转为json")
print(json.dumps(data))
data=json.dumps(data)
print("json数据转为python")
print(json.loads(data))
# python数据转为json
# {"key1": 2, "key2": 2}
# json数据转为python
# {'key1': 2, 'key2': 2}

data1=[{"key1":2,"key2":2},{"key11":2,"key2":2},{"name":"王大锤","key22":2}]
data1_json=json.dumps(data1,ensure_ascii=False)
print(type(data1_json))
print(data1_json)
# <class 'str'>
# [{"key1": 2, "key2": 2}, {"key11": 2, "key2": 2}, {"name": "\u738b\u5927\u9524", "key22": 2}]
# 不用ancii码转换，原样输出
# [{"key1": 2, "key2": 2}, {"key11": 2, "key2": 2}, {"name": "王大锤", "key22": 2}]
```

> 1.json: 是一种轻量级的数据交互格式,采用完全独立于编程语言的文本
> 格式来存储和表示数据( 就是字符串)
> Python语言使用JSON有很大优势，因为: JSON无非就是-个单独的字典或-个内部元素都
> 是字典的列表
> 所以JSON可以直接和Python的字典或列表进行无缝转换。
>
> 2. json格式数据转化
>
>   ##### 通过json. dumps (data)方法把python数据转化为了json数 据data = json. dumps (data)
>
>   如果有中文可以带上: ensure_ _ascii=Fal se参数来确保中
>   文正常转换.
>
>   ##### 通过json. loads (data)方法把josn数据转化为了python列表或字典.
data = json. loads (data) 

##### pyecharts模块----利用鼠标放上去的提示写

==***bar.reversal_axis()***==

##### 1折线图2基础可视化地图map

> 1. ##### 折线图
>
>    ```python
>    import json
>    from pyecharts.charts import Line
>    from pyecharts.options import *
>    with open("./数据/日本.txt","r",encoding="UTF-8") as file:
>        data=file.read().replace("jsonp_1629350871167_29498(","")
>        data=data[:-2]
>        # print(data)
>        data=json.loads(data)
>        # print(data)
>        data=data["data"][0]["trend"]
>        xdata=data["updateDate"][:315]
>        ydata=data["list"][0]["data"][:315]
>        # print(xdata)
>        # print(ydata)
>    with open("./数据/美国.txt","r",encoding="UTF-8") as f:
>        data=f.read()
>        data=data.replace("jsonp_1629344292311_69436(","")
>        data=data[:-2]
>    
>    
>        pydata=json.loads(data)
>    
>    
>        # x轴数据
>        timedata=pydata["data"][0]["trend"]["updateDate"][:314]
>        # print(timedata)
>        # y轴数据
>        listdata=pydata["data"][0]["trend"]["list"][0]["data"][:314]
>    
>    
>    
>        line=Line()
>                                                                                                                    
>        line.add_xaxis(xdata)
>                                                                                                                    
>        line.add_yaxis("日本疫情数据",ydata,label_opts=LabelOpts(is_show=False))
>        line.add_yaxis("美国疫情数据",listdata,label_opts=LabelOpts(is_show=False))
>    
>    
>        line.set_global_opts(
>            toolbox_opts=ToolboxOpts(is_show=True),
>            tooltip_opts=TooltipOpts(is_show=True),
>            legend_opts=LegendOpts(is_show=True),
>            visualmap_opts=VisualMapOpts(is_show=True),
>            title_opts=TitleOpts(title="疫情数据",pos_left="center",pos_top="5%"),
>            datazoom_opts=DataZoomOpts(is_show=True)
>                                                                                                                    
>        )
>                                                                                                                    
>        line.render("./两国数据.html")
>    
>    2. ##### **基础可视化地图**
>    
> ```python
>    import json
> from pyecharts.charts import Map
>from pyecharts.options import *
>with open("./数据/疫情.txt","r",encoding="UTF-8") as file:
>     data=file.read()
>     data=json.loads(data)
> 
>     fordata=data["areaTree"][0]["children"]
>     # print(fordata)
> 
> 
>     listdata=[]
> 
>     for k in fordata:
>         # print(k)
>         address=k["name"]
>         peoples=k["total"]["confirm"]
>         # print(address,peoples)
>         listdata.append((address,peoples))
>     print(type(listdata),listdata)
> 
> map=Map()
> 
> map.add("各省疫情总览",listdata,"china")
> 
> map.set_global_opts(
>     visualmap_opts=VisualMapOpts(
>         is_show=True,
>         is_piecewise=True,
>         pieces=[
>             {"min":1,"max":1000,"color":"#87ceeb","label":"1-1000人"},
>             {"min":10,"max":20,"color":"blue","label":"10-20人"},
>             {"min":20,"max":100,"color":"yellow","label":"20-100人"},
>             {"min":2000,"max":3000,"color":"red","label":"2000-3000人"},
>         ]
>     ),
>     title_opts=TitleOpts(title="全国疫情")
> 
> )
> 
> 
> map.render("./疫情大地图.html")
> ```
> 
> 

---

##### 柱状图，时间柱状图,动态柱状图

**基础柱状图----------------------------------------------------------------------------------------------------------------------------------------------------------------**

```python
bar.add_yaxis("gdp",[30,40,50],label_opts=LabelOpts(position="right"))
```

***实现数值标签的位置***

```python
from pyecharts.charts import Bar
from pyecharts.options import *



bar=Bar()


bar.add_yaxis("gdp",[30,40,50])
bar.add_xaxis(["中国","美国","日本"])
bar.set_global_opts(
    legend_opts=LegendOpts(is_show=True),
    toolbox_opts=ToolboxOpts(is_show=True),
    tooltip_opts=TooltipOpts(is_show=True),
    visualmap_opts=VisualMapOpts(is_show=True),
    datazoom_opts=DataZoomOpts(is_show=True)
)
bar.reversal_axis() 
bar.render("./基础柱状图.html")
```

> ##### 1.通过Bar()构建一个柱状图对象
>
> ##### 2.和折线图一样，通过add xaxis()和add_yaxis()添加
>
> ##### x和y轴数据
>
> ##### 3.通过柱状图对象的:reversal axis()，反转x和y轴
>
> ##### 4.通过label opts=LabelOpts(position="right")设置
>
> ##### 数值标签在右侧显示

---

**时间柱状图------------------------------------------------------------------------------------------------------------------------------------------------------------------**

**在有多个柱状图bar对象的前提下，创建一个时间线timeline对象，然后给时间线对象的add方法添加多个bar对象和标题**

**from** pyecharts.charts **import** Timeline

```python
from pyecharts.charts import Bar
from pyecharts.options import *
from pyecharts.charts import Timeline




bar=Bar()
bar1=Bar()
bar2=Bar()
bar3=Bar()
bar4=Bar()
bar5=Bar()
bar6=Bar()





bar.add_yaxis("gdp",[30,40,50],label_opts=LabelOpts(position="right"))
bar.add_xaxis(["中国","美国","日本"])

bar1.add_yaxis("gdp",[35,45,45],label_opts=LabelOpts(position="right"))
bar1.add_xaxis(["中国","美国","日本"])

bar2.add_yaxis("gdp",[40,60,40],label_opts=LabelOpts(position="right"))
bar2.add_xaxis(["中国","美国","日本"])

bar3.add_yaxis("gdp",[45,30,50],label_opts=LabelOpts(position="right",font_size="30px"))
bar3.add_xaxis(["中国","美国","日本"])

bar4.add_yaxis("gdp",[205,30,50],label_opts=LabelOpts(position="right",font_size="30px"))
bar4.add_xaxis(["中国","美国","日本"])

bar5.add_yaxis("gdp",[100,30,50],label_opts=LabelOpts(position="right",font_size="30px"))
bar5.add_xaxis(["中国","美国","日本"])

bar6.add_yaxis("gdp",[205,30,50],label_opts=LabelOpts(position="right",font_size="30px"))
bar6.add_xaxis(["中国","美国","日本"])

bar.set_global_opts(
    title_opts=TitleOpts(title="时间线柱状图666666" ),
    legend_opts=LegendOpts(is_show=True),
    toolbox_opts=ToolboxOpts(is_show=True),
    tooltip_opts=TooltipOpts(is_show=True),
    visualmap_opts=VisualMapOpts(is_show=True),
    datazoom_opts=DataZoomOpts(is_show=True,pos_top="20px")
)
time=Timeline()

time.add(bar,"2001")
time.add(bar1,"2002")
time.add(bar2,"2003")
time.add(bar3,"2004")
time.add(bar4,"2010")
time.add(bar5,"2024")
time.add(bar6,"2034")

time.add_schema(
    play_interval=700,
    is_auto_play=True,
    is_loop_play=True,
)


# bar.reversal_axis()


time.render("./时间线柱状图.html")
```

**==控制时间线的属性==**

```python
time.add_schema(
    play_interval=700,
    is_auto_play=True,
    is_loop_play=True,
)
```

###### **==主题类型模块==**

```python
from pyecharts.globals import ThemeType
time=Timeline(
    {"theme":ThemeType.BUILTIN_THEMES}
)
```

##### 综合案例

***循环中每创建一个bar就add到时间线里面，是不会有问题的***

```python
from pyecharts.charts import Timeline
from pyecharts.charts import Bar
from pyecharts.globals import ThemeType
from pyecharts.options import *

with open("./数据/1960-2019全球GDP数据.csv","r",encoding="GB2312") as file:
    data=file.readlines()
    data.pop(0)
    # print(data)

zd={}

for line in data:
    # print(line)
    list=line.split(",")
    # print(list)
    year=int(list[0])
    country=list[1]
    gdp=float(list[2])
    # print(year,country,gdp)
    try:
        zd[year].append([country,gdp])
    except KeyError:
        zd[year]=[]
        zd[year].append([country,gdp])

# print(zd)
timeline=Timeline(
    {"theme":ThemeType.WALDEN}
)
timedata=zd.keys()
# print(type(timedata))

for year in timedata:
    zd[year].sort(key=lambda x:x[1],reverse=True)
    yeardata=zd[year][0:8]
    x_data=[]
    y_data=[]
    for data in yeardata:
        x_data.append(data[0])
        y_data.append(int(data[1]/100000000))



        bar=Bar()
        # x_data.reverse()
        # y_data.reverse()

        bar.add_xaxis(x_data)
        bar.add_yaxis("GDP/亿",y_data,label_opts=LabelOpts(position="right",font_size="20px"))

        bar.set_global_opts(
            # visualmap_opts=VisualMapOpts(is_show=True),
            # toolbox_opts=ToolboxOpts(is_show=True),
            # tooltip_opts=TooltipOpts(is_show=True),
            # datazoom_opts=DataZoomOpts(is_show=True),
            # legend_opts=LegendOpts(is_show=True)
            title_opts=TitleOpts(title=f"gdp{year}前八争霸")
        )
        bar.reversal_axis()
        timeline.add(bar,str(year))

timeline.add_schema(
    is_auto_play=True,
    is_loop_play=True,
    play_interval=300,
    is_timeline_show=True
)


timeline.render("./动态gdp.html")




```



### 对象

> 1. ##### 创建一个类，-》设计表格
> 2. ##### 创建具体的对象，-》打印出来
> 3. ##### 设置对象的属性值，-》学生填写

```python
# 设计类
class student:
    name=None
    number=None
    address=None
    age=None


# 实例化对象
student1=student()

student1.age=11
student1.name="林军姐"
student1.address="日本"
student1.number=1982830095

print(student1.address,student1.age,student1.name,student1.number)
# 日本 11 林军姐 1982830095
```

#### 类

##### 类的定义和使用

---

**在类内定义和变量叫成员变量**

**在类内定义和函数叫成员方法**

==**类的属性和行为都是类的成员**==

```python
class 类名:
	类的属性
	
	
	类的行为
```

##### 创建类对象的语法

###### ==对象名=类名字()==

---

##### 类的成员方法的创建

> ##### 1，和普通函数构造没太大区别，2，==只不过必须有一个形参是self，必须要有==,3，self形参不需要给对应的实参。
>
> ​     **==实例方法需要通过类的实例来调用，而不是直接通过类来调用。==**
>
> ```python
> class father:
>     name="黑马"
> 
> 
>     def a5g(self):
>         print("5g")
> father.a5g()
> ```
>
> 
>
> ##### 2. 访问成员变量的时候也要用到self

```python
# 设计类
class student:
    name=None
    number=None
    address=None
    age=None
    def sayhi(self):
        print(f"你好,我叫{self.name}")

# 实例化对象
student1=student()

student1.age=11
student1.name="林军姐"
student1.address="日本"
student1.number=1982830095 

print(student1.address,student1.age,student1.name,student1.number)
# 日本 11 林军姐 1982830095
student1.sayhi()
# 你好,我叫林军姐
```

##### 面向对象编程(属性和行为)

> ##### 类==设计图纸
>
> ##### 对象==基于图纸生产的实体

```python
class clock:
    id=None
    price=None
    def ring(self):
        import winsound
        winsound.Beep(2000,3000)
类==设计图纸


对象==基于图纸生产的实体
clock1=clock()
clock2=clock()

clock1.id="0001"
clock1.price=100

clock2.id="0002"
clock2.price=200
clock1.ring()
clock2.ring()
```

#### 类内置的方法----魔术方法

魔术方法\_\_魔术名字\_\_

很多很多，常用的

> 1. #### \_\_init\_\_---构造方法
>
>    ##### ==特点：对象实例化的时候自动执行，把参数自动传递\_\_inie\_\_方法使用==
>
>    与最基本的声明变量相比
>
>    **定义---》定义加赋值，二合一**
>
>    ```python
>    name:None
>    address=None
>    number=None
>    age=None
>    这一步可以被构造方法来代替
>    ```
>
>    ```python
>    class student:
>        name:None
>        address=None
>        number=None
>        age=None
>          
>        def __init__(self,name,address,number,age):
>          
>            self.name= name
>            self.age=age
>            self.number=number
>            self.address=address
>          
>    xrb=student("王大山","日本",198283095,17)
>    print(xrb.address)
>    print(xrb.age)
>    print(xrb.name)
>    print(xrb.number)
>       # 日本
>          
>       # 17
>          
>       # 王大山
>          
>       # 198283095
>
>
> #### \_\_str\_\_方法---字符串方法
>
> > 问题引入
>
>    ```python
>    class student:
>        name:None
>        address=None
>        number=None
>        age=None
> 
>        def __init__(self,name,address,number,age):
> 
>            self.name= name
>            self.age=age
>            self.number=number
>            self.address=address
> 
>    xrb=student("王大山","日本",198283095,17)
>    print(xrb)
>    # <__main__.student object at 0x0000024AD5537450>
>    ```
>
>    ##### 使用str魔术方法，可以直接输出对象的属性
>
>    ##### ==替换了原来的str方法 ,原来的str（对象）是内存地址,也替换了对象的打印方式==
>
>    ```python
>    class student:
>        name:None
>        address=None
>        number=None
>        age=None
> 
>        def __init__(self,name,address,number,age):
> 
>            self.name= name
>            self.age=age
>            self.number=number
>            self.address=address
>        def __str__(self):
>            return f"{self.name},{self.age},{self.address}"
> 
>    xrb=student("王大山","日本",198283095,17)
>    print(str(xrb))
>    # 王大山,17,日本
> 
>    ```
>
> ---
>
>    ##### \_\_lt\_\_方法 
>
>    > ##### 操控原来的<,原来是比较内存位置的大小
>
>    ```python
>    class student:
>        def __init__(self,name,age):
> 
>            self.name= name
>            self.age=age
> 
>        def __str__(self):
>            return f"{self.name},{self.age},{self.address}"
> 
>        def __lt__(self,other):
>            return self.age>other.age
> 
>    xrb=student("王大山",17)
>    xrb1=student("周杰伦",32)
>    print(xrb.age,xrb1.age)
>    print(xrb>xrb1)
>    print(xrb.__lt__(xrb1))
>    17,32
> 
> 
> 
> 
>    对于给定的代码，输出结果应该是不同的。
> 
>    1. 在 `print(xrb>xrb1)` 中，使用了 `>` 操作符进行比较。`>` 操作符实际上调用了对象的 `__gt__` 方法。由于 `student` 类中没有定义 `__gt__` 方法，Python 会使用默认的比较规则进行比较。默认的比较规则是基于对象的内存地址进行比较，而不是基于对象的属性。
>    2. 在 `print(xrb.__lt__(xrb1))` 中，使用了 `__lt__` 方法进行比较。`__lt__` 方法定义了对象之间的比较规则。根据 `__lt__` 方法中的逻辑，如果 `self` 对象的 `age` 属性大于 `other` 对象的 `age` 属性，它将返回 `True`，否则返回 `False`。
>    在这种情况下，`xrb` 对象的 `age` 是 17，`xrb1` 对象的 `age` 是 32。因此，`xrb.__lt__(xrb1)` 返回 `False`，而不是 `True`。
>    所以，根据提供的代码，`print(xrb>xrb1)` 的输出结果应该是 `False`，而 `print(xrb.__lt__(xrb1))` 的输出结果应该是 `False`。
>    ```
>
>    ==最好使用具体的方法，因为>,<都需要定义，默认是比较内存地址的大小，现在之定义了<号，而>还默认是比较内存地址==
>
>   ##### print(xrb.__lt__(xrb1))，或者<，才是自己定义的方法，如果符合return后面的式子就返回true
>
> ---
>
> 3. \_\_lt\_\_方法
>
>   > ##### 操控原来 的<= ，原来是比较内存位置的大小
>
>   ```python
>    class student:
>       def __init__(self,name,age):
> 
>            self.name= name
>            self.age=age
> 
>        def __str__(self):
>            return f"{self.name},{self.age},{self.address}"
> 
>        def __lt__(self,other):
>            return self.age<other.age
>       def __le__(self,other):
>            return self.age<=other.age
> 
>    xrb=student("王大山",32)
>    xrb1=student("周杰伦",32)
>   xrb2=student("林俊杰",11)
>    # print(xrb.age,xrb1.age)
>    print(xrb2<=xrb1)
>    print(xrb.__le__(xrb1))
>    # True
>    # True
>   ```
>
>    #### ==在 Python 中，`>` 操作符和 `>=` 操作符的默认行为是比较对象的内存位置，==
>
>   lt le,gt ge   < <= > >=
>
> 4. \_\_eq\_\_方法
>
>   > ##### 操控\==,原来的==是比较内存位置是否相同的
>
>   ```python
>    class student:
>       def __init__(self,name,age):
> 
>            self.name= name
>            self.age=age
> 
>        def __str__(self):
>            return f"{self.name},{self.age},{self.address}"
> 
>        def __lt__(self,other):
>            return self.age<other.age
>           def __le__(self,other):
>            return self.age<=other.age
>        def __eq__(self, other):
>            return self.age==other.age
> 
>    xrb=student("王大山",98)
>    xrb1=student("周杰伦",98)
>       xrb2=student("林俊杰",11)
>    print(xrb==xrb1)
>    print(xrb==xrb2)
>   ```

- `__gt__(self, other)` 方法用于定义大于（`>`）比较运算符的行为。它接受一个参数 `other`，表示要与当前对象进行比较的对象。返回值为布尔类型，表示当前对象是否大于 `other`。
- `__lt__(self, other)` 方法用于定义小于（`<`）比较运算符的行为。它接受一个参数 `other`，表示要与当前对象进行比较的对象。返回值为布尔类型，表示当前对象是否小于 `other`。

---

#### 封装

**把现实世界的，属性，行为，封装道类中，描述为成员变量，成员方法，从而完成程序对现实世界事物的描述**

> 苹果越狱，安卓root
>
> 就是突破权限
>
> ---
>
> #### 私有成员变量，私有成员方法
>
> 如何私有？
>
> ---
>
> ##### 1. ==如果一个属性或方法的名称以两个下划线开头，并且不以两个下划线结尾，那么它将被视为私有的。==
>
> ##### 2. ==私有成员变量和私有成员方法在类的外部是无法直接访问的。==
>
> 3==**私有成员通过公共的成员函数去调用和操作**==
>
> xxxxxx外部访问，外部修改都是不可以的
>
> 类对象无法使用
>
> ```python
> class sb:
>  __name="王大山"
>  age=None
>  def __getage(self):
>      return self.age
>  def public(self):
>      print(self.__getage())
>      return self.__name
> sbson=sb()
> sbson.age=18
> # print(sbson.__getage())
> 
> sbson.__name="周杰伦"
> print(sbson.__name)
> print(f"公共方法可以访问私有成员变量和私有成员方法,{sbson.public()}")
> 
> # __name 是私有成员变量，但是在 sbson 对象上赋值 sbson.__name = "周杰伦" 并不会修改类中的私有成员变量 __name。相反，它会创建一个新的公有成员变量 __name 并将其赋值为 "周杰伦"。因此，当你打印 sbson.__name 时，它将输出 "周杰伦"。
> # 周杰伦
> # 18
> # 公共方法可以访问私有成员变量和私有成员方法,王大山
> ```
>

#### 继承

##### **单继承**

> ##### class 类名（父类名）
>
> ##### 	类内容体
>
> ###### ==就把父亲的成员都继承过来了。==
>
> ```python
> class phone:
>     name=None
> 
> 
>     def a5g(self):
>         print("5g")
> 
> class phone2022(phone):
>     age=None
>     def a6g(self):
>         print("6g")
> a=phone2022()
> a.a5g()
> a.a6g()
> 5g
> 6g
> ```

##### **多继承**

> ##### class 类名(父类1，父类2，父类3.。。。)
>
> ##### 	类内容提体
>
> 就把所有父亲的成员继承下来了。

==***如果有同名的成员，从左到右，最左边继承的优先级最高***==

```python
class phone:
    name="黑马"


    def a5g(self):
        print("5g")


class phone1:
    name="牛马"


    def a5g(self):
        print("5g")
class phone2022(phone1,phone):
    age=None
    def a6g(self):
        print("6g")
a=phone2022()
print(a.name)
牛马
```

#### 复写

**==子类对父亲的成员不满意，就在子类重新定义父亲继承下来的那个，名字相同，就是复写==**

**复写后。子类调用类实体对象的成员是复写后 的成员**

```python
class father:
    name="黑马"


    def a5g(self):
        print("5g")

class son(father):
    age=None
    name="牛马"
    def a6g(self):
        print("6g")

    def a5g(self):
        print("555555g")
a=son()
print(a.name)
a.a5g()
# 牛马
# 555555g
```

**但复写后，还想使用父类原来的成员，也就是复写前的父类成员**

> 1. #### 用父类名.成员   类外==，子类内都可以使用== 
>
>    **在类外调用成员行为需要实例化一个对象先**
>
>    **在子类里面调用父类的行为需要加（self）参数**
>
> 2. #### super().父类成员  ==只能在子类的类体内使用== ★★★★★★★★

```python
class father:
    name="黑马"


    def a5g(self):
        print("5g")

class son(father):
    age=None
    name="牛马"
    def a6g(self):
        print(super().name)
        print(father.name)

        father.a5g(self)
        super().a5g()
    

    
a=son()
print(a.name)
a.a6g()
print(father.name)
# 牛马
# 黑马
# 黑马
# 黑马

```

#### 类型注解

**方便开发者看**

**帮助ide代码提示**

**标记错了也不影响运行**

**变量:类型**

**数据容器:类型[类型注解挨个，如果统一写一个就ok]**

**数据容器都用[]**

##### 变量，数据容器的类型注解

```python
a:int=10
b=10
class sb:
    name:str=None

xrb:sb=sb()
mylist:list=[1,2,3,4]
mylist1:list[int]=[1,2,3,4]
mytuple:tuple=(1,2,3,4)
mytuple1:tuple[int,str]=(1,"adsad")

myset:set={1,2,3,4}
myset1:set[int]={1,2,34}


mydict:dict={"ky1":1,"ky2":2}
mydict1:dict[str,int]
```

> ##### **给无法直接看出变量类型的变量添加类型注解**

---

##### **函数参数的类型注解**

***就会有类型提示了，ide知道了***

```python
def func(a:int,b:str):
    print(a,b)

func(1,"你好")
```

##### 函数返回值的类型注解

***-\>就会帮函数的返回值给予提示***

```python
def func(a:int,b:str)->int:
    print(a,b)
    return a
```

##### Union类型注解

1. ##### 导入Union模块

2. ##### 注释的时候如果里面的数据多，且是混合的，之前的挨个注释就不太方便了

3. ##### union[数据类型1，数据类型2]

4. ##### 表示要么是数据类型1，要么是数据类型2

   ```python
   from typing import Union
   
   mylist:list[Union[int,str]]=[1,2,34,"s","b","c"]
   mydict={1:2,2:3,"1":"你好","2":"我去"}
   mydict:dict[Union[int,str],Union[int,str]]={1:2,2:3,"1":"你好","2":"我去"}
   
   def a(data:Union[int,str])->Union[int,str]:
       pass
   a()提示
   (variable) def a(data: int | str) -> (int | str)
       
   ```

#### 多态

**多种状态，完成某个行为的时候，使用不同的对象得到不同的结果**

**animal；相当于顶层设计，设计一个标准**

```python
class animal:
    def speak(self):
        pass
class dog:
    def speak(self):
        print("汪汪汪")
class cat:
    def speak(self):
        print("喵喵喵")

def jiao(a:animal):
    a.speak()

dog=dog()
cat=cat()

jiao(dog)
jiao(cat)
汪汪汪
喵喵喵
```

**抽象类（接口）：含有抽象方法的类**

**抽象方法：方法体的实现是空的PASS**

**顶层设计有多少个抽象方法，以后就要有对应几个函数。**

**顶层设计标准，子类来实现具体的功能**

**要求子类必须复写实现具体的功能**

```python
class airconditioner:
    def make_cool(self):
        pass
    def make_hot(self):
        pass
    def swing(self):
        pass
 
class geli(airconditioner):
    def make_cool(self):
        print("格力的制冷")
    def make_hot(self):
        print("格力的制热")
    def swing(self):
        print("格力的左右摇摆")

class meidi(airconditioner):
    def make_cool(self):
        print("美的的制冷")
    def make_hot(self):
        print("美的的制热")
    def swing(self):
        print("美的的左右摇摆")

def mc(object:airconditioner):
    object.make_cool()
def mh(object:airconditioner):
    object.make_hot()
def swing(object:airconditioner):
    object.swing()



airmeidi=meidi()
airgeli=geli()

mc(airgeli)
mc(airmeidi)
# 格力的制冷
# 美的的制冷
mh(airgeli)
mh(airmeidi)
# 格力的制热
# 美的的制热
swing(airgeli)
swing(airmeidi)
# 格力的左右摇摆
# 美的的左右摇摆


```

### SQL数据库（简单入门）

**==字符串的值，出现在sql语句中，必须用单引号包起来==**

**后端=sql+编程语言**

**SQL开发人员必备技能**

**SQL{pyspark，pyflink,BI可视化}**

***数据的存储，数据库管理系统***

---

**==数据库是对数据库数据的操作管理查询==**

***而操控数据库需要用到SQL语言***

组织数据：库->表->数据





> 1. 进入mysql开发环境
>
>    mysql -uroot -p
>
>    >  在命令行环境中
>    >
>    > 1. show databases;查看有哪些数据库
>    > 2. use 数据库名  使用某个数据库
>    > 3. show tables 查看数据库内有哪些表
>    > 4. exit 退出数据库



**mysql图形化工具DBeaver	免费开源**

SQL语言的分类

> 1. 数据定义
>
>    1. 数据定义D D L   -define
>    2. 数据操纵D M L   -manipulate
>    3. 数据控制D C L   - control
>    4. 数据查询D Q L   quer
>
> 2. 简单语法
>
>    ```sql
>    show databases;
>    SHOW databases;
>    show
>    databases;
>    # dsadsadasd
>    -- dasdadasd
>    /*三大
>     * 大撒大撒
>     * 撒大苏打
>     * 
>     */*/
>    ```
>
>    ##### 对大小写不敏感
>
>    ##### 可以换行写，但必须以;结尾
>
>    ##### 三种注释方法:单行:#(空格),-空格,
>
>    ##### 						多行:/**/

#### 数据定义D D L

**库管理**

> 1. 查看数据库
>
>    ##### show databases;
>
> 2. 使用数据库
>
>    ##### use 库名;
>
> 3. 创建数据库
>
>    ##### create database 库名 [charset utf-8];
>
> 4. 删除数据库
>
>    ##### drop database 库名;
>
> 5. 查看当前使用的数据库
>
>    ##### select database();

**表管理	**

> 1. 查看表
>
>    ##### 先选择数据库
>
>    ##### show tables;
>
> 2. 添加表
>
>    ##### creat table 表（
>
>    ##### 	列名 列类型,
>
>    ##### 	列名 列类型,
>
>    ##### 	列名 列类型
>
>    ##### ）;
>
>    **最后一个表的添加不需要,**
>
> 3. 删除表
>
>    ##### drop table 表名;
>
>    ##### drop table if exits 表名;
>
> ==**选中要运行的语句然后执行**==

---

#### 数据操作D M L

对表的数据操作

> 1. 数据插入insert
>
>    insert into 表名([列],,,,,) values (对应的值,,,,,,,,,)
>
>    ```sql
>    
>    insert into student(id) values (1001),(1002),(1003);
>    
>    insert  into student(id,name,age) values (001,"林俊杰",18),(002,"张杰",23);
>    
>    insert  into  student values (001,"林俊杰",18),(002,"张杰",23);
>    ```
>
> 2. 数据的删除delete
>
>    ##### delete from 表名 [where 条件判断];
>
>    ##### 条件判断:> < = >= <= !=
>
>    ```sql
>    delete from student where id=1;
>    删除具体的
>    delete from student;
>    删除整张表
>    ```
>
> 3. 数据的更新update
>
>    ##### update 表 set 列=值 [where 条件判断];
>
>    ##### 条件判断:> < = >= <= !=
>
>    ```sql
>    update student set name="牛马程序员" where id=1;
>    ```

#### 数据查找 D Q L



> 1. ##### 最基础的数据查找
>
>    select  列表 from 表
>
>    *代表该表的所有列
>
>    where 条件判断
>
>    ```sql
>    select name,age,gender from students;
>    select * from students;
>    select * from students age>=18;
>    ```
>
> 2. 分组聚合
>
>    基础语法: group by 列，按照列分组
>
>    ###### SELECT==字段==|聚合函数 FROM 表[WHERE条件] ==GROUP BY列==
>
>    **==GROUP BY中出现了哪个列，哪个列才能出现在SELECT中的非聚合中。==**
>
>    聚合函数有:
>    SUM(列)求和
>    AVG(列)求平均值
>    MIN(列)求最小值
>    MAX(列)求最大值
>    COUNT(列| *）:求数量
>
> 
>
>    ```sql
>    select sex,avg(age) from student group by sex;
>    ```

#### 数据排序 D C L

> ##### **select** 列|* **from** student [**where** 条件判断] **order** **by** 字段 [asc|desc] ;
>
> 默认是asc，也就是升序。
>
> 按照字段排序
>
> ```sql
> select * from student where age>=18 order by age;
> ```
>
> 加个限制条件
>
> ```sql
> select * from student where age>=18 order by age limit n[,m];
> ```
>
> 只有n的时候就取前n条数据
>
> 既有n又有m的时候是取n（不包含第n条)之后的m条数据

where,group by ,order by,limit 都可以省略，按照需求

---

执行顺序:
FROM -> WHERE -> GROUP BY和聚合函数-> SELECT -> ORDER BY ->LIMIT



#### PYTHON&mysql

**获取链接对象**

```sql
#导入模块
from pymysql import Connect

#connection(主机，端口，用户，密码)得到链接对象
sql=Connect(
    host="localhost",
    port=3306,
    user="root",
    passwd="zzuli4514"
)

#关闭链接
sql.close()
```

**sql执行语句创建表单**

创建

```sql
#导入模块
from pymysql import Connect
#创建链接对象
sql=Connect(
    host="localhost",
    port=3306,
    user="root",
    passwd="zzuli4514"
)
print(sql.get_server_info())
#链接数据库
sql.select_db("text001")
#创建对应的游标对象
cursor=sql.cursor()
#执行sql
cursor.execute("create table sb2(id int)")
#关闭链接

sql.close()
```

查询相关功能

利用游标对象执行不同的excute语句

```sql
#导入模块
from pymysql import Connect
#创建链接对象
sql=Connect(
    host="localhost",
    port=3306,
    user="root",
    passwd="zzuli4514"
)
print(sql.get_server_info())
#链接数据库
sql.select_db("text001")
#创建对应的游标对象
cursor=sql.cursor()

#执行sql
cursor.execute("select * from student")
data:tuple=cursor.fetchall()
for i in data:
    print(i)
# (4, '尼干吗', 13, 4, '男')
# (1, '周杰伦', 33, 1, '男')
# (2, '王大山', 43, 2, '女')
# (3, '周星驰', 23, 3, '男')
# (4, '尼干吗', 13, 4, '男')
# (1, '周杰伦', 33, 1, '男')
# (2, '王大山', 43, 2, '女')
# (3, '周星驰', 23, 3, '男')
# (4, '尼干吗', 13, 4, '男')


#关闭链接
sql.close()
```

对数据的更改，需要使用connection对象的commit方法来确认

**1,直接在创建connection对象的时候直接设置自动确认属性**

**2，在执行mysql语句后手动确认**

**只有确认的修改才能生效**

```python
from pymysql import *

connect=connect(
    host="localhost",
    autocommit=True,
    password="zzuli4514",
    user="root",
    port=3306
)


connect.select_db("text001")

cursor=connect.cursor()

cursor.execute("insert into student values (9,'林俊杰',20,3,'男');")

# connect.commit()
connect.close()
```



### 高级功能

#### 闭包

> **不定义全局变量，让函数持续的访问和修改一个外部的变量**	

**`nonlocal`是一个关键字，用于在嵌套函数中声明一个变量为非局部变量。当在一个函数内部定义了另一个函数时，内部函数可以访问外部函数的变量。然而，==默认情况下，内部函数只能读取外部函数的变量，而不能修改它们。==**

**在内部函数中使用`nonlocal`关键字声明一个变量时，Python会沿着作用域链向上查找，找到最近的外部函数中具有相同名称的变量，并将其标记为非局部变量。**

**==`nonlocal`关键字只能在嵌套函数中使用，而不能在全局作用域或单独的函数中使用。==**

```python

def account_mount(total=0):
    def atm(money,choose=True):
        nonlocal total
        if choose:
            total+=money
            print(f"取款:+{money},账户余额:{total}")

        else:
            total-=money
            print(f"取款:-{money},账户余额:{total}")


    return atm
print(f"无需通过定义全局变量，就可以通过函数实现持续访问，操作某个值")
print(f"闭包使用的变量在函数内，很难被错误的误改")
print(f"缺点，由于一直持续的引用外部函数的变量，会占用内存")



atm=account_mount()
atm(100)
atm(100)
atm(100,choose=False)
无需通过定义全局变量，就可以通过函数实现持续访问，操作某个值
闭包使用的变量在函数内，很难被错误的误改
缺点，由于一直持续的引用外部函数的变量，会占用内存
取款:+100,账户余额:100
取款:+100,账户余额:200
取款:-100,账户余额:100
```

---

#### 装饰器	

**在不修改原函数的内容的情况下**

实现给原函数添加新的功能



```python
import time
import random

def sleep():
    print("睡眠中。。。")
    time.sleep(random.randint(0,5))

def outer(sleep):
    def inner():
        print("我要汤姆睡觉了")
        sleep()
        print("我要汤姆起床了")
    return inner

sheep=outer(sleep)
sheep()
# 我要汤姆睡觉了
# 睡眠中。。。
# 我要汤姆起床了
 
```

改进后的写法，@**outer **

```python
import time
import random



def outer(sleep):
    def inner():
        print("我要汤姆睡觉了")
        sleep()
        print("我要汤姆起床了")
    return inner


@outer
def sleep():
    print("睡眠中。。。")
    time.sleep(random.randint(0,5))


sleep()
# 我要汤姆睡觉了
# 睡眠中。。。
# 我要汤姆起床了

```

#### 单例模式

**编程套路**

```python
class sb:
    name=None
SB=sb()
```

​	**减少内存损耗，提供多个接口，只实例一个对象，导包传入一个对象。**

```python
from 包 import sb,SB

s1=SB
s2=SB



print(s1)
print(s2)
# <包.sb object at 0x00000247FA22B590>
# <包.sb object at 0x00000247FA22B590>
```

#### 工厂模式

当要创建很多很多对象的时候

有统一的getperson（）入口  易于维护

当发生修改的时候只修改工厂的方法就可以了



```python
class student:
    pass
class teacher:
    pass
class worker:
    pass

class factory:
    def getperson(self,type):
        if type=='w':
            return worker()
        elif type=='t':
            return teacher()
        else:
            return student()
        


person=factory()
worker=person.getperson('w')
teacher=person.getperson('t')
student=person.getperson('s')
```

#### 进程，线程, 并行执行

**一个操作系统中可以有多个进程，多任务运行**

**一个进程可以运行多个线程，多线程运行**

![image-20230717134650413](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230717134650413.png)

**一个进程可以有多个线程，线程之间内存是共享的。**

**不同线程之间的内存是隔离的**

**并行执行**

同一时间做多个事情。	



#### 多线程编程

**调用threading模块，创造一个线程对象就是一个线程**

**线程一般都持久干活**

```python
import threading,time


def sing():
    while True:
        print("我在唱歌啦啦啦啦啦")
        time.sleep(1)


def dance():
    while True:
        print("我在跳舞嘎嘎")
        time.sleep(1)

sing=threading.Thread(target=sing)
dance=threading.Thread(target=dance)


sing.start()
dance.start()

一边唱歌一边跳舞
```

参数

​    group: *None* **=** None,**忽略**
​    target: ((...) -> **object**) **|** *None* **=** None, **执行任务名称**
​    name: **str** **|** *None* **=** None, **线程名一般不设置**
​    args: Iterable[Any] **=** (), **以元组的形式传参**
​    kwargs: Mapping[**str**, Any] **|** *None* **=** None,  **以字典的形式传参**

因为target=任务名字，没有直接调用函数,所以要另一种方式传参

```python
import threading,time


def sing(msg):
    while True:
        print(msg)
        time.sleep(1)


def dance(msg):
    while True:
        print(msg)
        time.sleep(1)

sing=threading.Thread(target=sing,args=("我在唱歌啊啊啊啊啊",))
dance=threading.Thread(target=dance,kwargs={"msg":"我在跳舞蹬蹬咚咚"})


sing.start()
dance.start()
```

#### 网络编程Socket

进程之间的网路通信需要**socket**,数据的搬运工

---

**两个进程之间要想进行通讯,就必须有服务端和客户端**

**socket服务端**

> #### 等待其他进程的连接,可以收发信息.
>
> 1. 导入内置的socket对象
>
>    ```python
>    import socket
>    #创建一个socket对象
>    socket_severe=socket.socket()
>                                                 
>    #服务端绑定在本机和端口
>    socket_severe.bind(("localhost", 8888))
>                                                 
>    #设置服务端允许连接的数量
>    socket_severe.listen(1)
>    #等待客户端连接，这是一个阻塞语句，只有成功链接了才会执行下一句,返回一个二元元组.
>    client_socket,client_address=socket_severe.accept()
>    #表示连接的socket对象，以及客户端的地址信息。
>    print(f"蛙趣，客户端连接成功!,并且客户端的地址信息是{client_address}")
>    while True:
>        client_msg=client_socket.recv(1024).decode("UTF-8")
>        #这是一个阻塞语句，只有成功链接了才会执行下一句
>        print(f"客户端发送来的信息是:{client_msg}")
>                                                 
>        severe_sentmsg=input("要给客户端回应的信息是:")
>        client_socket.send(severe_sentmsg.encode("UTF-8"))
>        if severe_sentmsg=='exit':
>            break
>                                                   
>       client_socket.close()
>    socket_severe.close()
> 

**socket客户端**

> #### 主动连接服务端,可以收发信息.
>
> **全程使用client\_\_socket对象**,**先发送后接受**
>
> 1. 导入socket模块
>
>    ```python
>    import socket
>    #创建一个socket对象
>    client_socket=socket.socket()
>    #客户端连接具体的服务端
>                                              
>    client_socket.connect(("localhost",8888))
>                                              
>    while True:
>        sent_data=input("要给服务端发送的信息是:")
>        if sent_data=="exit":
>            break
>        client_socket.send(sent_data.encode("UTF-8"))
>                                              
>        recv_data=client_socket.recv(1024)
>                                              
>        print(f"服务端返回来的信息是:{recv_data.decode('UTF-8')}")
>          #关闭链接
>    client_socket.close()
>

#### 正则表达式

**正则表达式,又称规则表达式( Regular Expression),是使用单个字符串来描述、匹配某个句法规则的字符串,常被用**
**来检索、替换那些符合某个模式(规则)的文本。**

> 1. **match,search,findall方法**
> 1. **span得到的是对应的(起始下标，末下标+1)**
> 1. match是从头到尾开始匹配，如果刚开始都没有，后面又也没用。
> 1. search也从头开始找，但只找第一个。
> 1. findall，全部找，不管在哪能找到，并以列表的形式返回
>
> ```python
> import re
> #导入正则表达式的RE模块
> print("-----------------------match-------------------    ")
> 
> str="python itniuma python itniuma"
> #目标字符串
> result=re.match("python",str)
> #re模块的match对象实例化
> print(result)
> print(result.span())
> print(result.group())
> # <re.Match object; span=(0, 6), match='python'>
> # (0, 6)
> # python
> #从前到后开始找，如果刚开始就匹配不到，就算后面又有也没用
> # 如果没有就返回none
> 
> print("--------------------search---------------------    ")
> 
> str="1python itniuma python itniuma"
> 
> result=re.search("python",str)
> print(result)
> print(result.span())
> print(result.group())
> #  <re.Match object; span=(1, 7), match='python'>
> # (1, 7)
> # python
> #有的话只找一个！
> # 如果没有就返回none
> print("-------------------findall-----------------------    ")
> str="1python itniuma python itniuma"
> result=re.findall("python",str)
> print(result)
> # print(result.count("python"))
> # ['python', 'python']
> ```
>

---

#### 正则表达式——元字符匹配

| 字符 | 功能                                   |
| :--: | -------------------------------------- |
|  .   | 匹配任意1个字符(除了\n) ，\.匹配点本身 |
|  []  | 匹配[ ]中列举的字符                    |
|  \d  | 匹配数字，即0-9                        |
|  \D  | 匹配非数字                             |
|  \s  | 匹配空白，即空格、tab键 .              |
|  \S  | 匹配非空白                             |
|  \w  | 匹配单词字符，即a-Z、A-Z、  日-9、 _   |
|  \W  | 匹配非单词字符                         |

r标记是查找原始的字符串，转义字符无效

**数量匹配**

| 字符  | 功能                                        |
| ----- | ------------------------------------------- |
| *     | 匹配前一个规则的字符出现0至无数次  [0,+∞)   |
| +     | 匹配前一个规则的字符出现1至无数次   [1,+∞)  |
| ？    | 匹配前一个规则的字符出现0次或1次     o\|\|1 |
| {m}   | 匹配前一个规则的字符出现m次    ==m          |
| {m,}  | 匹配前一个规则的字符出现最少m次  >=m        |
| {m,n} | 匹配前一个规则的字符出现m到n次   [m,n]      |

**边界匹配**

^$匹配整体需要加这个

| 字符 | 功能               |
| ---- | ------------------ |
| ^    | 匹配字符串开头     |
| $    | 匹配字符串结尾     |
| \b   | 匹配一个单词的边界 |
| \B   | 匹配非单词边界     |

分组匹配

| 字符 | 功能                     |
| :--: | :----------------------- |
|  \|  | 匹配左右任意一个表达式   |
| （） | 将括号中字符作为一个分组 |

![image-20230720182736642](C:\Users\许闰博\AppData\Roaming\Typora\typora-user-images\image-20230720182736642.png)

如果正则表达式里面有（），会把每一个（）都列出来，findall，每一个组的匹配返回，可以外加一个大括号.







